{
  "RB-WIN-AD-001": {
    "id": "RB-WIN-AD-001",
    "name": "Active Directory Health",
    "platform": "windows",
    "detect_script": "# Check AD health (run on Domain Controller)\n$Result = @{\n    IsDomainController = $false\n    Drifted = $false\n}\n\ntry {\n    Import-Module ActiveDirectory -ErrorAction Stop\n    $DC = Get-ADDomainController -Discover -ErrorAction Stop\n    $Result.IsDomainController = $true\n    $Result.DomainController = $DC.HostName\n\n    # Check replication status\n    $ReplStatus = repadmin /showrepl /csv | ConvertFrom-Csv\n    $FailedRepl = $ReplStatus | Where-Object { $_.\"Number of Failures\" -gt 0 }\n    $Result.ReplicationFailures = $FailedRepl.Count\n\n    # Check locked out accounts\n    $LockedAccounts = Search-ADAccount -LockedOut\n    $Result.LockedAccountCount = $LockedAccounts.Count\n    $Result.LockedAccounts = @($LockedAccounts | Select-Object -First 10 | Select-Object SamAccountName, LockedOut)\n\n    # Check DNS\n    $DNSServer = Resolve-DnsName -Name $DC.Domain -Type A -ErrorAction SilentlyContinue\n    $Result.DNSHealthy = ($null -ne $DNSServer)\n\n    $Result.Drifted = ($FailedRepl.Count -gt 0) -or ($LockedAccounts.Count -gt 5)\n\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.IsDomainController = $false\n}\n\n$Result | ConvertTo-Json -Depth 3",
    "remediate_script": "# AD remediation actions\nImport-Module ActiveDirectory\n\n$Actions = @()\n\n# Unlock accounts that have been locked > 30 minutes\n$LockedAccounts = Search-ADAccount -LockedOut\nforeach ($Account in $LockedAccounts) {\n    $LockoutTime = (Get-ADUser $Account.SamAccountName -Properties AccountLockoutTime).AccountLockoutTime\n    if ($LockoutTime -and ((Get-Date) - $LockoutTime).TotalMinutes -gt 30) {\n        Unlock-ADAccount -Identity $Account.SamAccountName\n        $Actions += \"Unlocked: $($Account.SamAccountName)\"\n    }\n}\n\n# Force replication\nrepadmin /syncall /AdeP\n\n@{\n    AccountsUnlocked = $Actions.Count\n    Actions = $Actions\n    ReplicationForced = $true\n} | ConvertTo-Json",
    "verify_script": "Import-Module ActiveDirectory\n$LockedAccounts = Search-ADAccount -LockedOut\n@{\n    LockedAccountCount = $LockedAccounts.Count\n    Verified = ($LockedAccounts.Count -le 5)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(a)(1)",
      "164.308(a)(3)(ii)(C)"
    ],
    "severity": "high",
    "timeout_seconds": 300
  },
  "RB-WIN-AV-001": {
    "id": "RB-WIN-AV-001",
    "name": "Windows Defender Health",
    "platform": "windows",
    "detect_script": "# Check Windows Defender status\ntry {\n    $DefenderStatus = Get-MpComputerStatus\n    $SignatureAge = (Get-Date) - $DefenderStatus.AntivirusSignatureLastUpdated\n\n    $Result = @{\n        RealTimeProtection = $DefenderStatus.RealTimeProtectionEnabled\n        AntivirusEnabled = $DefenderStatus.AntivirusEnabled\n        AntispywareEnabled = $DefenderStatus.AntispywareEnabled\n        SignatureVersion = $DefenderStatus.AntivirusSignatureVersion\n        SignatureLastUpdated = $DefenderStatus.AntivirusSignatureLastUpdated.ToString(\"o\")\n        SignatureAgeDays = [math]::Round($SignatureAge.TotalDays, 1)\n        QuickScanAge = $DefenderStatus.QuickScanAge\n        FullScanAge = $DefenderStatus.FullScanAge\n        Drifted = (-not $DefenderStatus.RealTimeProtectionEnabled) -or ($SignatureAge.TotalDays -gt 3)\n    }\n\n    $Result | ConvertTo-Json\n} catch {\n    @{\n        Error = $_.Exception.Message\n        Drifted = $true\n        DefenderNotInstalled = $true\n    } | ConvertTo-Json\n}",
    "remediate_script": "# Enable Windows Defender and update signatures\ntry {\n    # Enable real-time protection\n    Set-MpPreference -DisableRealtimeMonitoring $false\n\n    # Update signatures\n    Update-MpSignature -ErrorAction Stop\n\n    # Run quick scan if signatures were stale\n    Start-MpScan -ScanType QuickScan -AsJob\n\n    @{\n        RealTimeEnabled = $true\n        SignaturesUpdated = $true\n        QuickScanStarted = $true\n    } | ConvertTo-Json\n} catch {\n    @{\n        Error = $_.Exception.Message\n        Success = $false\n    } | ConvertTo-Json\n}",
    "verify_script": "# Verify Defender is healthy\n$DefenderStatus = Get-MpComputerStatus\n$SignatureAge = (Get-Date) - $DefenderStatus.AntivirusSignatureLastUpdated\n\n@{\n    RealTimeProtection = $DefenderStatus.RealTimeProtectionEnabled\n    SignatureAgeDays = [math]::Round($SignatureAge.TotalDays, 1)\n    Verified = $DefenderStatus.RealTimeProtectionEnabled -and ($SignatureAge.TotalDays -le 3)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.308(a)(5)(ii)(B)",
      "164.312(b)"
    ],
    "severity": "critical",
    "timeout_seconds": 600
  },
  "RB-WIN-BACKUP-001": {
    "id": "RB-WIN-BACKUP-001",
    "name": "Backup Verification",
    "platform": "windows",
    "detect_script": "# Check backup status (Windows Server Backup or Veeam)\n$Result = @{\n    BackupType = \"Unknown\"\n    LastBackup = $null\n    BackupAgeHours = 999\n    Drifted = $true\n}\n\n# Try Windows Server Backup first\ntry {\n    $WBSummary = Get-WBSummary -ErrorAction Stop\n    if ($WBSummary.LastSuccessfulBackupTime) {\n        $Age = (Get-Date) - $WBSummary.LastSuccessfulBackupTime\n        $Result = @{\n            BackupType = \"WindowsServerBackup\"\n            LastBackup = $WBSummary.LastSuccessfulBackupTime.ToString(\"o\")\n            BackupAgeHours = [math]::Round($Age.TotalHours, 1)\n            NextBackup = $WBSummary.NextBackupTime\n            LastResult = $WBSummary.LastBackupResultHR\n            Drifted = ($Age.TotalHours -gt 24)\n        }\n    }\n} catch {\n    # WSB not available, try Veeam\n    try {\n        Add-PSSnapin VeeamPSSnapin -ErrorAction Stop\n        $VeeamJob = Get-VBRJob | Where-Object { $_.IsScheduleEnabled } | Select-Object -First 1\n        if ($VeeamJob) {\n            $LastSession = Get-VBRBackupSession -Job $VeeamJob | Sort-Object CreationTime -Descending | Select-Object -First 1\n            $Age = (Get-Date) - $LastSession.CreationTime\n            $Result = @{\n                BackupType = \"Veeam\"\n                JobName = $VeeamJob.Name\n                LastBackup = $LastSession.CreationTime.ToString(\"o\")\n                BackupAgeHours = [math]::Round($Age.TotalHours, 1)\n                LastResult = $LastSession.Result\n                Drifted = ($Age.TotalHours -gt 24) -or ($LastSession.Result -ne \"Success\")\n            }\n        }\n    } catch {\n        $Result.Error = \"No backup solution detected\"\n    }\n}\n\n$Result | ConvertTo-Json",
    "remediate_script": "# Trigger backup job\n$Result = @{ Success = $false }\n\n# Try Windows Server Backup\ntry {\n    $Policy = Get-WBPolicy -ErrorAction Stop\n    if ($Policy) {\n        Start-WBBackup -Policy $Policy -Async\n        $Result = @{\n            Success = $true\n            BackupType = \"WindowsServerBackup\"\n            Message = \"Backup job started\"\n        }\n    }\n} catch {\n    # Try Veeam\n    try {\n        Add-PSSnapin VeeamPSSnapin -ErrorAction Stop\n        $VeeamJob = Get-VBRJob | Where-Object { $_.IsScheduleEnabled } | Select-Object -First 1\n        if ($VeeamJob) {\n            Start-VBRJob -Job $VeeamJob -RunAsync\n            $Result = @{\n                Success = $true\n                BackupType = \"Veeam\"\n                JobName = $VeeamJob.Name\n                Message = \"Veeam backup job started\"\n            }\n        }\n    } catch {\n        $Result.Error = $_.Exception.Message\n    }\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "# Verify backup completed\nStart-Sleep -Seconds 60  # Wait for backup to start\n\ntry {\n    $WBSummary = Get-WBSummary -ErrorAction Stop\n    $Age = (Get-Date) - $WBSummary.LastSuccessfulBackupTime\n    @{\n        BackupAgeHours = [math]::Round($Age.TotalHours, 1)\n        Verified = ($Age.TotalHours -lt 24)\n    } | ConvertTo-Json\n} catch {\n    @{ Verified = $false; Error = $_.Exception.Message } | ConvertTo-Json\n}",
    "hipaa_controls": [
      "164.308(a)(7)(ii)(A)",
      "164.310(d)(2)(iv)"
    ],
    "severity": "critical",
    "timeout_seconds": 3600
  },
  "RB-WIN-ENCRYPTION-001": {
    "id": "RB-WIN-ENCRYPTION-001",
    "name": "BitLocker Encryption",
    "platform": "windows",
    "detect_script": "# Check BitLocker status\n$Volumes = Get-BitLockerVolume\n\n$Result = @{\n    Volumes = @()\n    AllEncrypted = $true\n    Drifted = $false\n}\n\nforeach ($Vol in $Volumes) {\n    $VolInfo = @{\n        MountPoint = $Vol.MountPoint\n        VolumeStatus = $Vol.VolumeStatus.ToString()\n        ProtectionStatus = $Vol.ProtectionStatus.ToString()\n        EncryptionPercentage = $Vol.EncryptionPercentage\n        KeyProtector = ($Vol.KeyProtector | Select-Object -First 1).KeyProtectorType.ToString()\n    }\n    $Result.Volumes += $VolInfo\n\n    # Check if system drive is encrypted\n    if ($Vol.MountPoint -eq \"C:\" -and $Vol.VolumeStatus -ne \"FullyEncrypted\") {\n        $Result.AllEncrypted = $false\n        $Result.Drifted = $true\n    }\n}\n\n$Result | ConvertTo-Json -Depth 3",
    "remediate_script": "# NOTE: BitLocker enablement requires careful planning\n# This is an ALERT-ONLY runbook - full encryption requires manual intervention\n\n@{\n    Action = \"ALERT\"\n    Message = \"BitLocker not enabled on system drive. Manual intervention required.\"\n    Recommendation = \"Enable BitLocker via: Enable-BitLocker -MountPoint 'C:' -EncryptionMethod XtsAes256 -UsedSpaceOnly -RecoveryPasswordProtector\"\n    Warning = \"Ensure recovery key is backed up to AD or secure location before enabling\"\n} | ConvertTo-Json",
    "verify_script": "$Vol = Get-BitLockerVolume -MountPoint \"C:\"\n@{\n    VolumeStatus = $Vol.VolumeStatus.ToString()\n    Verified = ($Vol.VolumeStatus -eq \"FullyEncrypted\")\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(a)(2)(iv)",
      "164.312(e)(2)(ii)"
    ],
    "severity": "critical",
    "timeout_seconds": 60
  },
  "RB-WIN-FIREWALL-001": {
    "id": "RB-WIN-FIREWALL-001",
    "name": "Windows Firewall Status",
    "platform": "windows",
    "detect_script": "# Check Windows Firewall status\n$Profiles = Get-NetFirewallProfile\n\n$Result = @{\n    Domain = @{\n        Enabled = ($Profiles | Where-Object { $_.Name -eq \"Domain\" }).Enabled\n        DefaultInboundAction = ($Profiles | Where-Object { $_.Name -eq \"Domain\" }).DefaultInboundAction\n    }\n    Private = @{\n        Enabled = ($Profiles | Where-Object { $_.Name -eq \"Private\" }).Enabled\n        DefaultInboundAction = ($Profiles | Where-Object { $_.Name -eq \"Private\" }).DefaultInboundAction\n    }\n    Public = @{\n        Enabled = ($Profiles | Where-Object { $_.Name -eq \"Public\" }).Enabled\n        DefaultInboundAction = ($Profiles | Where-Object { $_.Name -eq \"Public\" }).DefaultInboundAction\n    }\n    AllEnabled = ($Profiles | Where-Object { -not $_.Enabled }).Count -eq 0\n    Drifted = ($Profiles | Where-Object { -not $_.Enabled }).Count -gt 0\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "remediate_script": "# Enable Windows Firewall on all profiles\nSet-NetFirewallProfile -Profile Domain,Public,Private -Enabled True\n\n# Set default inbound action to Block\nSet-NetFirewallProfile -Profile Domain,Public,Private -DefaultInboundAction Block\n\n@{\n    FirewallEnabled = $true\n    DefaultInboundAction = \"Block\"\n} | ConvertTo-Json",
    "verify_script": "$Profiles = Get-NetFirewallProfile\n@{\n    AllEnabled = ($Profiles | Where-Object { -not $_.Enabled }).Count -eq 0\n    Verified = ($Profiles | Where-Object { -not $_.Enabled }).Count -eq 0\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(a)(1)",
      "164.312(e)(1)"
    ],
    "severity": "critical",
    "timeout_seconds": 120
  },
  "RB-WIN-LOGGING-001": {
    "id": "RB-WIN-LOGGING-001",
    "name": "Windows Event Logging",
    "platform": "windows",
    "detect_script": "# Check audit policy and event log health\n$AuditPolicy = auditpol /get /category:* /r | ConvertFrom-Csv\n\n$RequiredPolicies = @(\n    \"Logon\",\n    \"Logoff\",\n    \"Account Lockout\",\n    \"User Account Management\",\n    \"Security Group Management\",\n    \"Process Creation\",\n    \"Object Access\"\n)\n\n$MissingPolicies = @()\nforeach ($Policy in $RequiredPolicies) {\n    $Found = $AuditPolicy | Where-Object { $_.Subcategory -like \"*$Policy*\" -and ($_.\"Inclusion Setting\" -ne \"No Auditing\") }\n    if (-not $Found) {\n        $MissingPolicies += $Policy\n    }\n}\n\n# Check event log sizes\n$SecurityLog = Get-WinEvent -ListLog Security\n$SystemLog = Get-WinEvent -ListLog System\n\n$Result = @{\n    AuditPoliciesConfigured = ($MissingPolicies.Count -eq 0)\n    MissingPolicies = $MissingPolicies\n    SecurityLogMaxSizeMB = [math]::Round($SecurityLog.MaximumSizeInBytes / 1MB, 0)\n    SecurityLogRetentionDays = $SecurityLog.LogRetention\n    SecurityLogEnabled = $SecurityLog.IsEnabled\n    SystemLogEnabled = $SystemLog.IsEnabled\n    Drifted = ($MissingPolicies.Count -gt 0) -or (-not $SecurityLog.IsEnabled)\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "remediate_script": "# Configure audit policy for HIPAA compliance\n# Using direct auditpol calls instead of Invoke-Expression for security\n$Policies = @(\n    @{ Subcategory = \"Logon\"; Success = $true; Failure = $true },\n    @{ Subcategory = \"Logoff\"; Success = $true; Failure = $false },\n    @{ Subcategory = \"Account Lockout\"; Success = $true; Failure = $true },\n    @{ Subcategory = \"User Account Management\"; Success = $true; Failure = $true },\n    @{ Subcategory = \"Security Group Management\"; Success = $true; Failure = $true },\n    @{ Subcategory = \"Process Creation\"; Success = $true; Failure = $true },\n    @{ Subcategory = \"Audit Policy Change\"; Success = $true; Failure = $true }\n)\n\n$Results = @()\nforeach ($Policy in $Policies) {\n    $SuccessArg = if ($Policy.Success) { \"/success:enable\" } else { \"/success:disable\" }\n    $FailureArg = if ($Policy.Failure) { \"/failure:enable\" } else { \"/failure:disable\" }\n    $Args = @(\"/set\", \"/subcategory:`\"$($Policy.Subcategory)`\"\", $SuccessArg, $FailureArg)\n\n    $Proc = Start-Process -FilePath \"auditpol.exe\" -ArgumentList $Args -NoNewWindow -Wait -PassThru\n    $Results += @{ Subcategory = $Policy.Subcategory; ExitCode = $Proc.ExitCode }\n}\n\n# Ensure Security log is properly sized (at least 1GB)\n$Log = Get-WinEvent -ListLog Security\nif ($Log.MaximumSizeInBytes -lt 1GB) {\n    Limit-EventLog -LogName Security -MaximumSize 1GB\n}\n\n@{\n    CommandsExecuted = $Results.Count\n    Success = ($Results | Where-Object { $_.ExitCode -ne 0 }).Count -eq 0\n} | ConvertTo-Json",
    "verify_script": "# Verify audit policy\n$AuditPolicy = auditpol /get /category:* /r | ConvertFrom-Csv\n$LogonAudit = $AuditPolicy | Where-Object { $_.Subcategory -like \"*Logon*\" }\n\n@{\n    LogonAuditEnabled = ($LogonAudit.\"Inclusion Setting\" -ne \"No Auditing\")\n    Verified = ($LogonAudit.\"Inclusion Setting\" -ne \"No Auditing\")\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(b)",
      "164.308(a)(1)(ii)(D)"
    ],
    "severity": "high",
    "timeout_seconds": 300
  },
  "RB-WIN-PATCH-001": {
    "id": "RB-WIN-PATCH-001",
    "name": "Windows Patch Compliance",
    "platform": "windows",
    "detect_script": "# Check for pending Windows updates\n$ErrorActionPreference = \"Stop\"\n$StartTime = Get-Date\n$UpdateSession = New-Object -ComObject Microsoft.Update.Session\n$UpdateSearcher = $UpdateSession.CreateUpdateSearcher()\n\ntry {\n    $SearchResult = $UpdateSearcher.Search(\"IsInstalled=0 and Type='Software' and IsHidden=0\")\n\n    $CriticalUpdates = @($SearchResult.Updates | Where-Object { $_.MsrcSeverity -eq 'Critical' })\n    $ImportantUpdates = @($SearchResult.Updates | Where-Object { $_.MsrcSeverity -eq 'Important' })\n\n    $Result = @{\n        TotalPending = $SearchResult.Updates.Count\n        CriticalPending = $CriticalUpdates.Count\n        ImportantPending = $ImportantUpdates.Count\n        LastInstallDate = (Get-HotFix | Sort-Object InstalledOn -Descending | Select-Object -First 1).InstalledOn\n        Drifted = ($CriticalUpdates.Count -gt 0)\n        Updates = @($SearchResult.Updates | Select-Object Title, MsrcSeverity, KBArticleIDs)\n    }\n\n    $Result | ConvertTo-Json -Depth 3\n} catch {\n    @{\n        Error = $_.Exception.Message\n        Drifted = $true\n    } | ConvertTo-Json\n}",
    "remediate_script": "# Install pending critical/important updates\n$UpdateSession = New-Object -ComObject Microsoft.Update.Session\n$UpdateSearcher = $UpdateSession.CreateUpdateSearcher()\n$SearchResult = $UpdateSearcher.Search(\"IsInstalled=0 and Type='Software' and IsHidden=0\")\n\n$UpdatesToInstall = New-Object -ComObject Microsoft.Update.UpdateColl\n\nforeach ($Update in $SearchResult.Updates) {\n    if ($Update.MsrcSeverity -in @('Critical', 'Important')) {\n        $UpdatesToInstall.Add($Update) | Out-Null\n    }\n}\n\nif ($UpdatesToInstall.Count -gt 0) {\n    $Downloader = $UpdateSession.CreateUpdateDownloader()\n    $Downloader.Updates = $UpdatesToInstall\n    $DownloadResult = $Downloader.Download()\n\n    $Installer = $UpdateSession.CreateUpdateInstaller()\n    $Installer.Updates = $UpdatesToInstall\n    $InstallResult = $Installer.Install()\n\n    @{\n        UpdatesInstalled = $UpdatesToInstall.Count\n        ResultCode = $InstallResult.ResultCode\n        RebootRequired = $InstallResult.RebootRequired\n    } | ConvertTo-Json\n} else {\n    @{\n        UpdatesInstalled = 0\n        Message = \"No critical or important updates pending\"\n    } | ConvertTo-Json\n}",
    "verify_script": "# Verify updates were applied\n$UpdateSession = New-Object -ComObject Microsoft.Update.Session\n$UpdateSearcher = $UpdateSession.CreateUpdateSearcher()\n$SearchResult = $UpdateSearcher.Search(\"IsInstalled=0 and Type='Software' and IsHidden=0\")\n\n$CriticalUpdates = @($SearchResult.Updates | Where-Object { $_.MsrcSeverity -eq 'Critical' })\n\n@{\n    CriticalPending = $CriticalUpdates.Count\n    Verified = ($CriticalUpdates.Count -eq 0)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.308(a)(5)(ii)(B)",
      "164.312(c)(1)"
    ],
    "severity": "high",
    "timeout_seconds": 1800
  },
  "RB-WIN-ACCESS-001": {
    "id": "RB-WIN-ACCESS-001",
    "name": "Access Control Verification",
    "platform": "windows",
    "detect_script": "# Comprehensive access control verification\n$Result = @{\n    Drifted = $false\n    Issues = @()\n    PasswordPolicy = @{}\n    AccountLockout = @{}\n    MFAStatus = @{}\n    PrivilegedAccounts = @()\n}\n\n# Check password policy\n$NetAccounts = net accounts 2>&1\nforeach ($Line in $NetAccounts) {\n    if ($Line -match \"Minimum password length:\\s*(\\d+)\") {\n        $Result.PasswordPolicy.MinLength = [int]$Matches[1]\n        if ([int]$Matches[1] -lt 12) {\n            $Result.Drifted = $true\n            $Result.Issues += \"Password min length < 12 characters\"\n        }\n    }\n    if ($Line -match \"Maximum password age.*:\\s*(\\d+|Unlimited)\") {\n        $Result.PasswordPolicy.MaxAge = $Matches[1]\n        if ($Matches[1] -eq \"Unlimited\" -or [int]$Matches[1] -gt 90) {\n            $Result.Drifted = $true\n            $Result.Issues += \"Password max age > 90 days or unlimited\"\n        }\n    }\n    if ($Line -match \"Lockout threshold:\\s*(\\d+|Never)\") {\n        $Result.AccountLockout.Threshold = $Matches[1]\n        if ($Matches[1] -eq \"Never\" -or [int]$Matches[1] -eq 0 -or [int]$Matches[1] -gt 5) {\n            $Result.Drifted = $true\n            $Result.Issues += \"Account lockout threshold not configured (should be 3-5)\"\n        }\n    }\n}\n\n# Check for local admin accounts\n$AdminGroup = [ADSI]\"WinNT://./Administrators,group\"\n$Admins = @($AdminGroup.Invoke(\"Members\")) | ForEach-Object {\n    $Path = ([ADSI]$_).Path\n    $Name = $Path.Split(\"/\")[-1]\n    @{ Name = $Name; Type = if ($Path -match \"WinNT://[^/]+/[^/]+$\") { \"Local\" } else { \"Domain\" } }\n}\n$Result.PrivilegedAccounts = $Admins\n$LocalAdmins = @($Admins | Where-Object { $_.Type -eq \"Local\" })\nif ($LocalAdmins.Count -gt 2) {\n    $Result.Drifted = $true\n    $Result.Issues += \"More than 2 local admin accounts found ($($LocalAdmins.Count))\"\n}\n\n# Check for disabled accounts that should be removed\n$DisabledLocalUsers = Get-LocalUser | Where-Object { -not $_.Enabled -and $_.LastLogon -lt (Get-Date).AddDays(-90) }\nif ($DisabledLocalUsers.Count -gt 0) {\n    $Result.Issues += \"$($DisabledLocalUsers.Count) stale disabled accounts found\"\n}\n\n# Check password complexity via secedit\n$TempCfg = \"$env:TEMP\\secpol_check.cfg\"\nsecedit /export /cfg $TempCfg /areas SECURITYPOLICY 2>&1 | Out-Null\nif (Test-Path $TempCfg) {\n    $SecPol = Get-Content $TempCfg\n    $Complexity = ($SecPol | Select-String \"PasswordComplexity\\s*=\\s*1\") -ne $null\n    $Result.PasswordPolicy.ComplexityEnabled = $Complexity\n    if (-not $Complexity) {\n        $Result.Drifted = $true\n        $Result.Issues += \"Password complexity not enabled\"\n    }\n    Remove-Item $TempCfg -Force -ErrorAction SilentlyContinue\n}\n\n# Check for Windows Hello / MFA indicators\ntry {\n    $CredProvider = Get-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Authentication\\Credential Providers\\*\" -ErrorAction SilentlyContinue\n    $Result.MFAStatus.WindowsHelloConfigured = (Test-Path \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Authentication\\Credential Providers\\{D6886603-9D2F-4EB2-B667-1971041FA96B}\")\n} catch {\n    $Result.MFAStatus.WindowsHelloConfigured = $false\n}\n\n$Result | ConvertTo-Json -Depth 4",
    "remediate_script": "# Remediate access control issues\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # Set minimum password length to 12\n    net accounts /minpwlen:12 2>&1 | Out-Null\n    $Result.Actions += \"Set minimum password length to 12\"\n\n    # Set maximum password age to 90 days\n    net accounts /maxpwage:90 2>&1 | Out-Null\n    $Result.Actions += \"Set maximum password age to 90 days\"\n\n    # Set account lockout threshold to 5\n    net accounts /lockoutthreshold:5 2>&1 | Out-Null\n    $Result.Actions += \"Set account lockout threshold to 5\"\n\n    # Set lockout duration to 30 minutes\n    net accounts /lockoutduration:30 2>&1 | Out-Null\n    $Result.Actions += \"Set account lockout duration to 30 minutes\"\n\n    # Enable password complexity via secedit\n    $CfgFile = \"$env:TEMP\\secpol_fix.cfg\"\n    $DbFile = \"$env:TEMP\\secpol_fix.sdb\"\n    @\"\n[Unicode]\nUnicode=yes\n[System Access]\nPasswordComplexity = 1\nMinimumPasswordLength = 12\nMaximumPasswordAge = 90\nMinimumPasswordAge = 1\nPasswordHistorySize = 12\n\"@ | Set-Content $CfgFile\n\n    secedit /configure /db $DbFile /cfg $CfgFile /areas SECURITYPOLICY 2>&1 | Out-Null\n    $Result.Actions += \"Configured password complexity and policy via secedit\"\n\n    Remove-Item $CfgFile, $DbFile -Force -ErrorAction SilentlyContinue\n\n    $Result.Success = $true\n    $Result.Message = \"Access control policies configured\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "verify_script": "$NetAccounts = net accounts 2>&1\n$MinLength = 0\n$LockoutThreshold = 0\nforeach ($Line in $NetAccounts) {\n    if ($Line -match \"Minimum password length:\\s*(\\d+)\") { $MinLength = [int]$Matches[1] }\n    if ($Line -match \"Lockout threshold:\\s*(\\d+)\") { $LockoutThreshold = [int]$Matches[1] }\n}\n@{\n    MinPasswordLength = $MinLength\n    LockoutThreshold = $LockoutThreshold\n    Verified = ($MinLength -ge 12 -and $LockoutThreshold -ge 3 -and $LockoutThreshold -le 5)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(d)",
      "164.312(a)(1)",
      "164.312(a)(2)(i)"
    ],
    "severity": "high",
    "timeout_seconds": 120
  },
  "RB-WIN-SEC-002": {
    "id": "RB-WIN-SEC-002",
    "name": "Audit Policy Remediation",
    "platform": "windows",
    "detect_script": "# Check HIPAA-required audit policies\n$RequiredPolicies = @{\n    \"Logon\" = \"Success,Failure\"\n    \"Logoff\" = \"Success\"\n    \"Account Lockout\" = \"Success,Failure\"\n    \"User Account Management\" = \"Success,Failure\"\n    \"Security Group Management\" = \"Success,Failure\"\n    \"Audit Policy Change\" = \"Success,Failure\"\n    \"Authentication Policy Change\" = \"Success\"\n    \"Sensitive Privilege Use\" = \"Success,Failure\"\n}\n\n$AuditPolicy = auditpol /get /category:* /r 2>$null | ConvertFrom-Csv\n$Result = @{\n    Drifted = $false\n    MissingPolicies = @()\n    ConfiguredPolicies = @()\n}\n\nforeach ($Policy in $RequiredPolicies.Keys) {\n    $Current = $AuditPolicy | Where-Object { $_.Subcategory -like \"*$Policy*\" }\n    if ($Current) {\n        $Setting = $Current.\"Inclusion Setting\"\n        if ($Setting -eq \"No Auditing\") {\n            $Result.Drifted = $true\n            $Result.MissingPolicies += $Policy\n        } else {\n            $Result.ConfiguredPolicies += @{ Name = $Policy; Setting = $Setting }\n        }\n    }\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "remediate_script": "# Configure HIPAA-required audit policies\n# Using direct auditpol calls instead of Invoke-Expression for security\n$Policies = @(\n    @{ Subcategory = \"Logon\"; Success = $true; Failure = $true },\n    @{ Subcategory = \"Logoff\"; Success = $true; Failure = $false },\n    @{ Subcategory = \"Account Lockout\"; Success = $true; Failure = $true },\n    @{ Subcategory = \"User Account Management\"; Success = $true; Failure = $true },\n    @{ Subcategory = \"Security Group Management\"; Success = $true; Failure = $true },\n    @{ Subcategory = \"Audit Policy Change\"; Success = $true; Failure = $true },\n    @{ Subcategory = \"Authentication Policy Change\"; Success = $true; Failure = $false },\n    @{ Subcategory = \"Sensitive Privilege Use\"; Success = $true; Failure = $true }\n)\n\n$Results = @()\nforeach ($Policy in $Policies) {\n    $SuccessArg = if ($Policy.Success) { \"/success:enable\" } else { \"/success:disable\" }\n    $FailureArg = if ($Policy.Failure) { \"/failure:enable\" } else { \"/failure:disable\" }\n    $Args = @(\"/set\", \"/subcategory:`\"$($Policy.Subcategory)`\"\", $SuccessArg, $FailureArg)\n\n    $Proc = Start-Process -FilePath \"auditpol.exe\" -ArgumentList $Args -NoNewWindow -Wait -PassThru\n    $Results += @{ Subcategory = $Policy.Subcategory; ExitCode = $Proc.ExitCode }\n}\n\n$FailedCount = ($Results | Where-Object { $_.ExitCode -ne 0 }).Count\n\n@{\n    Success = ($FailedCount -eq 0)\n    CommandsExecuted = $Results.Count\n    FailedCommands = $FailedCount\n    Results = $Results\n} | ConvertTo-Json -Depth 2",
    "verify_script": "$AuditPolicy = auditpol /get /category:* /r | ConvertFrom-Csv\n$LogonAudit = $AuditPolicy | Where-Object { $_.Subcategory -like \"*Logon*\" }\n@{\n    LogonAuditEnabled = ($LogonAudit.\"Inclusion Setting\" -ne \"No Auditing\")\n    Verified = ($LogonAudit.\"Inclusion Setting\" -ne \"No Auditing\")\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(b)",
      "164.308(a)(1)(ii)(D)"
    ],
    "severity": "high",
    "timeout_seconds": 120
  },
  "RB-WIN-SEC-005": {
    "id": "RB-WIN-SEC-005",
    "name": "BitLocker Status Recovery",
    "platform": "windows",
    "detect_script": "# Check BitLocker status\n$Result = @{\n    Drifted = $false\n    Volumes = @()\n}\n\ntry {\n    $Volumes = Get-BitLockerVolume -ErrorAction Stop\n\n    foreach ($Vol in $Volumes) {\n        $VolInfo = @{\n            MountPoint = $Vol.MountPoint\n            VolumeStatus = $Vol.VolumeStatus.ToString()\n            ProtectionStatus = $Vol.ProtectionStatus.ToString()\n            EncryptionPercentage = $Vol.EncryptionPercentage\n        }\n        $Result.Volumes += $VolInfo\n\n        # Check for issues on system drive\n        if ($Vol.MountPoint -eq \"C:\") {\n            if ($Vol.ProtectionStatus -eq \"Off\" -and $Vol.VolumeStatus -eq \"FullyEncrypted\") {\n                $Result.Drifted = $true\n                $Result.DriftReason = \"BitLocker suspended on system drive\"\n            } elseif ($Vol.VolumeStatus -ne \"FullyEncrypted\") {\n                $Result.Drifted = $true\n                $Result.DriftReason = \"System drive not fully encrypted\"\n            }\n        }\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.BitLockerNotAvailable = $true\n}\n\n$Result | ConvertTo-Json -Depth 3",
    "remediate_script": "# Resume BitLocker protection if suspended\n$Result = @{ Success = $false }\n\ntry {\n    $Vol = Get-BitLockerVolume -MountPoint \"C:\" -ErrorAction Stop\n\n    if ($Vol.ProtectionStatus -eq \"Off\" -and $Vol.VolumeStatus -eq \"FullyEncrypted\") {\n        # Resume protection\n        Resume-BitLocker -MountPoint \"C:\" -ErrorAction Stop\n        $Result.Success = $true\n        $Result.Action = \"Resumed BitLocker protection\"\n    } elseif ($Vol.VolumeStatus -eq \"FullyEncrypted\") {\n        $Result.Success = $true\n        $Result.Message = \"BitLocker already active\"\n    } else {\n        # Not encrypted - this requires planning\n        $Result.Action = \"ALERT\"\n        $Result.Message = \"Drive not encrypted - manual intervention required\"\n        $Result.Warning = \"Enable BitLocker: Enable-BitLocker -MountPoint C: -EncryptionMethod XtsAes256\"\n    }\n\n    $Result.CurrentStatus = (Get-BitLockerVolume -MountPoint \"C:\").ProtectionStatus.ToString()\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "try {\n    $Vol = Get-BitLockerVolume -MountPoint \"C:\" -ErrorAction Stop\n    @{\n        ProtectionStatus = $Vol.ProtectionStatus.ToString()\n        Verified = ($Vol.ProtectionStatus -eq \"On\")\n    } | ConvertTo-Json\n} catch {\n    @{ Verified = $false; Error = $_.Exception.Message } | ConvertTo-Json\n}",
    "hipaa_controls": [
      "164.312(a)(2)(iv)",
      "164.312(e)(2)(ii)"
    ],
    "severity": "critical",
    "timeout_seconds": 120
  },
  "RB-WIN-SEC-013": {
    "id": "RB-WIN-SEC-013",
    "name": "Credential Guard Status",
    "platform": "windows",
    "detect_script": "# Check Credential Guard status\n$Result = @{\n    Drifted = $false\n    Issues = @()\n}\n\ntry {\n    # Check Device Guard status\n    $DeviceGuard = Get-CimInstance -ClassName Win32_DeviceGuard -Namespace root\\Microsoft\\Windows\\DeviceGuard -ErrorAction Stop\n\n    $Result.VirtualizationBasedSecurityStatus = $DeviceGuard.VirtualizationBasedSecurityStatus\n    $Result.SecurityServicesConfigured = $DeviceGuard.SecurityServicesConfigured\n    $Result.SecurityServicesRunning = $DeviceGuard.SecurityServicesRunning\n\n    # 0 = Not configured, 1 = Credential Guard configured\n    $Result.CredentialGuardConfigured = $DeviceGuard.SecurityServicesConfigured -contains 1\n    $Result.CredentialGuardRunning = $DeviceGuard.SecurityServicesRunning -contains 1\n\n    # Check if VBS is running\n    if ($DeviceGuard.VirtualizationBasedSecurityStatus -ne 2) {\n        $Result.Issues += \"Virtualization Based Security not running\"\n    }\n\n    # Credential Guard not running is informational (hardware dependent)\n    if (-not $Result.CredentialGuardRunning) {\n        $Result.Issues += \"Credential Guard not running (may require hardware support)\"\n    }\n\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Issues += \"Unable to query Credential Guard status\"\n}\n\n# Check for LSA protection\n$LSAProtection = (Get-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa\" -Name \"RunAsPPL\" -ErrorAction SilentlyContinue).RunAsPPL\n$Result.LSAProtectionEnabled = ($LSAProtection -eq 1)\n\nif ($LSAProtection -ne 1) {\n    $Result.Drifted = $true\n    $Result.Issues += \"LSA Protection (RunAsPPL) not enabled\"\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "remediate_script": "# Enable LSA Protection (Credential Guard requires hardware support)\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # Enable LSA Protection\n    Set-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa\" -Name \"RunAsPPL\" -Value 1 -Type DWord\n    $Result.Actions += \"Enabled LSA Protection (RunAsPPL)\"\n\n    # Note: Full Credential Guard requires:\n    # - Compatible hardware (VT-x, TPM 2.0)\n    # - UEFI with Secure Boot\n    # - Windows 10 Enterprise or Windows Server 2016+\n\n    $Result.Success = $true\n    $Result.Message = \"LSA Protection enabled\"\n    $Result.Warning = \"Reboot required. Full Credential Guard may require additional configuration.\"\n    $Result.Note = \"Credential Guard requires compatible hardware and Enterprise SKU\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "$LSAProtection = (Get-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa\" -Name \"RunAsPPL\" -ErrorAction SilentlyContinue).RunAsPPL\n@{\n    LSAProtectionEnabled = ($LSAProtection -eq 1)\n    Verified = ($LSAProtection -eq 1)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(a)(2)(iv)",
      "164.312(d)"
    ],
    "severity": "medium",
    "timeout_seconds": 60
  },
  "RB-WIN-SEC-017": {
    "id": "RB-WIN-SEC-017",
    "name": "Windows Defender Exclusion Audit",
    "platform": "windows",
    "detect_script": "try {\n    $Prefs = Get-MpPreference\n\n    # Collect all exclusion types\n    $PathExclusions = @($Prefs.ExclusionPath | Where-Object { $_ })\n    $ExtExclusions = @($Prefs.ExclusionExtension | Where-Object { $_ })\n    $ProcessExclusions = @($Prefs.ExclusionProcess | Where-Object { $_ })\n\n    # Known-suspicious patterns\n    $SuspiciousPaths = @(\n        'C:\\Windows\\Temp',\n        'C:\\Temp',\n        'C:\\Users\\Public',\n        'C:\\ProgramData',\n        'C:\\'\n    )\n    $SuspiciousExtensions = @('exe', 'dll', 'bat', 'cmd', 'ps1', 'vbs', 'js', 'wsf', 'scr', 'com')\n\n    $Unauthorized = @()\n    $Details = @()\n\n    # Check path exclusions\n    foreach ($Path in $PathExclusions) {\n        $IsSuspicious = $false\n        foreach ($Pattern in $SuspiciousPaths) {\n            if ($Path -like \"$Pattern*\") {\n                $IsSuspicious = $true\n                break\n            }\n        }\n        if ($IsSuspicious) {\n            $Unauthorized += $Path\n            $Details += \"Suspicious path exclusion: $Path\"\n        }\n    }\n\n    # Check extension exclusions\n    foreach ($Ext in $ExtExclusions) {\n        $NormExt = $Ext.TrimStart('.')\n        if ($SuspiciousExtensions -contains $NormExt) {\n            $Unauthorized += \"ext:$NormExt\"\n            $Details += \"Dangerous extension exclusion: .$NormExt\"\n        }\n    }\n\n    # Check process exclusions for suspicious patterns\n    foreach ($Proc in $ProcessExclusions) {\n        if ($Proc -match '\\\\Temp\\\\|\\\\Downloads\\\\|\\\\Public\\\\|\\\\AppData\\\\Local\\\\Temp') {\n            $Unauthorized += \"proc:$Proc\"\n            $Details += \"Suspicious process exclusion: $Proc\"\n        }\n    }\n\n    $Drifted = $Unauthorized.Count -gt 0\n\n    @{\n        Drifted = $Drifted\n        PathExclusions = $PathExclusions\n        ExtensionExclusions = $ExtExclusions\n        ProcessExclusions = $ProcessExclusions\n        UnauthorizedCount = $Unauthorized.Count\n        UnauthorizedExclusions = $Unauthorized\n        Details = $Details\n    } | ConvertTo-Json -Depth 3\n} catch {\n    @{ Drifted = $false; Error = $_.Exception.Message } | ConvertTo-Json\n}",
    "remediate_script": "try {\n    $Prefs = Get-MpPreference\n    $Removed = @()\n\n    # Suspicious paths to remove\n    $SuspiciousPaths = @(\n        'C:\\Windows\\Temp',\n        'C:\\Temp',\n        'C:\\Users\\Public',\n        'C:\\ProgramData',\n        'C:\\'\n    )\n    $SuspiciousExtensions = @('exe', 'dll', 'bat', 'cmd', 'ps1', 'vbs', 'js', 'wsf', 'scr', 'com')\n\n    # Remove suspicious path exclusions\n    foreach ($Path in @($Prefs.ExclusionPath | Where-Object { $_ })) {\n        foreach ($Pattern in $SuspiciousPaths) {\n            if ($Path -like \"$Pattern*\") {\n                Remove-MpPreference -ExclusionPath $Path -ErrorAction Stop\n                $Removed += \"path:$Path\"\n                break\n            }\n        }\n    }\n\n    # Remove suspicious extension exclusions\n    foreach ($Ext in @($Prefs.ExclusionExtension | Where-Object { $_ })) {\n        $NormExt = $Ext.TrimStart('.')\n        if ($SuspiciousExtensions -contains $NormExt) {\n            Remove-MpPreference -ExclusionExtension $Ext -ErrorAction Stop\n            $Removed += \"ext:$Ext\"\n        }\n    }\n\n    # Remove suspicious process exclusions\n    foreach ($Proc in @($Prefs.ExclusionProcess | Where-Object { $_ })) {\n        if ($Proc -match '\\\\Temp\\\\|\\\\Downloads\\\\|\\\\Public\\\\|\\\\AppData\\\\Local\\\\Temp') {\n            Remove-MpPreference -ExclusionProcess $Proc -ErrorAction Stop\n            $Removed += \"proc:$Proc\"\n        }\n    }\n\n    @{\n        Success = $true\n        RemovedCount = $Removed.Count\n        RemovedExclusions = $Removed\n    } | ConvertTo-Json -Depth 3\n} catch {\n    @{ Success = $false; Error = $_.Exception.Message } | ConvertTo-Json\n}",
    "verify_script": "try {\n    $Prefs = Get-MpPreference\n\n    $SuspiciousPaths = @(\n        'C:\\Windows\\Temp',\n        'C:\\Temp',\n        'C:\\Users\\Public',\n        'C:\\ProgramData',\n        'C:\\'\n    )\n    $SuspiciousExtensions = @('exe', 'dll', 'bat', 'cmd', 'ps1', 'vbs', 'js', 'wsf', 'scr', 'com')\n\n    $Remaining = @()\n\n    foreach ($Path in @($Prefs.ExclusionPath | Where-Object { $_ })) {\n        foreach ($Pattern in $SuspiciousPaths) {\n            if ($Path -like \"$Pattern*\") {\n                $Remaining += \"path:$Path\"\n                break\n            }\n        }\n    }\n\n    foreach ($Ext in @($Prefs.ExclusionExtension | Where-Object { $_ })) {\n        $NormExt = $Ext.TrimStart('.')\n        if ($SuspiciousExtensions -contains $NormExt) {\n            $Remaining += \"ext:$Ext\"\n        }\n    }\n\n    @{\n        Verified = ($Remaining.Count -eq 0)\n        RemainingCount = $Remaining.Count\n        RemainingExclusions = $Remaining\n        TotalPathExclusions = @($Prefs.ExclusionPath | Where-Object { $_ }).Count\n        TotalExtExclusions = @($Prefs.ExclusionExtension | Where-Object { $_ }).Count\n        TotalProcessExclusions = @($Prefs.ExclusionProcess | Where-Object { $_ }).Count\n    } | ConvertTo-Json -Depth 3\n} catch {\n    @{ Verified = $false; Error = $_.Exception.Message } | ConvertTo-Json\n}",
    "hipaa_controls": [
      "164.308(a)(5)(ii)(B)",
      "164.312(b)"
    ],
    "severity": "high",
    "timeout_seconds": 120
  },
  "RB-WIN-SEC-006": {
    "id": "RB-WIN-SEC-006",
    "name": "Windows Defender Real-time Protection",
    "platform": "windows",
    "detect_script": "# Check Windows Defender status\n$Result = @{\n    Drifted = $false\n}\n\ntry {\n    $Status = Get-MpComputerStatus -ErrorAction Stop\n    $SignatureAge = (Get-Date) - $Status.AntivirusSignatureLastUpdated\n\n    $Result.RealTimeEnabled = $Status.RealTimeProtectionEnabled\n    $Result.AntivirusEnabled = $Status.AntivirusEnabled\n    $Result.BehaviorMonitorEnabled = $Status.BehaviorMonitorEnabled\n    $Result.SignatureVersion = $Status.AntivirusSignatureVersion\n    $Result.SignatureAgeDays = [math]::Round($SignatureAge.TotalDays, 1)\n    $Result.EngineVersion = $Status.AMEngineVersion\n    $Result.QuickScanAgeDays = $Status.QuickScanAge\n\n    # Drift conditions\n    if (-not $Status.RealTimeProtectionEnabled) {\n        $Result.Drifted = $true\n        $Result.DriftReason = \"Real-time protection disabled\"\n    } elseif ($SignatureAge.TotalDays -gt 3) {\n        $Result.Drifted = $true\n        $Result.DriftReason = \"Signatures older than 3 days\"\n    } elseif (-not $Status.AntivirusEnabled) {\n        $Result.Drifted = $true\n        $Result.DriftReason = \"Antivirus disabled\"\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.DefenderNotAvailable = $true\n    $Result.Drifted = $true\n}\n\n$Result | ConvertTo-Json",
    "remediate_script": "# Enable Defender and update signatures\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # Enable real-time protection\n    Set-MpPreference -DisableRealtimeMonitoring $false -ErrorAction Stop\n    $Result.Actions += \"Enabled real-time monitoring\"\n\n    # Enable behavior monitoring\n    Set-MpPreference -DisableBehaviorMonitoring $false -ErrorAction SilentlyContinue\n    $Result.Actions += \"Enabled behavior monitoring\"\n\n    # Update signatures\n    Update-MpSignature -ErrorAction Stop\n    $Result.Actions += \"Updated virus signatures\"\n\n    # Quick scan in background\n    Start-MpScan -ScanType QuickScan -AsJob | Out-Null\n    $Result.Actions += \"Started background quick scan\"\n\n    $Result.Success = $true\n    $Result.Message = \"Windows Defender protection enabled and updated\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "try {\n    $Status = Get-MpComputerStatus\n    $SignatureAge = (Get-Date) - $Status.AntivirusSignatureLastUpdated\n    @{\n        RealTimeEnabled = $Status.RealTimeProtectionEnabled\n        SignatureAgeDays = [math]::Round($SignatureAge.TotalDays, 1)\n        Verified = ($Status.RealTimeProtectionEnabled -and $SignatureAge.TotalDays -le 3)\n    } | ConvertTo-Json\n} catch {\n    @{ Verified = $false; Error = $_.Exception.Message } | ConvertTo-Json\n}",
    "hipaa_controls": [
      "164.308(a)(5)(ii)(B)"
    ],
    "severity": "critical",
    "timeout_seconds": 300
  },
  "RB-WIN-SEC-012": {
    "id": "RB-WIN-SEC-012",
    "name": "Event Log Protection",
    "platform": "windows",
    "detect_script": "# Check event log protection and retention\n$Result = @{\n    Drifted = $false\n    Issues = @()\n    Logs = @()\n}\n\n$ImportantLogs = @(\"Security\", \"System\", \"Application\")\n\nforeach ($LogName in $ImportantLogs) {\n    $Log = Get-WinEvent -ListLog $LogName -ErrorAction SilentlyContinue\n    if ($Log) {\n        $LogInfo = @{\n            Name = $LogName\n            Enabled = $Log.IsEnabled\n            MaxSizeMB = [math]::Round($Log.MaximumSizeInBytes / 1MB, 0)\n            LogMode = $Log.LogMode.ToString()\n            RecordCount = $Log.RecordCount\n        }\n        $Result.Logs += $LogInfo\n\n        # Check if log is enabled\n        if (-not $Log.IsEnabled) {\n            $Result.Drifted = $true\n            $Result.Issues += \"$LogName log is disabled\"\n        }\n\n        # Check minimum size (Security should be at least 1GB for HIPAA)\n        if ($LogName -eq \"Security\" -and $Log.MaximumSizeInBytes -lt 1GB) {\n            $Result.Drifted = $true\n            $Result.Issues += \"Security log size too small (< 1GB)\"\n        }\n\n        # Check if overwrite mode (should be Archive/DoNotOverwrite for compliance)\n        if ($LogName -eq \"Security\" -and $Log.LogMode -eq \"Circular\") {\n            $Result.Issues += \"Security log may overwrite old events\"\n        }\n    }\n}\n\n# Check if event log service is running\n$EventLogService = Get-Service -Name \"EventLog\" -ErrorAction SilentlyContinue\n$Result.EventLogServiceRunning = ($EventLogService.Status -eq \"Running\")\nif ($EventLogService.Status -ne \"Running\") {\n    $Result.Drifted = $true\n    $Result.Issues += \"Event Log service not running\"\n}\n\n# Check audit for log clearing (Event ID 1102)\n$RecentClears = Get-WinEvent -FilterHashtable @{LogName='Security';Id=1102} -MaxEvents 5 -ErrorAction SilentlyContinue\n$Result.RecentLogClears = @($RecentClears).Count\nif ($Result.RecentLogClears -gt 0) {\n    $Result.Drifted = $true\n    $Result.Issues += \"Security log was recently cleared ($($Result.RecentLogClears) times)\"\n}\n\n$Result | ConvertTo-Json -Depth 3",
    "remediate_script": "# Configure event log protection\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # Ensure Event Log service is running\n    $Service = Get-Service -Name \"EventLog\"\n    if ($Service.Status -ne \"Running\") {\n        Start-Service -Name \"EventLog\"\n        $Result.Actions += \"Started Event Log service\"\n    }\n\n    # Configure Security log\n    $SecurityLog = Get-WinEvent -ListLog Security\n    if ($SecurityLog.MaximumSizeInBytes -lt 1GB) {\n        Limit-EventLog -LogName Security -MaximumSize 1GB\n        $Result.Actions += \"Set Security log to 1GB\"\n    }\n\n    # Enable all important logs\n    $Logs = @(\"Security\", \"System\", \"Application\")\n    foreach ($LogName in $Logs) {\n        $Log = Get-WinEvent -ListLog $LogName -ErrorAction SilentlyContinue\n        if ($Log -and -not $Log.IsEnabled) {\n            wevtutil sl $LogName /e:true\n            $Result.Actions += \"Enabled $LogName log\"\n        }\n    }\n\n    # Configure audit policy to log log clearing\n    auditpol /set /subcategory:\"Audit Policy Change\" /success:enable /failure:enable 2>&1 | Out-Null\n    $Result.Actions += \"Enabled audit for policy changes\"\n\n    $Result.Success = $true\n    $Result.Message = \"Event log protection configured\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "$SecurityLog = Get-WinEvent -ListLog Security -ErrorAction SilentlyContinue\n$Service = Get-Service -Name \"EventLog\" -ErrorAction SilentlyContinue\n@{\n    SecurityLogEnabled = $SecurityLog.IsEnabled\n    SecurityLogSizeMB = [math]::Round($SecurityLog.MaximumSizeInBytes / 1MB, 0)\n    EventLogServiceRunning = ($Service.Status -eq \"Running\")\n    Verified = ($SecurityLog.IsEnabled -and $Service.Status -eq \"Running\" -and $SecurityLog.MaximumSizeInBytes -ge 1GB)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(b)",
      "164.308(a)(1)(ii)(D)"
    ],
    "severity": "high",
    "timeout_seconds": 120
  },
  "RB-WIN-SEC-001": {
    "id": "RB-WIN-SEC-001",
    "name": "Windows Firewall Re-enable",
    "platform": "windows",
    "detect_script": "# Check Windows Firewall status on all profiles\n$Profiles = Get-NetFirewallProfile\n$Result = @{\n    Profiles = @{}\n    Drifted = $false\n    DisabledProfiles = @()\n}\n\nforeach ($Profile in $Profiles) {\n    $Result.Profiles[$Profile.Name] = @{\n        Enabled = $Profile.Enabled\n        DefaultInboundAction = $Profile.DefaultInboundAction.ToString()\n        DefaultOutboundAction = $Profile.DefaultOutboundAction.ToString()\n    }\n\n    if (-not $Profile.Enabled) {\n        $Result.Drifted = $true\n        $Result.DisabledProfiles += $Profile.Name\n    }\n}\n\n$Result | ConvertTo-Json -Depth 3",
    "remediate_script": "# Enable Windows Firewall on all profiles\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    $Profiles = Get-NetFirewallProfile\n\n    foreach ($Profile in $Profiles) {\n        if (-not $Profile.Enabled) {\n            Set-NetFirewallProfile -Name $Profile.Name -Enabled True\n            $Result.Actions += \"Enabled $($Profile.Name) profile\"\n        }\n    }\n\n    # Verify all enabled\n    $Profiles = Get-NetFirewallProfile\n    $AllEnabled = ($Profiles | Where-Object { -not $_.Enabled }).Count -eq 0\n\n    $Result.Success = $AllEnabled\n    $Result.Message = if ($AllEnabled) { \"All profiles enabled\" } else { \"Some profiles failed to enable\" }\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "$Profiles = Get-NetFirewallProfile\n$AllEnabled = ($Profiles | Where-Object { -not $_.Enabled }).Count -eq 0\n@{\n    AllEnabled = $AllEnabled\n    Verified = $AllEnabled\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(a)(1)",
      "164.312(e)(1)"
    ],
    "severity": "critical",
    "timeout_seconds": 60
  },
  "RB-WIN-SEC-003": {
    "id": "RB-WIN-SEC-003",
    "name": "Account Lockout Policy Reset",
    "platform": "windows",
    "detect_script": "# Check account lockout policy\n$Result = @{\n    Drifted = $false\n}\n\n# Get current policy from net accounts\n$NetAccounts = net accounts 2>&1\n$LockoutThreshold = 0\n$LockoutDuration = 0\n$LockoutWindow = 0\n\nforeach ($Line in $NetAccounts) {\n    if ($Line -match \"Lockout threshold:\\s*(\\d+|Never)\") {\n        $LockoutThreshold = if ($Matches[1] -eq \"Never\") { 0 } else { [int]$Matches[1] }\n    }\n    if ($Line -match \"Lockout duration.*:\\s*(\\d+)\") {\n        $LockoutDuration = [int]$Matches[1]\n    }\n    if ($Line -match \"Lockout observation window.*:\\s*(\\d+)\") {\n        $LockoutWindow = [int]$Matches[1]\n    }\n}\n\n$Result.LockoutThreshold = $LockoutThreshold\n$Result.LockoutDuration = $LockoutDuration\n$Result.LockoutWindow = $LockoutWindow\n\n# HIPAA requires lockout after 3-5 failed attempts\nif ($LockoutThreshold -eq 0 -or $LockoutThreshold -gt 5) {\n    $Result.Drifted = $true\n    $Result.DriftReason = \"Lockout threshold should be 3-5 attempts\"\n}\n\n# Lockout duration should be at least 15 minutes\nif ($LockoutDuration -lt 15 -and $LockoutThreshold -gt 0) {\n    $Result.Drifted = $true\n    $Result.DriftReason = \"Lockout duration should be at least 15 minutes\"\n}\n\n$Result | ConvertTo-Json",
    "remediate_script": "# Configure account lockout policy\n$Result = @{ Success = $false }\n\ntry {\n    # Set lockout threshold to 5 attempts\n    net accounts /lockoutthreshold:5 | Out-Null\n\n    # Set lockout duration to 30 minutes\n    net accounts /lockoutduration:30 | Out-Null\n\n    # Set lockout observation window to 30 minutes\n    net accounts /lockoutwindow:30 | Out-Null\n\n    $Result.Success = $true\n    $Result.Message = \"Account lockout policy configured\"\n    $Result.Settings = @{\n        LockoutThreshold = 5\n        LockoutDuration = 30\n        LockoutWindow = 30\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "$NetAccounts = net accounts 2>&1\n$LockoutThreshold = 0\nforeach ($Line in $NetAccounts) {\n    if ($Line -match \"Lockout threshold:\\s*(\\d+)\") {\n        $LockoutThreshold = [int]$Matches[1]\n    }\n}\n@{\n    LockoutThreshold = $LockoutThreshold\n    Verified = ($LockoutThreshold -ge 3 -and $LockoutThreshold -le 5)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(a)(2)(i)"
    ],
    "severity": "medium",
    "timeout_seconds": 60
  },
  "RB-WIN-SEC-010": {
    "id": "RB-WIN-SEC-010",
    "name": "NLA Enforcement",
    "platform": "windows",
    "detect_script": "# Check NLA settings for RDP\n$Result = @{\n    Drifted = $false\n    Issues = @()\n}\n\n# Check if RDP is enabled\n$RDPEnabled = (Get-ItemProperty -Path \"HKLM:\\System\\CurrentControlSet\\Control\\Terminal Server\" -Name \"fDenyTSConnections\" -ErrorAction SilentlyContinue).fDenyTSConnections -eq 0\n$Result.RDPEnabled = $RDPEnabled\n\nif ($RDPEnabled) {\n    # Check NLA setting\n    $NLAEnabled = (Get-ItemProperty -Path \"HKLM:\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" -Name \"UserAuthentication\" -ErrorAction SilentlyContinue).UserAuthentication\n    $Result.NLAEnabled = ($NLAEnabled -eq 1)\n\n    # Check security layer\n    $SecurityLayer = (Get-ItemProperty -Path \"HKLM:\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" -Name \"SecurityLayer\" -ErrorAction SilentlyContinue).SecurityLayer\n    $Result.SecurityLayer = $SecurityLayer\n    # 0 = RDP, 1 = Negotiate, 2 = TLS\n\n    # Check encryption level\n    $EncryptionLevel = (Get-ItemProperty -Path \"HKLM:\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" -Name \"MinEncryptionLevel\" -ErrorAction SilentlyContinue).MinEncryptionLevel\n    $Result.MinEncryptionLevel = $EncryptionLevel\n\n    if ($NLAEnabled -ne 1) {\n        $Result.Drifted = $true\n        $Result.Issues += \"NLA not enabled for RDP\"\n    }\n    if ($SecurityLayer -lt 2) {\n        $Result.Drifted = $true\n        $Result.Issues += \"RDP security layer not set to TLS\"\n    }\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "remediate_script": "# Enable NLA for RDP\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    $RDPPath = \"HKLM:\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\"\n\n    # Enable NLA\n    Set-ItemProperty -Path $RDPPath -Name \"UserAuthentication\" -Value 1 -Type DWord\n    $Result.Actions += \"Enabled NLA for RDP\"\n\n    # Set security layer to TLS\n    Set-ItemProperty -Path $RDPPath -Name \"SecurityLayer\" -Value 2 -Type DWord\n    $Result.Actions += \"Set RDP security layer to TLS\"\n\n    # Set minimum encryption level to High\n    Set-ItemProperty -Path $RDPPath -Name \"MinEncryptionLevel\" -Value 3 -Type DWord\n    $Result.Actions += \"Set RDP encryption to High\"\n\n    $Result.Success = $true\n    $Result.Message = \"NLA and RDP security enforced\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "$RDPPath = \"HKLM:\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\"\n$NLA = (Get-ItemProperty -Path $RDPPath -Name \"UserAuthentication\" -ErrorAction SilentlyContinue).UserAuthentication\n$Security = (Get-ItemProperty -Path $RDPPath -Name \"SecurityLayer\" -ErrorAction SilentlyContinue).SecurityLayer\n@{\n    NLAEnabled = ($NLA -eq 1)\n    SecurityLayer = $Security\n    Verified = ($NLA -eq 1 -and $Security -ge 2)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(d)",
      "164.312(e)(1)"
    ],
    "severity": "high",
    "timeout_seconds": 60
  },
  "RB-WIN-SEC-008": {
    "id": "RB-WIN-SEC-008",
    "name": "NTLM Security Settings",
    "platform": "windows",
    "detect_script": "# Check NTLM security settings\n$Result = @{\n    Drifted = $false\n    Issues = @()\n}\n\n# Check LAN Manager authentication level\n$LMKey = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa\"\n$LMLevel = (Get-ItemProperty -Path $LMKey -Name \"LmCompatibilityLevel\" -ErrorAction SilentlyContinue).LmCompatibilityLevel\n$Result.LmCompatibilityLevel = $LMLevel\n\n# Level 5 = Send NTLMv2 response only, refuse LM & NTLM\n# Minimum for HIPAA should be 3 or higher\nif ($null -eq $LMLevel -or $LMLevel -lt 3) {\n    $Result.Drifted = $true\n    $Result.Issues += \"LM compatibility level too low (should be >= 3)\"\n}\n\n# Check NTLMv2 session security\n$SessionSecurity = (Get-ItemProperty -Path $LMKey -Name \"NtlmMinClientSec\" -ErrorAction SilentlyContinue).NtlmMinClientSec\n$Result.NtlmMinClientSec = $SessionSecurity\n\n# Check if NTLM is restricted\n$RestrictNTLM = (Get-ItemProperty -Path \"$LMKey\\MSV1_0\" -Name \"RestrictSendingNTLMTraffic\" -ErrorAction SilentlyContinue).RestrictSendingNTLMTraffic\n$Result.RestrictNTLMTraffic = $RestrictNTLM\n\n# Check NoLMHash\n$NoLMHash = (Get-ItemProperty -Path $LMKey -Name \"NoLMHash\" -ErrorAction SilentlyContinue).NoLMHash\n$Result.NoLMHash = $NoLMHash\n\nif ($NoLMHash -ne 1) {\n    $Result.Drifted = $true\n    $Result.Issues += \"LM hash storage not disabled\"\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "remediate_script": "# Configure NTLM security settings\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    $LMKey = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa\"\n\n    # Set LM compatibility level to 5 (NTLMv2 only)\n    Set-ItemProperty -Path $LMKey -Name \"LmCompatibilityLevel\" -Value 5 -Type DWord\n    $Result.Actions += \"Set LM compatibility level to 5 (NTLMv2 only)\"\n\n    # Disable LM hash storage\n    Set-ItemProperty -Path $LMKey -Name \"NoLMHash\" -Value 1 -Type DWord\n    $Result.Actions += \"Disabled LM hash storage\"\n\n    # Set minimum session security\n    Set-ItemProperty -Path $LMKey -Name \"NtlmMinClientSec\" -Value 537395200 -Type DWord\n    Set-ItemProperty -Path $LMKey -Name \"NtlmMinServerSec\" -Value 537395200 -Type DWord\n    $Result.Actions += \"Enabled NTLM session security\"\n\n    $Result.Success = $true\n    $Result.Message = \"NTLM security hardened\"\n    $Result.Warning = \"Some legacy applications may require testing\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "$LMKey = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa\"\n$LMLevel = (Get-ItemProperty -Path $LMKey -Name \"LmCompatibilityLevel\" -ErrorAction SilentlyContinue).LmCompatibilityLevel\n$NoLMHash = (Get-ItemProperty -Path $LMKey -Name \"NoLMHash\" -ErrorAction SilentlyContinue).NoLMHash\n@{\n    LmCompatibilityLevel = $LMLevel\n    NoLMHash = $NoLMHash\n    Verified = ($LMLevel -ge 3 -and $NoLMHash -eq 1)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(d)",
      "164.312(e)(2)(ii)"
    ],
    "severity": "high",
    "timeout_seconds": 60
  },
  "RB-WIN-SEC-004": {
    "id": "RB-WIN-SEC-004",
    "name": "Password Policy Enforcement",
    "platform": "windows",
    "detect_script": "# Check password policy\n$Result = @{\n    Drifted = $false\n    Issues = @()\n}\n\n$NetAccounts = net accounts 2>&1\n$MinLength = 0\n$MaxAge = 0\n$MinAge = 0\n$History = 0\n\nforeach ($Line in $NetAccounts) {\n    if ($Line -match \"Minimum password length:\\s*(\\d+)\") {\n        $MinLength = [int]$Matches[1]\n    }\n    if ($Line -match \"Maximum password age.*:\\s*(\\d+|Unlimited)\") {\n        $MaxAge = if ($Matches[1] -eq \"Unlimited\") { 999 } else { [int]$Matches[1] }\n    }\n    if ($Line -match \"Minimum password age.*:\\s*(\\d+)\") {\n        $MinAge = [int]$Matches[1]\n    }\n    if ($Line -match \"Length of password history.*:\\s*(\\d+|None)\") {\n        $History = if ($Matches[1] -eq \"None\") { 0 } else { [int]$Matches[1] }\n    }\n}\n\n$Result.MinimumLength = $MinLength\n$Result.MaximumAge = $MaxAge\n$Result.MinimumAge = $MinAge\n$Result.PasswordHistory = $History\n\n# Check compliance\nif ($MinLength -lt 8) {\n    $Result.Drifted = $true\n    $Result.Issues += \"Minimum length should be at least 8 characters\"\n}\nif ($MaxAge -gt 90 -or $MaxAge -eq 999) {\n    $Result.Drifted = $true\n    $Result.Issues += \"Maximum age should be 90 days or less\"\n}\nif ($History -lt 6) {\n    $Result.Drifted = $true\n    $Result.Issues += \"Password history should remember at least 6 passwords\"\n}\n\n# Check complexity requirement\n$SecEdit = secedit /export /cfg \"$env:TEMP\\secpol.cfg\" /areas SECURITYPOLICY 2>&1\n$SecPol = Get-Content \"$env:TEMP\\secpol.cfg\" -ErrorAction SilentlyContinue\n$Complexity = ($SecPol | Select-String \"PasswordComplexity\\s*=\\s*1\") -ne $null\nRemove-Item \"$env:TEMP\\secpol.cfg\" -Force -ErrorAction SilentlyContinue\n\n$Result.ComplexityEnabled = $Complexity\nif (-not $Complexity) {\n    $Result.Drifted = $true\n    $Result.Issues += \"Password complexity should be enabled\"\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "remediate_script": "# Configure password policy (domain GPO or local)\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # These work for local policy; domain requires GPO\n    net accounts /minpwlen:12 2>&1 | Out-Null\n    $Result.Actions += \"Set minimum password length to 12\"\n\n    net accounts /maxpwage:90 2>&1 | Out-Null\n    $Result.Actions += \"Set maximum password age to 90 days\"\n\n    net accounts /minpwage:1 2>&1 | Out-Null\n    $Result.Actions += \"Set minimum password age to 1 day\"\n\n    net accounts /uniquepw:12 2>&1 | Out-Null\n    $Result.Actions += \"Set password history to 12\"\n\n    # Enable complexity via secedit\n    $CfgFile = \"$env:TEMP\\secpol_fix.cfg\"\n    $DbFile = \"$env:TEMP\\secpol_fix.sdb\"\n\n    @\"\n[Unicode]\nUnicode=yes\n[System Access]\nPasswordComplexity = 1\n\"@ | Set-Content $CfgFile\n\n    secedit /configure /db $DbFile /cfg $CfgFile /areas SECURITYPOLICY 2>&1 | Out-Null\n    $Result.Actions += \"Enabled password complexity\"\n\n    Remove-Item $CfgFile, $DbFile -Force -ErrorAction SilentlyContinue\n\n    $Result.Success = $true\n    $Result.Message = \"Password policy configured\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "verify_script": "$NetAccounts = net accounts 2>&1\n$MinLength = 0\nforeach ($Line in $NetAccounts) {\n    if ($Line -match \"Minimum password length:\\s*(\\d+)\") {\n        $MinLength = [int]$Matches[1]\n    }\n}\n@{\n    MinimumLength = $MinLength\n    Verified = ($MinLength -ge 8)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(d)"
    ],
    "severity": "high",
    "timeout_seconds": 120
  },
  "RB-WIN-SEC-019": {
    "id": "RB-WIN-SEC-019",
    "name": "Suspicious Registry Run Key Removal",
    "platform": "windows",
    "detect_script": "$found = @()\n$paths = @(\n    'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run',\n    'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce'\n)\nforeach ($p in $paths) {\n    $props = Get-ItemProperty -Path $p -ErrorAction SilentlyContinue\n    if ($props) {\n        $props.PSObject.Properties | Where-Object {\n            $_.Name -notmatch '^(PS|VMware|SecurityHealth|RealTimeProtection|Windows)' -and\n            $_.Value -match '\\.(exe|bat|cmd|ps1|vbs|js)' -and\n            $_.Value -notmatch '(Program Files|Windows|Microsoft|VMware)'\n        } | ForEach-Object {\n            $found += @{Name=$_.Name; Value=$_.Value; Path=$p}\n        }\n    }\n}\nif ($found.Count -gt 0) {\n    @{Status='FAIL'; Details=\"Suspicious Run entries found\"; Entries=$found} | ConvertTo-Json -Compress\n} else {\n    @{Status='PASS'; Details=\"No suspicious Run entries\"} | ConvertTo-Json -Compress\n}",
    "remediate_script": "$removed = @()\n$failed = @()\n$paths = @(\n    'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run',\n    'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce'\n)\nforeach ($p in $paths) {\n    $props = Get-ItemProperty -Path $p -ErrorAction SilentlyContinue\n    if ($props) {\n        $props.PSObject.Properties | Where-Object {\n            $_.Name -notmatch '^(PS|VMware|SecurityHealth|RealTimeProtection|Windows)' -and\n            $_.Value -match '\\.(exe|bat|cmd|ps1|vbs|js)' -and\n            $_.Value -notmatch '(Program Files|Windows|Microsoft|VMware)'\n        } | ForEach-Object {\n            try {\n                Remove-ItemProperty -Path $p -Name $_.Name -Force -ErrorAction Stop\n                $removed += @{Name=$_.Name; Path=$p}\n            } catch {\n                $failed += @{Name=$_.Name; Path=$p; Error=$_.Exception.Message}\n            }\n        }\n    }\n}\n@{Removed=$removed; Failed=$failed} | ConvertTo-Json -Compress",
    "verify_script": "$remaining = @()\n$paths = @(\n    'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run',\n    'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce'\n)\nforeach ($p in $paths) {\n    $props = Get-ItemProperty -Path $p -ErrorAction SilentlyContinue\n    if ($props) {\n        $props.PSObject.Properties | Where-Object {\n            $_.Name -notmatch '^(PS|VMware|SecurityHealth|RealTimeProtection|Windows)' -and\n            $_.Value -match '\\.(exe|bat|cmd|ps1|vbs|js)' -and\n            $_.Value -notmatch '(Program Files|Windows|Microsoft|VMware)'\n        } | ForEach-Object {\n            $remaining += @{Name=$_.Name; Value=$_.Value; Path=$p}\n        }\n    }\n}\nif ($remaining.Count -gt 0) {\n    @{Status='FAIL'; Details=\"Suspicious entries still present\"; Entries=$remaining} | ConvertTo-Json -Compress\n} else {\n    @{Status='PASS'; Details=\"All suspicious Run entries removed\"} | ConvertTo-Json -Compress\n}",
    "hipaa_controls": [
      "164.308(a)(1)(ii)(D)",
      "164.312(b)"
    ],
    "severity": "critical",
    "timeout_seconds": 300
  },
  "RB-WIN-SEC-018": {
    "id": "RB-WIN-SEC-018",
    "name": "Suspicious Scheduled Task Removal",
    "platform": "windows",
    "detect_script": "$suspicious = Get-ScheduledTask -ErrorAction SilentlyContinue | Where-Object {\n    $_.TaskName -notmatch '^(Microsoft|Google|Adobe|Mozilla|OneDrive|MicrosoftEdge|Optimize|Scheduled|User_Feed|CreateExplorerShellUnelevatedTask)' -and\n    $_.TaskPath -eq '\\' -and\n    $_.State -ne 'Disabled'\n} | ForEach-Object {\n    $action = ($_.Actions | Select-Object -First 1).Execute\n    if ($action -and $action -notmatch '(svchost|taskhost|consent|SystemSettings|WindowsUpdate|defrag|SilentCleanup)') {\n        @{TaskName=$_.TaskName; Execute=$action; State=$_.State.ToString()}\n    }\n}\nif ($suspicious) {\n    @{Status='FAIL'; Details=\"Suspicious scheduled tasks found\"; Tasks=$suspicious} | ConvertTo-Json -Compress\n} else {\n    @{Status='PASS'; Details=\"No suspicious scheduled tasks\"} | ConvertTo-Json -Compress\n}",
    "remediate_script": "$removed = @()\n$failed = @()\nGet-ScheduledTask -ErrorAction SilentlyContinue | Where-Object {\n    $_.TaskName -notmatch '^(Microsoft|Google|Adobe|Mozilla|OneDrive|MicrosoftEdge|Optimize|Scheduled|User_Feed|CreateExplorerShellUnelevatedTask)' -and\n    $_.TaskPath -eq '\\' -and\n    $_.State -ne 'Disabled'\n} | ForEach-Object {\n    $action = ($_.Actions | Select-Object -First 1).Execute\n    if ($action -and $action -notmatch '(svchost|taskhost|consent|SystemSettings|WindowsUpdate|defrag|SilentCleanup)') {\n        try {\n            Unregister-ScheduledTask -TaskName $_.TaskName -Confirm:$false -ErrorAction Stop\n            $removed += $_.TaskName\n        } catch {\n            $failed += @{TaskName=$_.TaskName; Error=$_.Exception.Message}\n        }\n    }\n}\n@{Removed=$removed; Failed=$failed} | ConvertTo-Json -Compress",
    "verify_script": "$remaining = Get-ScheduledTask -ErrorAction SilentlyContinue | Where-Object {\n    $_.TaskName -notmatch '^(Microsoft|Google|Adobe|Mozilla|OneDrive|MicrosoftEdge|Optimize|Scheduled|User_Feed|CreateExplorerShellUnelevatedTask)' -and\n    $_.TaskPath -eq '\\' -and\n    $_.State -ne 'Disabled'\n} | ForEach-Object {\n    $action = ($_.Actions | Select-Object -First 1).Execute\n    if ($action -and $action -notmatch '(svchost|taskhost|consent|SystemSettings|WindowsUpdate|defrag|SilentCleanup)') {\n        @{TaskName=$_.TaskName; Execute=$action}\n    }\n}\nif ($remaining) {\n    @{Status='FAIL'; Details=\"Suspicious tasks still present\"; Tasks=$remaining} | ConvertTo-Json -Compress\n} else {\n    @{Status='PASS'; Details=\"All suspicious scheduled tasks removed\"} | ConvertTo-Json -Compress\n}",
    "hipaa_controls": [
      "164.308(a)(1)(ii)(D)",
      "164.312(b)"
    ],
    "severity": "critical",
    "timeout_seconds": 300
  },
  "RB-WIN-SEC-016": {
    "id": "RB-WIN-SEC-016",
    "name": "Screen Lock / Auto Logoff",
    "platform": "windows",
    "detect_script": "# Check screen lock and auto logoff settings\n$Result = @{\n    Drifted = $false\n    Issues = @()\n}\n\ntry {\n    # Check screen saver timeout (machine-level GPO)\n    $SSKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\Control Panel\\Desktop\"\n    $SSTimeout = (Get-ItemProperty -Path $SSKey -Name \"ScreenSaveTimeOut\" -ErrorAction SilentlyContinue).ScreenSaveTimeOut\n    $SSActive = (Get-ItemProperty -Path $SSKey -Name \"ScreenSaveActive\" -ErrorAction SilentlyContinue).ScreenSaveActive\n    $SSSecure = (Get-ItemProperty -Path $SSKey -Name \"ScreenSaverIsSecure\" -ErrorAction SilentlyContinue).ScreenSaverIsSecure\n\n    # Also check user-level (fallback)\n    if ($null -eq $SSTimeout) {\n        $UserSSKey = \"HKCU:\\Control Panel\\Desktop\"\n        $SSTimeout = (Get-ItemProperty -Path $UserSSKey -Name \"ScreenSaveTimeOut\" -ErrorAction SilentlyContinue).ScreenSaveTimeOut\n        $SSActive = (Get-ItemProperty -Path $UserSSKey -Name \"ScreenSaveActive\" -ErrorAction SilentlyContinue).ScreenSaveActive\n        $SSSecure = (Get-ItemProperty -Path $UserSSKey -Name \"ScreenSaverIsSecure\" -ErrorAction SilentlyContinue).ScreenSaverIsSecure\n    }\n\n    $Result.ScreenSaverTimeout = $SSTimeout\n    $Result.ScreenSaverActive = $SSActive\n    $Result.ScreenSaverSecure = $SSSecure\n\n    # HIPAA requires 15 minutes or less\n    if ($null -eq $SSTimeout -or [int]$SSTimeout -gt 900) {\n        $Result.Drifted = $true\n        $Result.Issues += \"Screen saver timeout not set or exceeds 900 seconds (15 minutes)\"\n    }\n\n    if ($SSActive -ne \"1\") {\n        $Result.Drifted = $true\n        $Result.Issues += \"Screen saver is not active\"\n    }\n\n    if ($SSSecure -ne \"1\") {\n        $Result.Drifted = $true\n        $Result.Issues += \"Screen saver password protection not enabled\"\n    }\n\n    # Check idle disconnect for RDP sessions\n    $TSKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\Terminal Services\"\n    $IdleTimeout = (Get-ItemProperty -Path $TSKey -Name \"MaxIdleTime\" -ErrorAction SilentlyContinue).MaxIdleTime\n    $DisconnectTimeout = (Get-ItemProperty -Path $TSKey -Name \"MaxDisconnectionTime\" -ErrorAction SilentlyContinue).MaxDisconnectionTime\n\n    $Result.RDPIdleTimeoutMs = $IdleTimeout\n    $Result.RDPDisconnectTimeoutMs = $DisconnectTimeout\n\n    # Idle timeout should be 15 minutes (900000 ms) or less\n    if ($null -eq $IdleTimeout -or $IdleTimeout -gt 900000 -or $IdleTimeout -eq 0) {\n        $Result.Drifted = $true\n        $Result.Issues += \"RDP idle timeout not configured or exceeds 15 minutes\"\n    }\n\n    # Check machine inactivity limit (local security policy)\n    $InactivityKey = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\"\n    $InactivityLimit = (Get-ItemProperty -Path $InactivityKey -Name \"InactivityTimeoutSecs\" -ErrorAction SilentlyContinue).InactivityTimeoutSecs\n    $Result.InactivityTimeoutSecs = $InactivityLimit\n\n    if ($null -eq $InactivityLimit -or $InactivityLimit -gt 900 -or $InactivityLimit -eq 0) {\n        $Result.Drifted = $true\n        $Result.Issues += \"Machine inactivity timeout not configured or exceeds 900 seconds\"\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Drifted = $true\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "remediate_script": "# Configure screen lock and idle disconnect settings\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # Set screen saver timeout to 900 seconds (15 minutes) via GPO registry\n    $SSKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\Control Panel\\Desktop\"\n    if (-not (Test-Path $SSKey)) {\n        New-Item -Path $SSKey -Force | Out-Null\n    }\n    Set-ItemProperty -Path $SSKey -Name \"ScreenSaveTimeOut\" -Value \"900\" -Type String\n    $Result.Actions += \"Set screen saver timeout to 900 seconds (15 minutes)\"\n\n    # Enable screen saver\n    Set-ItemProperty -Path $SSKey -Name \"ScreenSaveActive\" -Value \"1\" -Type String\n    $Result.Actions += \"Enabled screen saver\"\n\n    # Require password on resume\n    Set-ItemProperty -Path $SSKey -Name \"ScreenSaverIsSecure\" -Value \"1\" -Type String\n    $Result.Actions += \"Enabled screen saver password protection\"\n\n    # Configure RDP idle timeout (15 minutes = 900000 ms)\n    $TSKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\Terminal Services\"\n    if (-not (Test-Path $TSKey)) {\n        New-Item -Path $TSKey -Force | Out-Null\n    }\n    Set-ItemProperty -Path $TSKey -Name \"MaxIdleTime\" -Value 900000 -Type DWord\n    $Result.Actions += \"Set RDP idle timeout to 15 minutes\"\n\n    # Set disconnected session timeout to 5 minutes (300000 ms)\n    Set-ItemProperty -Path $TSKey -Name \"MaxDisconnectionTime\" -Value 300000 -Type DWord\n    $Result.Actions += \"Set RDP disconnected session timeout to 5 minutes\"\n\n    # Set machine inactivity limit\n    $InactivityKey = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\"\n    Set-ItemProperty -Path $InactivityKey -Name \"InactivityTimeoutSecs\" -Value 900 -Type DWord\n    $Result.Actions += \"Set machine inactivity timeout to 900 seconds\"\n\n    $Result.Success = $true\n    $Result.Message = \"Screen lock and idle disconnect configured for HIPAA compliance\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "verify_script": "# Verify screen lock settings\ntry {\n    $SSKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\Control Panel\\Desktop\"\n    $SSTimeout = (Get-ItemProperty -Path $SSKey -Name \"ScreenSaveTimeOut\" -ErrorAction SilentlyContinue).ScreenSaveTimeOut\n    $SSSecure = (Get-ItemProperty -Path $SSKey -Name \"ScreenSaverIsSecure\" -ErrorAction SilentlyContinue).ScreenSaverIsSecure\n\n    $TSKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\Terminal Services\"\n    $IdleTimeout = (Get-ItemProperty -Path $TSKey -Name \"MaxIdleTime\" -ErrorAction SilentlyContinue).MaxIdleTime\n\n    $InactivityKey = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\"\n    $InactivityLimit = (Get-ItemProperty -Path $InactivityKey -Name \"InactivityTimeoutSecs\" -ErrorAction SilentlyContinue).InactivityTimeoutSecs\n\n    @{\n        ScreenSaverTimeout = $SSTimeout\n        ScreenSaverSecure = $SSSecure\n        RDPIdleTimeoutMs = $IdleTimeout\n        InactivityTimeoutSecs = $InactivityLimit\n        Verified = (\n            $SSTimeout -le 900 -and\n            $SSSecure -eq \"1\" -and\n            $IdleTimeout -le 900000 -and $IdleTimeout -gt 0 -and\n            $InactivityLimit -le 900 -and $InactivityLimit -gt 0\n        )\n    } | ConvertTo-Json\n} catch {\n    @{ Verified = $false; Error = $_.Exception.Message } | ConvertTo-Json\n}",
    "hipaa_controls": [
      "164.312(a)(2)(iii)"
    ],
    "severity": "high",
    "timeout_seconds": 60
  },
  "RB-WIN-SEC-020": {
    "id": "RB-WIN-SEC-020",
    "name": "SMBv1 Protocol Disabling",
    "platform": "windows",
    "detect_script": "# Check if SMBv1 protocol is enabled\n$Result = @{\n    Drifted = $false\n    Issues = @()\n}\n\ntry {\n    # Check via SMB Server Configuration\n    $SmbConfig = Get-SmbServerConfiguration -ErrorAction Stop\n    $Result.EnableSMB1Protocol = $SmbConfig.EnableSMB1Protocol\n\n    if ($SmbConfig.EnableSMB1Protocol) {\n        $Result.Drifted = $true\n        $Result.Issues += \"SMBv1 protocol is enabled on server\"\n    }\n\n    # Also check Windows Optional Feature (may differ from config)\n    $Feature = Get-WindowsOptionalFeature -Online -FeatureName SMB1Protocol -ErrorAction SilentlyContinue\n    if ($Feature) {\n        $Result.SMB1FeatureState = $Feature.State.ToString()\n        if ($Feature.State -eq \"Enabled\") {\n            $Result.Drifted = $true\n            $Result.Issues += \"SMB1Protocol Windows feature is enabled\"\n        }\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n    # If Get-SmbServerConfiguration fails, check registry directly\n    $regPath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\"\n    $smb1Val = (Get-ItemProperty -Path $regPath -Name SMB1 -ErrorAction SilentlyContinue).SMB1\n    if ($null -eq $smb1Val -or $smb1Val -ne 0) {\n        $Result.Drifted = $true\n        $Result.Issues += \"SMBv1 not explicitly disabled in registry\"\n    }\n    $Result.SMB1RegistryValue = $smb1Val\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "remediate_script": "# Disable SMBv1 protocol\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # Disable via SMB Server Configuration (immediate effect)\n    Set-SmbServerConfiguration -EnableSMB1Protocol $false -Confirm:$false -ErrorAction Stop\n    $Result.Actions += \"Disabled SMBv1 via Set-SmbServerConfiguration\"\n\n    # Also set registry value for persistence across reboots\n    $regPath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\"\n    Set-ItemProperty -Path $regPath -Name SMB1 -Value 0 -Type DWord -ErrorAction SilentlyContinue\n    $Result.Actions += \"Set SMB1=0 in registry\"\n\n    # Disable Windows Optional Feature (prevents re-enablement)\n    $Feature = Get-WindowsOptionalFeature -Online -FeatureName SMB1Protocol -ErrorAction SilentlyContinue\n    if ($Feature -and $Feature.State -eq \"Enabled\") {\n        Disable-WindowsOptionalFeature -Online -FeatureName SMB1Protocol -NoRestart -ErrorAction SilentlyContinue\n        $Result.Actions += \"Disabled SMB1Protocol Windows feature (reboot may be needed)\"\n    }\n\n    $Result.Success = $true\n    $Result.Message = \"SMBv1 protocol disabled\"\n} catch {\n    $Result.Error = $_.Exception.Message\n    # Fallback: try registry-only approach\n    try {\n        $regPath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\"\n        Set-ItemProperty -Path $regPath -Name SMB1 -Value 0 -Type DWord\n        $Result.Actions += \"Fallback: Set SMB1=0 in registry\"\n        $Result.Success = $true\n    } catch {\n        $Result.FallbackError = $_.Exception.Message\n    }\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "$SmbConfig = Get-SmbServerConfiguration -ErrorAction SilentlyContinue\n$enabled = if ($SmbConfig) { $SmbConfig.EnableSMB1Protocol } else { $null }\n$regPath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\"\n$regVal = (Get-ItemProperty -Path $regPath -Name SMB1 -ErrorAction SilentlyContinue).SMB1\n@{\n    EnableSMB1Protocol = $enabled\n    SMB1RegistryValue = $regVal\n    Verified = ($enabled -eq $false -or $regVal -eq 0)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(e)(1)",
      "164.312(e)(2)(i)"
    ],
    "severity": "high",
    "timeout_seconds": 120
  },
  "RB-WIN-SEC-007": {
    "id": "RB-WIN-SEC-007",
    "name": "SMB Signing Enforcement",
    "platform": "windows",
    "detect_script": "# Check SMB signing settings\n$Result = @{\n    Drifted = $false\n    Issues = @()\n}\n\n# Check server-side SMB signing\n$SmbServerConfig = Get-SmbServerConfiguration\n$Result.RequireSecuritySignature = $SmbServerConfig.RequireSecuritySignature\n$Result.EnableSecuritySignature = $SmbServerConfig.EnableSecuritySignature\n\n# Check client-side SMB signing via registry\n$ClientSigning = Get-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters\" -ErrorAction SilentlyContinue\n$Result.ClientRequireSigning = $ClientSigning.RequireSecuritySignature\n$Result.ClientEnableSigning = $ClientSigning.EnableSecuritySignature\n\n# HIPAA requires SMB signing\nif (-not $SmbServerConfig.RequireSecuritySignature) {\n    $Result.Drifted = $true\n    $Result.Issues += \"Server SMB signing not required\"\n}\nif (-not $SmbServerConfig.EnableSecuritySignature) {\n    $Result.Drifted = $true\n    $Result.Issues += \"Server SMB signing not enabled\"\n}\nif ($ClientSigning.RequireSecuritySignature -ne 1) {\n    $Result.Drifted = $true\n    $Result.Issues += \"Client SMB signing not required\"\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "remediate_script": "# Enable SMB signing on server and client\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # Enable server-side SMB signing\n    Set-SmbServerConfiguration -RequireSecuritySignature $true -EnableSecuritySignature $true -Confirm:$false\n    $Result.Actions += \"Enabled server SMB signing\"\n\n    # Enable client-side SMB signing via registry\n    Set-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters\" -Name \"RequireSecuritySignature\" -Value 1 -Type DWord\n    Set-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters\" -Name \"EnableSecuritySignature\" -Value 1 -Type DWord\n    $Result.Actions += \"Enabled client SMB signing\"\n\n    $Result.Success = $true\n    $Result.Message = \"SMB signing enforced\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "$SmbConfig = Get-SmbServerConfiguration\n@{\n    RequireSecuritySignature = $SmbConfig.RequireSecuritySignature\n    EnableSecuritySignature = $SmbConfig.EnableSecuritySignature\n    Verified = ($SmbConfig.RequireSecuritySignature -and $SmbConfig.EnableSecuritySignature)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(e)(1)",
      "164.312(e)(2)(i)"
    ],
    "severity": "high",
    "timeout_seconds": 60
  },
  "RB-WIN-SEC-014": {
    "id": "RB-WIN-SEC-014",
    "name": "TLS/SSL Configuration",
    "platform": "windows",
    "detect_script": "# Check TLS/SSL protocol configuration\n$Result = @{\n    Drifted = $false\n    Issues = @()\n    Protocols = @{}\n}\n\n$BasePath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\"\n\n# Protocols that must be DISABLED for HIPAA\n$LegacyProtocols = @(\"SSL 2.0\", \"SSL 3.0\", \"TLS 1.0\", \"TLS 1.1\")\n\n# Protocols that must be ENABLED\n$ModernProtocols = @(\"TLS 1.2\")\n\ntry {\n    # Check legacy protocols (should be disabled)\n    foreach ($Protocol in $LegacyProtocols) {\n        $ServerPath = \"$BasePath\\$Protocol\\Server\"\n        $ClientPath = \"$BasePath\\$Protocol\\Client\"\n\n        $ServerEnabled = (Get-ItemProperty -Path $ServerPath -Name \"Enabled\" -ErrorAction SilentlyContinue).Enabled\n        $ServerDisabledByDefault = (Get-ItemProperty -Path $ServerPath -Name \"DisabledByDefault\" -ErrorAction SilentlyContinue).DisabledByDefault\n        $ClientEnabled = (Get-ItemProperty -Path $ClientPath -Name \"Enabled\" -ErrorAction SilentlyContinue).Enabled\n\n        $ProtocolInfo = @{\n            ServerEnabled = if ($null -eq $ServerEnabled) { \"NotConfigured\" } else { $ServerEnabled }\n            ServerDisabledByDefault = if ($null -eq $ServerDisabledByDefault) { \"NotConfigured\" } else { $ServerDisabledByDefault }\n            ClientEnabled = if ($null -eq $ClientEnabled) { \"NotConfigured\" } else { $ClientEnabled }\n        }\n        $Result.Protocols[$Protocol] = $ProtocolInfo\n\n        # Legacy protocol is drifted if not explicitly disabled\n        if ($ServerEnabled -ne 0 -or $ServerDisabledByDefault -ne 1) {\n            $Result.Drifted = $true\n            $Result.Issues += \"$Protocol server not explicitly disabled\"\n        }\n        if ($ClientEnabled -ne 0) {\n            $Result.Drifted = $true\n            $Result.Issues += \"$Protocol client not explicitly disabled\"\n        }\n    }\n\n    # Check modern protocols (should be enabled)\n    foreach ($Protocol in $ModernProtocols) {\n        $ServerPath = \"$BasePath\\$Protocol\\Server\"\n        $ClientPath = \"$BasePath\\$Protocol\\Client\"\n\n        $ServerEnabled = (Get-ItemProperty -Path $ServerPath -Name \"Enabled\" -ErrorAction SilentlyContinue).Enabled\n        $ClientEnabled = (Get-ItemProperty -Path $ClientPath -Name \"Enabled\" -ErrorAction SilentlyContinue).Enabled\n\n        $ProtocolInfo = @{\n            ServerEnabled = if ($null -eq $ServerEnabled) { \"NotConfigured\" } else { $ServerEnabled }\n            ClientEnabled = if ($null -eq $ClientEnabled) { \"NotConfigured\" } else { $ClientEnabled }\n        }\n        $Result.Protocols[$Protocol] = $ProtocolInfo\n\n        # TLS 1.2 should be explicitly enabled\n        if ($ServerEnabled -eq 0) {\n            $Result.Drifted = $true\n            $Result.Issues += \"$Protocol server is disabled\"\n        }\n    }\n\n    # Check for weak cipher suites\n    $WeakCiphers = Get-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Ciphers\\RC4 128/128\" -Name \"Enabled\" -ErrorAction SilentlyContinue\n    if ($null -ne $WeakCiphers -and $WeakCiphers.Enabled -ne 0) {\n        $Result.Issues += \"RC4 cipher is still enabled\"\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Drifted = $true\n}\n\n$Result | ConvertTo-Json -Depth 3",
    "remediate_script": "# Disable legacy TLS/SSL protocols and enable TLS 1.2+\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    $BasePath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\"\n\n    # Disable legacy protocols\n    $LegacyProtocols = @(\"SSL 2.0\", \"SSL 3.0\", \"TLS 1.0\", \"TLS 1.1\")\n\n    foreach ($Protocol in $LegacyProtocols) {\n        foreach ($Side in @(\"Server\", \"Client\")) {\n            $Path = \"$BasePath\\$Protocol\\$Side\"\n            if (-not (Test-Path $Path)) {\n                New-Item -Path $Path -Force | Out-Null\n            }\n            Set-ItemProperty -Path $Path -Name \"Enabled\" -Value 0 -Type DWord\n            Set-ItemProperty -Path $Path -Name \"DisabledByDefault\" -Value 1 -Type DWord\n        }\n        $Result.Actions += \"Disabled $Protocol (Server and Client)\"\n    }\n\n    # Enable TLS 1.2\n    foreach ($Side in @(\"Server\", \"Client\")) {\n        $Path = \"$BasePath\\TLS 1.2\\$Side\"\n        if (-not (Test-Path $Path)) {\n            New-Item -Path $Path -Force | Out-Null\n        }\n        Set-ItemProperty -Path $Path -Name \"Enabled\" -Value 1 -Type DWord\n        Set-ItemProperty -Path $Path -Name \"DisabledByDefault\" -Value 0 -Type DWord\n    }\n    $Result.Actions += \"Enabled TLS 1.2 (Server and Client)\"\n\n    # Enable TLS 1.3 if registry path is available\n    foreach ($Side in @(\"Server\", \"Client\")) {\n        $Path = \"$BasePath\\TLS 1.3\\$Side\"\n        if (-not (Test-Path $Path)) {\n            New-Item -Path $Path -Force | Out-Null\n        }\n        Set-ItemProperty -Path $Path -Name \"Enabled\" -Value 1 -Type DWord\n        Set-ItemProperty -Path $Path -Name \"DisabledByDefault\" -Value 0 -Type DWord\n    }\n    $Result.Actions += \"Enabled TLS 1.3 (Server and Client)\"\n\n    # Disable RC4 cipher\n    $RC4Path = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Ciphers\\RC4 128/128\"\n    if (-not (Test-Path $RC4Path)) {\n        New-Item -Path $RC4Path -Force | Out-Null\n    }\n    Set-ItemProperty -Path $RC4Path -Name \"Enabled\" -Value 0 -Type DWord\n    $Result.Actions += \"Disabled RC4 cipher\"\n\n    # Ensure .NET Framework uses strong crypto\n    $NetFx64 = \"HKLM:\\SOFTWARE\\Microsoft\\.NETFramework\\v4.0.30319\"\n    $NetFx32 = \"HKLM:\\SOFTWARE\\Wow6432Node\\Microsoft\\.NETFramework\\v4.0.30319\"\n    foreach ($Path in @($NetFx64, $NetFx32)) {\n        if (Test-Path $Path) {\n            Set-ItemProperty -Path $Path -Name \"SchUseStrongCrypto\" -Value 1 -Type DWord\n        }\n    }\n    $Result.Actions += \"Enabled .NET strong crypto\"\n\n    $Result.Success = $true\n    $Result.Message = \"TLS/SSL configuration hardened\"\n    $Result.Warning = \"Reboot required for changes to take effect\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "verify_script": "# Verify TLS configuration\n$BasePath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\"\n\ntry {\n    # Check TLS 1.0 is disabled\n    $TLS10Enabled = (Get-ItemProperty -Path \"$BasePath\\TLS 1.0\\Server\" -Name \"Enabled\" -ErrorAction SilentlyContinue).Enabled\n    $TLS10Disabled = ($TLS10Enabled -eq 0)\n\n    # Check TLS 1.1 is disabled\n    $TLS11Enabled = (Get-ItemProperty -Path \"$BasePath\\TLS 1.1\\Server\" -Name \"Enabled\" -ErrorAction SilentlyContinue).Enabled\n    $TLS11Disabled = ($TLS11Enabled -eq 0)\n\n    # Check SSL 3.0 is disabled\n    $SSL3Enabled = (Get-ItemProperty -Path \"$BasePath\\SSL 3.0\\Server\" -Name \"Enabled\" -ErrorAction SilentlyContinue).Enabled\n    $SSL3Disabled = ($SSL3Enabled -eq 0)\n\n    # Check TLS 1.2 is enabled\n    $TLS12Enabled = (Get-ItemProperty -Path \"$BasePath\\TLS 1.2\\Server\" -Name \"Enabled\" -ErrorAction SilentlyContinue).Enabled\n    $TLS12Ok = ($TLS12Enabled -ne 0)\n\n    @{\n        TLS10Disabled = $TLS10Disabled\n        TLS11Disabled = $TLS11Disabled\n        SSL3Disabled = $SSL3Disabled\n        TLS12Enabled = $TLS12Ok\n        Verified = ($TLS10Disabled -and $TLS11Disabled -and $SSL3Disabled -and $TLS12Ok)\n    } | ConvertTo-Json\n} catch {\n    @{ Verified = $false; Error = $_.Exception.Message } | ConvertTo-Json\n}",
    "hipaa_controls": [
      "164.312(e)(1)",
      "164.312(e)(2)(ii)"
    ],
    "severity": "high",
    "timeout_seconds": 120
  },
  "RB-WIN-SEC-011": {
    "id": "RB-WIN-SEC-011",
    "name": "UAC Enforcement",
    "platform": "windows",
    "detect_script": "# Check UAC settings\n$Result = @{\n    Drifted = $false\n    Issues = @()\n}\n\n$UACPath = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\"\n\n# EnableLUA - UAC enabled/disabled\n$EnableLUA = (Get-ItemProperty -Path $UACPath -Name \"EnableLUA\" -ErrorAction SilentlyContinue).EnableLUA\n$Result.UACEnabled = ($EnableLUA -eq 1)\n\n# ConsentPromptBehaviorAdmin - Admin prompt behavior\n$AdminPrompt = (Get-ItemProperty -Path $UACPath -Name \"ConsentPromptBehaviorAdmin\" -ErrorAction SilentlyContinue).ConsentPromptBehaviorAdmin\n$Result.AdminPromptBehavior = $AdminPrompt\n# 0 = Elevate without prompting, 1 = Prompt for credentials on secure desktop\n# 2 = Prompt for consent on secure desktop, 3 = Prompt for credentials\n# 4 = Prompt for consent, 5 = Prompt for consent for non-Windows binaries\n\n# PromptOnSecureDesktop - Secure desktop for prompts\n$SecureDesktop = (Get-ItemProperty -Path $UACPath -Name \"PromptOnSecureDesktop\" -ErrorAction SilentlyContinue).PromptOnSecureDesktop\n$Result.SecureDesktopEnabled = ($SecureDesktop -eq 1)\n\n# EnableVirtualization - File/registry virtualization\n$Virtualization = (Get-ItemProperty -Path $UACPath -Name \"EnableVirtualization\" -ErrorAction SilentlyContinue).EnableVirtualization\n$Result.VirtualizationEnabled = ($Virtualization -eq 1)\n\n# Check for drift\nif ($EnableLUA -ne 1) {\n    $Result.Drifted = $true\n    $Result.Issues += \"UAC is disabled\"\n}\nif ($AdminPrompt -eq 0) {\n    $Result.Drifted = $true\n    $Result.Issues += \"Admin elevation without prompting\"\n}\nif ($SecureDesktop -ne 1) {\n    $Result.Drifted = $true\n    $Result.Issues += \"Secure desktop disabled for UAC prompts\"\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "remediate_script": "# Enable and configure UAC\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    $UACPath = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\"\n\n    # Enable UAC\n    Set-ItemProperty -Path $UACPath -Name \"EnableLUA\" -Value 1 -Type DWord\n    $Result.Actions += \"Enabled UAC\"\n\n    # Set admin prompt to secure desktop with consent\n    Set-ItemProperty -Path $UACPath -Name \"ConsentPromptBehaviorAdmin\" -Value 2 -Type DWord\n    $Result.Actions += \"Set admin prompt to secure desktop with consent\"\n\n    # Enable secure desktop\n    Set-ItemProperty -Path $UACPath -Name \"PromptOnSecureDesktop\" -Value 1 -Type DWord\n    $Result.Actions += \"Enabled secure desktop\"\n\n    # Enable virtualization\n    Set-ItemProperty -Path $UACPath -Name \"EnableVirtualization\" -Value 1 -Type DWord\n    $Result.Actions += \"Enabled file/registry virtualization\"\n\n    $Result.Success = $true\n    $Result.Message = \"UAC enforced\"\n    $Result.Warning = \"Reboot may be required for full effect\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "$UACPath = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\"\n$EnableLUA = (Get-ItemProperty -Path $UACPath -Name \"EnableLUA\" -ErrorAction SilentlyContinue).EnableLUA\n$AdminPrompt = (Get-ItemProperty -Path $UACPath -Name \"ConsentPromptBehaviorAdmin\" -ErrorAction SilentlyContinue).ConsentPromptBehaviorAdmin\n@{\n    UACEnabled = ($EnableLUA -eq 1)\n    AdminPrompt = $AdminPrompt\n    Verified = ($EnableLUA -eq 1 -and $AdminPrompt -gt 0)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(a)(1)",
      "164.312(a)(2)(i)"
    ],
    "severity": "high",
    "timeout_seconds": 60
  },
  "RB-WIN-SEC-009": {
    "id": "RB-WIN-SEC-009",
    "name": "Unauthorized User Detection",
    "platform": "windows",
    "detect_script": "# Detect unauthorized local admin accounts\n$Result = @{\n    Drifted = $false\n    LocalAdmins = @()\n    SuspiciousAccounts = @()\n}\n\n# Known legitimate admin accounts (customize per environment)\n$KnownAdmins = @(\"Administrator\", \"Domain Admins\", \"Enterprise Admins\", \"svc.monitoring\", \"svc.backup\")\n\n# Get local administrators group members\n$AdminGroup = [ADSI]\"WinNT://./Administrators,group\"\n$Members = @($AdminGroup.Invoke(\"Members\")) | ForEach-Object {\n    $Path = ([ADSI]$_).Path\n    $Name = $Path.Split(\"/\")[-1]\n    @{\n        Name = $Name\n        Path = $Path\n        Type = if ($Path -match \"WinNT://[^/]+/[^/]+$\") { \"Local\" } else { \"Domain\" }\n    }\n}\n\n$Result.LocalAdmins = $Members\n\n# Check for suspicious accounts\nforeach ($Member in $Members) {\n    $IsKnown = $false\n    foreach ($KnownAdmin in $KnownAdmins) {\n        if ($Member.Name -like \"*$KnownAdmin*\") {\n            $IsKnown = $true\n            break\n        }\n    }\n\n    if (-not $IsKnown -and $Member.Type -eq \"Local\") {\n        # Check account creation date\n        $User = Get-LocalUser -Name $Member.Name -ErrorAction SilentlyContinue\n        if ($User) {\n            $SuspiciousInfo = @{\n                Name = $Member.Name\n                Created = $User.PasswordLastSet\n                Enabled = $User.Enabled\n                Description = $User.Description\n            }\n\n            # Check if recently created (within 24 hours)\n            if ($User.PasswordLastSet -and (Get-Date) - $User.PasswordLastSet -lt (New-TimeSpan -Hours 24)) {\n                $SuspiciousInfo.RecentlyCreated = $true\n            }\n\n            $Result.SuspiciousAccounts += $SuspiciousInfo\n            $Result.Drifted = $true\n        }\n    }\n}\n\n$Result.SuspiciousCount = $Result.SuspiciousAccounts.Count\n$Result | ConvertTo-Json -Depth 3",
    "remediate_script": "# Disable suspicious local admin accounts\n$Result = @{ Success = $false; Actions = @() }\n\n$KnownAdmins = @(\"Administrator\", \"Domain Admins\", \"Enterprise Admins\", \"svc.monitoring\", \"svc.backup\")\n\ntry {\n    # Get local administrators\n    $AdminGroup = [ADSI]\"WinNT://./Administrators,group\"\n    $Members = @($AdminGroup.Invoke(\"Members\")) | ForEach-Object {\n        $Path = ([ADSI]$_).Path\n        $Name = $Path.Split(\"/\")[-1]\n        @{ Name = $Name; Path = $Path; Type = if ($Path -match \"WinNT://[^/]+/[^/]+$\") { \"Local\" } else { \"Domain\" } }\n    }\n\n    foreach ($Member in $Members) {\n        $IsKnown = $false\n        foreach ($KnownAdmin in $KnownAdmins) {\n            if ($Member.Name -like \"*$KnownAdmin*\") { $IsKnown = $true; break }\n        }\n\n        if (-not $IsKnown -and $Member.Type -eq \"Local\") {\n            $User = Get-LocalUser -Name $Member.Name -ErrorAction SilentlyContinue\n            if ($User -and $User.Enabled) {\n                # Disable the suspicious account (don't delete - preserve for forensics)\n                Disable-LocalUser -Name $Member.Name\n                $Result.Actions += \"Disabled suspicious account: $($Member.Name)\"\n\n                # Remove from Administrators group\n                Remove-LocalGroupMember -Group \"Administrators\" -Member $Member.Name -ErrorAction SilentlyContinue\n                $Result.Actions += \"Removed from Administrators: $($Member.Name)\"\n            }\n        }\n    }\n\n    $Result.Success = $true\n    $Result.Message = \"Suspicious accounts disabled\"\n    $Result.Warning = \"Review disabled accounts and delete if confirmed malicious\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "$KnownAdmins = @(\"Administrator\", \"Domain Admins\", \"Enterprise Admins\", \"svc.monitoring\", \"svc.backup\")\n$AdminGroup = [ADSI]\"WinNT://./Administrators,group\"\n$Members = @($AdminGroup.Invoke(\"Members\")) | ForEach-Object { ([ADSI]$_).Path.Split(\"/\")[-1] }\n$Unknown = $Members | Where-Object { $Name = $_; -not ($KnownAdmins | Where-Object { $Name -like \"*$_*\" }) }\n@{\n    AdminCount = $Members.Count\n    UnknownAdmins = @($Unknown)\n    Verified = ($Unknown.Count -eq 0)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(a)(2)(i)",
      "164.308(a)(3)(ii)(A)"
    ],
    "severity": "critical",
    "timeout_seconds": 120
  },
  "RB-WIN-SEC-015": {
    "id": "RB-WIN-SEC-015",
    "name": "USB/Removable Media Control",
    "platform": "windows",
    "detect_script": "# Check USB storage and autorun configuration\n$Result = @{\n    Drifted = $false\n    Issues = @()\n}\n\ntry {\n    # Check USBSTOR service start type\n    # 3 = Manual (default), 4 = Disabled\n    $USBSTORKey = \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\USBSTOR\"\n    $USBSTORStart = (Get-ItemProperty -Path $USBSTORKey -Name \"Start\" -ErrorAction SilentlyContinue).Start\n    $Result.USBSTORStartType = $USBSTORStart\n\n    $StartTypeName = switch ($USBSTORStart) {\n        0 { \"Boot\" }\n        1 { \"System\" }\n        2 { \"Automatic\" }\n        3 { \"Manual\" }\n        4 { \"Disabled\" }\n        default { \"Unknown\" }\n    }\n    $Result.USBSTORStartTypeName = $StartTypeName\n\n    if ($USBSTORStart -ne 4) {\n        $Result.Drifted = $true\n        $Result.Issues += \"USB storage service is not disabled (current: $StartTypeName)\"\n    }\n\n    # Check AutoRun/AutoPlay settings\n    $AutoRunKey = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\"\n    $NoDriveTypeAutoRun = (Get-ItemProperty -Path $AutoRunKey -Name \"NoDriveTypeAutoRun\" -ErrorAction SilentlyContinue).NoDriveTypeAutoRun\n    $Result.NoDriveTypeAutoRun = $NoDriveTypeAutoRun\n\n    # 0xFF = Disable autorun for all drive types\n    if ($NoDriveTypeAutoRun -ne 255) {\n        $Result.Drifted = $true\n        $Result.Issues += \"AutoRun not fully disabled (should be 0xFF/255)\"\n    }\n\n    # Check removable storage access policy (GPO)\n    $RemovableKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\RemovableStorageDevices\"\n    $DenyAll = (Get-ItemProperty -Path \"$RemovableKey\\{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}\" -Name \"Deny_All\" -ErrorAction SilentlyContinue).Deny_All\n    $Result.RemovableStorageDenied = ($DenyAll -eq 1)\n\n    # Check for currently connected USB storage devices\n    $USBDevices = Get-WmiObject Win32_DiskDrive | Where-Object { $_.InterfaceType -eq \"USB\" }\n    $Result.ConnectedUSBDrives = @($USBDevices).Count\n    if ($USBDevices) {\n        $Result.Issues += \"$(@($USBDevices).Count) USB storage device(s) currently connected\"\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Drifted = $true\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "remediate_script": "# Disable USB storage and autorun\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # Disable USBSTOR service (set start type to 4 = Disabled)\n    $USBSTORKey = \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\USBSTOR\"\n    Set-ItemProperty -Path $USBSTORKey -Name \"Start\" -Value 4 -Type DWord\n    $Result.Actions += \"Disabled USBSTOR service (Start = 4)\"\n\n    # Disable AutoRun for all drive types\n    $ExplorerKey = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\"\n    if (-not (Test-Path $ExplorerKey)) {\n        New-Item -Path $ExplorerKey -Force | Out-Null\n    }\n    Set-ItemProperty -Path $ExplorerKey -Name \"NoDriveTypeAutoRun\" -Value 255 -Type DWord\n    $Result.Actions += \"Disabled AutoRun for all drive types (0xFF)\"\n\n    # Disable AutoPlay\n    Set-ItemProperty -Path $ExplorerKey -Name \"NoAutorun\" -Value 1 -Type DWord\n    $Result.Actions += \"Disabled AutoPlay\"\n\n    # Set removable storage deny policy\n    $RemovableKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\RemovableStorageDevices\\{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}\"\n    if (-not (Test-Path $RemovableKey)) {\n        New-Item -Path $RemovableKey -Force | Out-Null\n    }\n    Set-ItemProperty -Path $RemovableKey -Name \"Deny_All\" -Value 1 -Type DWord\n    $Result.Actions += \"Set removable storage deny policy\"\n\n    # Also set for WPD devices (phones, cameras)\n    $WPDKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\RemovableStorageDevices\\{6AC27878-A6FA-4155-BA85-F98F491D4F33}\"\n    if (-not (Test-Path $WPDKey)) {\n        New-Item -Path $WPDKey -Force | Out-Null\n    }\n    Set-ItemProperty -Path $WPDKey -Name \"Deny_All\" -Value 1 -Type DWord\n    $Result.Actions += \"Set WPD device deny policy\"\n\n    $Result.Success = $true\n    $Result.Message = \"USB storage and autorun disabled\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "verify_script": "# Verify USB storage restrictions\ntry {\n    $USBSTORStart = (Get-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\USBSTOR\" -Name \"Start\" -ErrorAction SilentlyContinue).Start\n    $AutoRun = (Get-ItemProperty -Path \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\" -Name \"NoDriveTypeAutoRun\" -ErrorAction SilentlyContinue).NoDriveTypeAutoRun\n\n    @{\n        USBSTORDisabled = ($USBSTORStart -eq 4)\n        AutoRunDisabled = ($AutoRun -eq 255)\n        Verified = ($USBSTORStart -eq 4 -and $AutoRun -eq 255)\n    } | ConvertTo-Json\n} catch {\n    @{ Verified = $false; Error = $_.Exception.Message } | ConvertTo-Json\n}",
    "hipaa_controls": [
      "164.310(d)(1)",
      "164.312(a)(1)"
    ],
    "severity": "medium",
    "timeout_seconds": 60
  },
  "RB-WIN-SEC-021": {
    "id": "RB-WIN-SEC-021",
    "name": "WMI Event Subscription Persistence Removal",
    "platform": "windows",
    "detect_script": "# Check for suspicious WMI event subscriptions (persistence mechanism)\n$Result = @{\n    Drifted = $false\n    Issues = @()\n    Filters = @()\n    Consumers = @()\n    Bindings = @()\n}\n\n# Known safe system WMI filter/consumer names\n$SafeNames = @(\n    'BVTFilter',\n    'SCM Event Log Filter',\n    '__InstanceOperationEvent',\n    'Microsoft-Windows-*',\n    'WMI Self-Instrumentation*'\n)\n\nfunction Test-IsSafe($name) {\n    foreach ($safe in $SafeNames) {\n        if ($name -like $safe) { return $true }\n    }\n    return $false\n}\n\ntry {\n    # Check EventFilters\n    $filters = Get-WmiObject -Namespace root\\subscription -Class __EventFilter -ErrorAction SilentlyContinue\n    foreach ($f in $filters) {\n        if (-not (Test-IsSafe $f.Name)) {\n            $Result.Drifted = $true\n            $Result.Filters += @{\n                Name = $f.Name\n                Query = $f.QueryLanguage + \": \" + $f.Query\n            }\n            $Result.Issues += \"Suspicious EventFilter: $($f.Name)\"\n        }\n    }\n\n    # Check EventConsumers (multiple types)\n    $consumerClasses = @(\n        'CommandLineEventConsumer',\n        'ActiveScriptEventConsumer',\n        'LogFileEventConsumer'\n    )\n    foreach ($cls in $consumerClasses) {\n        $consumers = Get-WmiObject -Namespace root\\subscription -Class $cls -ErrorAction SilentlyContinue\n        foreach ($c in $consumers) {\n            if (-not (Test-IsSafe $c.Name)) {\n                $Result.Drifted = $true\n                $consumerInfo = @{ Name = $c.Name; Type = $cls }\n                if ($c.CommandLineTemplate) { $consumerInfo.Command = $c.CommandLineTemplate }\n                if ($c.ScriptText) { $consumerInfo.Script = $c.ScriptText.Substring(0, [Math]::Min(200, $c.ScriptText.Length)) }\n                $Result.Consumers += $consumerInfo\n                $Result.Issues += \"Suspicious $cls`: $($c.Name)\"\n            }\n        }\n    }\n\n    # Check FilterToConsumerBindings\n    $bindings = Get-WmiObject -Namespace root\\subscription -Class __FilterToConsumerBinding -ErrorAction SilentlyContinue\n    foreach ($b in $bindings) {\n        $filterName = ($b.Filter -split '\"')[1]\n        $consumerName = ($b.Consumer -split '\"')[1]\n        if (-not (Test-IsSafe $filterName) -or -not (Test-IsSafe $consumerName)) {\n            $Result.Drifted = $true\n            $Result.Bindings += @{\n                Filter = $filterName\n                Consumer = $consumerName\n            }\n        }\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result.TotalSuspicious = $Result.Filters.Count + $Result.Consumers.Count\n$Result | ConvertTo-Json -Depth 3",
    "remediate_script": "# Remove suspicious WMI event subscriptions\n$Result = @{ Success = $false; Actions = @(); Errors = @() }\n\n$SafeNames = @(\n    'BVTFilter',\n    'SCM Event Log Filter',\n    '__InstanceOperationEvent',\n    'Microsoft-Windows-*',\n    'WMI Self-Instrumentation*'\n)\n\nfunction Test-IsSafe($name) {\n    foreach ($safe in $SafeNames) {\n        if ($name -like $safe) { return $true }\n    }\n    return $false\n}\n\ntry {\n    # Remove bindings first (must be removed before filters/consumers)\n    $bindings = Get-WmiObject -Namespace root\\subscription -Class __FilterToConsumerBinding -ErrorAction SilentlyContinue\n    foreach ($b in $bindings) {\n        $filterName = ($b.Filter -split '\"')[1]\n        $consumerName = ($b.Consumer -split '\"')[1]\n        if (-not (Test-IsSafe $filterName) -or -not (Test-IsSafe $consumerName)) {\n            try {\n                $b | Remove-WmiObject\n                $Result.Actions += \"Removed binding: $filterName -> $consumerName\"\n            } catch {\n                $Result.Errors += \"Failed to remove binding: $($_.Exception.Message)\"\n            }\n        }\n    }\n\n    # Remove suspicious EventFilters\n    $filters = Get-WmiObject -Namespace root\\subscription -Class __EventFilter -ErrorAction SilentlyContinue\n    foreach ($f in $filters) {\n        if (-not (Test-IsSafe $f.Name)) {\n            try {\n                $f | Remove-WmiObject\n                $Result.Actions += \"Removed EventFilter: $($f.Name)\"\n            } catch {\n                $Result.Errors += \"Failed to remove filter $($f.Name): $($_.Exception.Message)\"\n            }\n        }\n    }\n\n    # Remove suspicious EventConsumers\n    $consumerClasses = @(\n        'CommandLineEventConsumer',\n        'ActiveScriptEventConsumer',\n        'LogFileEventConsumer'\n    )\n    foreach ($cls in $consumerClasses) {\n        $consumers = Get-WmiObject -Namespace root\\subscription -Class $cls -ErrorAction SilentlyContinue\n        foreach ($c in $consumers) {\n            if (-not (Test-IsSafe $c.Name)) {\n                try {\n                    $c | Remove-WmiObject\n                    $Result.Actions += \"Removed $cls`: $($c.Name)\"\n                } catch {\n                    $Result.Errors += \"Failed to remove consumer $($c.Name): $($_.Exception.Message)\"\n                }\n            }\n        }\n    }\n\n    $Result.Success = ($Result.Errors.Count -eq 0)\n    $Result.Message = \"Removed $($Result.Actions.Count) WMI persistence objects\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "verify_script": "# Verify no suspicious WMI subscriptions remain\n$suspicious = 0\n$SafeNames = @('BVTFilter','SCM Event Log Filter','__InstanceOperationEvent','Microsoft-Windows-*','WMI Self-Instrumentation*')\n\nfunction Test-IsSafe($name) {\n    foreach ($safe in $SafeNames) { if ($name -like $safe) { return $true } }\n    return $false\n}\n\n$filters = Get-WmiObject -Namespace root\\subscription -Class __EventFilter -ErrorAction SilentlyContinue\nforeach ($f in $filters) { if (-not (Test-IsSafe $f.Name)) { $suspicious++ } }\n\n$consumerClasses = @('CommandLineEventConsumer','ActiveScriptEventConsumer','LogFileEventConsumer')\nforeach ($cls in $consumerClasses) {\n    $consumers = Get-WmiObject -Namespace root\\subscription -Class $cls -ErrorAction SilentlyContinue\n    foreach ($c in $consumers) { if (-not (Test-IsSafe $c.Name)) { $suspicious++ } }\n}\n\n@{\n    SuspiciousRemaining = $suspicious\n    Verified = ($suspicious -eq 0)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.308(a)(5)(ii)(C)",
      "164.312(a)(1)"
    ],
    "severity": "critical",
    "timeout_seconds": 120
  },
  "RB-WIN-SVC-002": {
    "id": "RB-WIN-SVC-002",
    "name": "DHCP Server Service Recovery",
    "platform": "windows",
    "detect_script": "# Check DHCP Server service status\n$ServiceName = \"DHCPServer\"\n$Result = @{\n    ServiceName = $ServiceName\n    Drifted = $false\n}\n\ntry {\n    $Service = Get-Service -Name $ServiceName -ErrorAction Stop\n    $Result.Status = $Service.Status.ToString()\n    $Result.StartType = $Service.StartType.ToString()\n    $Result.Drifted = ($Service.Status -ne \"Running\")\n\n    # Check if DHCP role is installed\n    $DHCPFeature = Get-WindowsFeature -Name DHCP -ErrorAction SilentlyContinue\n    $Result.DHCPRoleInstalled = ($DHCPFeature -and $DHCPFeature.Installed)\n\n    if (-not $Result.DHCPRoleInstalled) {\n        $Result.Drifted = $false\n        $Result.Note = \"DHCP role not installed - skipping\"\n    }\n\n    # Get scope info if running\n    if ($Service.Status -eq \"Running\") {\n        $Scopes = Get-DhcpServerv4Scope -ErrorAction SilentlyContinue\n        $Result.ScopeCount = @($Scopes).Count\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Drifted = $false\n    $Result.Note = \"DHCP service not found\"\n}\n\n$Result | ConvertTo-Json",
    "remediate_script": "# Restart DHCP Server service\n$ServiceName = \"DHCPServer\"\n$Result = @{ Success = $false }\n\ntry {\n    $Service = Get-Service -Name $ServiceName -ErrorAction Stop\n\n    if ($Service.Status -ne \"Running\") {\n        Start-Service -Name $ServiceName -ErrorAction Stop\n        Start-Sleep -Seconds 5\n\n        $Service = Get-Service -Name $ServiceName\n        $Result.Success = ($Service.Status -eq \"Running\")\n        $Result.Status = $Service.Status.ToString()\n        $Result.Message = \"DHCP service started successfully\"\n    } else {\n        $Result.Success = $true\n        $Result.Message = \"DHCP service already running\"\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "# Verify DHCP service is running\n$Service = Get-Service -Name \"DHCPServer\" -ErrorAction SilentlyContinue\n@{\n    Status = if ($Service) { $Service.Status.ToString() } else { \"NotFound\" }\n    Verified = ($Service -and $Service.Status -eq \"Running\")\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(b)"
    ],
    "severity": "high",
    "timeout_seconds": 120
  },
  "RB-WIN-SVC-001": {
    "id": "RB-WIN-SVC-001",
    "name": "DNS Server Service Recovery",
    "platform": "windows",
    "detect_script": "# Check DNS Server service status\n$ServiceName = \"DNS\"\n$Result = @{\n    ServiceName = $ServiceName\n    Drifted = $false\n}\n\ntry {\n    $Service = Get-Service -Name $ServiceName -ErrorAction Stop\n    $Result.Status = $Service.Status.ToString()\n    $Result.StartType = $Service.StartType.ToString()\n    $Result.Drifted = ($Service.Status -ne \"Running\")\n\n    # Check if it's a DNS server role\n    $DNSFeature = Get-WindowsFeature -Name DNS -ErrorAction SilentlyContinue\n    $Result.DNSRoleInstalled = ($DNSFeature -and $DNSFeature.Installed)\n\n    if (-not $Result.DNSRoleInstalled) {\n        $Result.Drifted = $false\n        $Result.Note = \"DNS role not installed - skipping\"\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Drifted = $false\n    $Result.Note = \"DNS service not found\"\n}\n\n$Result | ConvertTo-Json",
    "remediate_script": "# Restart DNS Server service\n$ServiceName = \"DNS\"\n$Result = @{ Success = $false }\n\ntry {\n    $Service = Get-Service -Name $ServiceName -ErrorAction Stop\n\n    if ($Service.Status -ne \"Running\") {\n        Start-Service -Name $ServiceName -ErrorAction Stop\n        Start-Sleep -Seconds 5\n\n        $Service = Get-Service -Name $ServiceName\n        $Result.Success = ($Service.Status -eq \"Running\")\n        $Result.Status = $Service.Status.ToString()\n        $Result.Message = \"DNS service started successfully\"\n    } else {\n        $Result.Success = $true\n        $Result.Message = \"DNS service already running\"\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "# Verify DNS service is running\n$Service = Get-Service -Name \"DNS\" -ErrorAction SilentlyContinue\n@{\n    Status = if ($Service) { $Service.Status.ToString() } else { \"NotFound\" }\n    Verified = ($Service -and $Service.Status -eq \"Running\")\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(b)"
    ],
    "severity": "critical",
    "timeout_seconds": 120
  },
  "RB-WIN-SVC-003": {
    "id": "RB-WIN-SVC-003",
    "name": "Print Spooler Service Recovery",
    "platform": "windows",
    "detect_script": "# Check Print Spooler status (security-conscious)\n$ServiceName = \"Spooler\"\n$Result = @{\n    ServiceName = $ServiceName\n    Drifted = $false\n}\n\ntry {\n    $Service = Get-Service -Name $ServiceName -ErrorAction Stop\n    $Result.Status = $Service.Status.ToString()\n    $Result.StartType = $Service.StartType.ToString()\n\n    # Check if this is a print server or DC\n    $IsDC = (Get-WmiObject Win32_ComputerSystem).DomainRole -ge 4\n    $HasPrintRole = (Get-WindowsFeature -Name Print-Services -ErrorAction SilentlyContinue).Installed\n\n    $Result.IsDomainController = $IsDC\n    $Result.PrintServerRole = $HasPrintRole\n\n    # Print Spooler should be DISABLED on DCs (security)\n    if ($IsDC -and $Service.Status -eq \"Running\") {\n        $Result.SecurityWarning = \"Print Spooler running on DC - security risk\"\n        $Result.Drifted = $true\n        $Result.RecommendedAction = \"Disable\"\n    } elseif ($HasPrintRole -and $Service.Status -ne \"Running\") {\n        # Print server needs spooler running\n        $Result.Drifted = $true\n        $Result.RecommendedAction = \"Start\"\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "remediate_script": "# Handle Print Spooler based on role\n$ServiceName = \"Spooler\"\n$Result = @{ Success = $false }\n\ntry {\n    $IsDC = (Get-WmiObject Win32_ComputerSystem).DomainRole -ge 4\n    $Service = Get-Service -Name $ServiceName -ErrorAction Stop\n\n    if ($IsDC) {\n        # Stop and disable on DCs for security\n        Stop-Service -Name $ServiceName -Force -ErrorAction SilentlyContinue\n        Set-Service -Name $ServiceName -StartupType Disabled\n        $Result.Success = $true\n        $Result.Action = \"Disabled on DC for security\"\n    } else {\n        # Start on non-DC if stopped\n        if ($Service.Status -ne \"Running\") {\n            Start-Service -Name $ServiceName -ErrorAction Stop\n            Start-Sleep -Seconds 3\n        }\n        $Service = Get-Service -Name $ServiceName\n        $Result.Success = ($Service.Status -eq \"Running\")\n        $Result.Action = \"Started\"\n    }\n\n    $Result.Status = (Get-Service -Name $ServiceName).Status.ToString()\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "$IsDC = (Get-WmiObject Win32_ComputerSystem).DomainRole -ge 4\n$Service = Get-Service -Name \"Spooler\" -ErrorAction SilentlyContinue\n$Expected = if ($IsDC) { \"Stopped\" } else { \"Running\" }\n$ActualStatus = if ($Service) { $Service.Status.ToString() } else { \"NotFound\" }\n@{\n    Status = $ActualStatus\n    Expected = $Expected\n    Verified = ($ActualStatus -eq $Expected)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.308(a)(5)(ii)(B)"
    ],
    "severity": "medium",
    "timeout_seconds": 60
  },
  "RB-WIN-SVC-004": {
    "id": "RB-WIN-SVC-004",
    "name": "Windows Time Service Recovery",
    "platform": "windows",
    "detect_script": "# Check Windows Time service and sync status\n$ServiceName = \"W32Time\"\n$Result = @{\n    ServiceName = $ServiceName\n    Drifted = $false\n}\n\ntry {\n    $Service = Get-Service -Name $ServiceName -ErrorAction Stop\n    $Result.Status = $Service.Status.ToString()\n    $Result.StartType = $Service.StartType.ToString()\n\n    # Check time sync status\n    $TimeStatus = w32tm /query /status 2>&1\n    if ($LASTEXITCODE -eq 0) {\n        $Result.TimeSource = ($TimeStatus | Select-String \"Source:\").ToString().Split(\":\")[1].Trim()\n        $Result.LastSync = ($TimeStatus | Select-String \"Last Successful Sync Time:\").ToString().Split(\":\",2)[1].Trim()\n        $Result.Stratum = [int]($TimeStatus | Select-String \"Stratum:\").ToString().Split(\":\")[1].Trim()\n    }\n\n    # Drift detection\n    if ($Service.Status -ne \"Running\") {\n        $Result.Drifted = $true\n        $Result.DriftReason = \"Service not running\"\n    } elseif ($Result.Stratum -gt 10) {\n        $Result.Drifted = $true\n        $Result.DriftReason = \"High stratum - poor time source\"\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Drifted = $true\n}\n\n$Result | ConvertTo-Json",
    "remediate_script": "# Fix Windows Time service\n$Result = @{ Success = $false }\n\ntry {\n    # Ensure service is running\n    $Service = Get-Service -Name \"W32Time\"\n    if ($Service.Status -ne \"Running\") {\n        Set-Service -Name \"W32Time\" -StartupType Automatic\n        Start-Service -Name \"W32Time\" -ErrorAction Stop\n        Start-Sleep -Seconds 3\n    }\n\n    # Force resync\n    w32tm /resync /force | Out-Null\n\n    # Check if domain-joined\n    $Domain = (Get-WmiObject Win32_ComputerSystem).Domain\n    $IsDomainJoined = -not [string]::IsNullOrEmpty($Domain) -and $Domain -ne \"WORKGROUP\"\n\n    if (-not $IsDomainJoined) {\n        # Configure NTP for standalone\n        w32tm /config /manualpeerlist:\"time.nist.gov,0x1 time.windows.com,0x1\" /syncfromflags:manual /reliable:YES /update\n        Restart-Service -Name \"W32Time\"\n        w32tm /resync\n    }\n\n    $Service = Get-Service -Name \"W32Time\"\n    $Result.Success = ($Service.Status -eq \"Running\")\n    $Result.Status = $Service.Status.ToString()\n    $Result.Message = \"Time service configured and synced\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "$Service = Get-Service -Name \"W32Time\" -ErrorAction SilentlyContinue\n$TimeStatus = w32tm /query /status 2>&1\n$Stratum = 99\nif ($LASTEXITCODE -eq 0) {\n    $Stratum = [int]($TimeStatus | Select-String \"Stratum:\").ToString().Split(\":\")[1].Trim()\n}\n@{\n    Status = if ($Service) { $Service.Status.ToString() } else { \"NotFound\" }\n    Stratum = $Stratum\n    Verified = ($Service.Status -eq \"Running\" -and $Stratum -lt 10)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(b)"
    ],
    "severity": "high",
    "timeout_seconds": 120
  },
  "RB-WIN-NET-001": {
    "id": "RB-WIN-NET-001",
    "name": "DNS Client Configuration Reset",
    "platform": "windows",
    "detect_script": "# Check DNS client configuration\n$Result = @{\n    Drifted = $false\n    Adapters = @()\n}\n\n$Adapters = Get-NetAdapter | Where-Object { $_.Status -eq \"Up\" }\n\nforeach ($Adapter in $Adapters) {\n    $DNS = Get-DnsClientServerAddress -InterfaceIndex $Adapter.ifIndex -AddressFamily IPv4\n    $AdapterInfo = @{\n        Name = $Adapter.Name\n        InterfaceIndex = $Adapter.ifIndex\n        DNSServers = $DNS.ServerAddresses\n    }\n    $Result.Adapters += $AdapterInfo\n\n    # Check for public DNS on domain-joined machines\n    $IsDomainJoined = (Get-WmiObject Win32_ComputerSystem).PartOfDomain\n    if ($IsDomainJoined) {\n        $PublicDNS = @(\"8.8.8.8\", \"8.8.4.4\", \"1.1.1.1\", \"1.0.0.1\")\n        foreach ($Server in $DNS.ServerAddresses) {\n            if ($Server -in $PublicDNS) {\n                $Result.Drifted = $true\n                $Result.DriftReason = \"Public DNS configured on domain-joined machine\"\n                break\n            }\n        }\n    }\n\n    # Check for empty DNS\n    if (-not $DNS.ServerAddresses -or $DNS.ServerAddresses.Count -eq 0) {\n        $Result.Drifted = $true\n        $Result.DriftReason = \"No DNS servers configured\"\n    }\n}\n\n$Result | ConvertTo-Json -Depth 3",
    "remediate_script": "# Reset DNS configuration based on domain membership\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    $IsDomainJoined = (Get-WmiObject Win32_ComputerSystem).PartOfDomain\n\n    if ($IsDomainJoined) {\n        $DC = $null\n\n        # Step 1: Check if THIS machine is a Domain Controller\n        # If so, DNS should point to itself (loopback or own IP)\n        $isDC = (Get-WmiObject Win32_ComputerSystem).DomainRole -ge 4\n        if ($isDC) {\n            # DC should use its own IP as DNS \u2014 get the primary adapter IP\n            $myIP = (Get-NetIPAddress -AddressFamily IPv4 |\n                Where-Object { $_.IPAddress -ne '127.0.0.1' -and $_.PrefixOrigin -ne 'WellKnown' } |\n                Select-Object -First 1).IPAddress\n            if ($myIP) {\n                $DC = $myIP\n                $Result.Actions += \"Machine is a DC, using own IP ($myIP)\"\n            }\n        }\n\n        # Step 2: Try AD lookup (works if DNS is not hijacked)\n        if (-not $DC) {\n            try {\n                $DC = ([System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()).DomainControllers[0].IPAddress\n            } catch {}\n        }\n\n        # Step 3: Try nltest (also DNS-dependent but different path)\n        if (-not $DC) {\n            try {\n                $nltest = nltest /dsgetdc: 2>&1\n                if ($nltest -match 'DC:\\\\\\\\(\\S+)') {\n                    $DC = [System.Net.Dns]::GetHostAddresses($Matches[1])[0].IPAddressToString\n                }\n            } catch {}\n        }\n\n        # Step 4: Try reading cached DC from registry (survives DNS hijack)\n        if (-not $DC) {\n            try {\n                $cached = (Get-ItemProperty 'HKLM:\\SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters' -Name 'DynamicSiteName' -ErrorAction SilentlyContinue)\n                $dcList = nltest /dsgetdc: /force 2>&1\n                if ($dcList -match '(\\d+\\.\\d+\\.\\d+\\.\\d+)') { $DC = $Matches[1] }\n            } catch {}\n        }\n\n        # Step 5: Last resort \u2014 gateway (likely DC on small networks)\n        if (-not $DC) {\n            $gw = (Get-NetRoute -DestinationPrefix '0.0.0.0/0' -ErrorAction SilentlyContinue | Select-Object -First 1).NextHop\n            if ($gw) { $DC = $gw }\n        }\n\n        if ($DC) {\n            $Adapters = Get-NetAdapter | Where-Object { $_.Status -eq \"Up\" }\n            foreach ($Adapter in $Adapters) {\n                Set-DnsClientServerAddress -InterfaceIndex $Adapter.ifIndex -ServerAddresses $DC\n                $Result.Actions += \"Set DNS to DC ($DC) on $($Adapter.Name)\"\n            }\n        } else {\n            $Result.Error = \"Could not determine DC IP for DNS restoration\"\n        }\n    } else {\n        # Standalone - use DHCP or set reliable DNS\n        $Adapters = Get-NetAdapter | Where-Object { $_.Status -eq \"Up\" }\n        foreach ($Adapter in $Adapters) {\n            $IPConfig = Get-NetIPConfiguration -InterfaceIndex $Adapter.ifIndex\n            if ($IPConfig.NetIPv4Interface.Dhcp -eq \"Enabled\") {\n                Set-DnsClientServerAddress -InterfaceIndex $Adapter.ifIndex -ResetServerAddresses\n                $Result.Actions += \"Reset to DHCP DNS on $($Adapter.Name)\"\n            }\n        }\n    }\n\n    # Flush DNS cache\n    Clear-DnsClientCache\n    $Result.Actions += \"Flushed DNS cache\"\n\n    $Result.Success = $true\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "$Adapters = Get-NetAdapter | Where-Object { $_.Status -eq \"Up\" }\n$HasDNS = $false\n$StillHijacked = $false\n$PublicDNS = @(\"8.8.8.8\", \"8.8.4.4\", \"1.1.1.1\", \"1.0.0.1\")\n$IsDomainJoined = (Get-WmiObject Win32_ComputerSystem).PartOfDomain\nforeach ($Adapter in $Adapters) {\n    $DNS = Get-DnsClientServerAddress -InterfaceIndex $Adapter.ifIndex -AddressFamily IPv4\n    if ($DNS.ServerAddresses.Count -gt 0) {\n        $HasDNS = $true\n        # On domain-joined machines, public DNS means still hijacked\n        if ($IsDomainJoined) {\n            foreach ($Server in $DNS.ServerAddresses) {\n                if ($Server -in $PublicDNS) { $StillHijacked = $true }\n            }\n        }\n    }\n}\n@{\n    HasDNSServers = $HasDNS\n    Verified = ($HasDNS -and -not $StillHijacked)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(b)"
    ],
    "severity": "medium",
    "timeout_seconds": 60
  },
  "RB-WIN-NET-005": {
    "id": "RB-WIN-NET-005",
    "name": "LLMNR/mDNS Disable",
    "platform": "windows",
    "detect_script": "# Check LLMNR and mDNS configuration\n$Result = @{\n    Drifted = $false\n    Issues = @()\n}\n\ntry {\n    # Check LLMNR status via registry (GPO)\n    $LLMNRKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\DNSClient\"\n    $EnableMulticast = (Get-ItemProperty -Path $LLMNRKey -Name \"EnableMulticast\" -ErrorAction SilentlyContinue).EnableMulticast\n    $Result.LLMNREnabled = if ($null -eq $EnableMulticast) { \"NotConfigured (default: enabled)\" } else { $EnableMulticast }\n\n    # LLMNR should be disabled (EnableMulticast = 0)\n    if ($EnableMulticast -ne 0) {\n        $Result.Drifted = $true\n        $Result.Issues += \"LLMNR is not disabled (EnableMulticast should be 0)\"\n    }\n\n    # Check mDNS status\n    $mDNSKey = \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\Dnscache\\Parameters\"\n    $EnableMDNS = (Get-ItemProperty -Path $mDNSKey -Name \"EnableMDNS\" -ErrorAction SilentlyContinue).EnableMDNS\n    $Result.mDNSEnabled = if ($null -eq $EnableMDNS) { \"NotConfigured (default: enabled)\" } else { $EnableMDNS }\n\n    # mDNS should be disabled (EnableMDNS = 0)\n    if ($EnableMDNS -ne 0) {\n        $Result.Drifted = $true\n        $Result.Issues += \"mDNS is not disabled (EnableMDNS should be 0)\"\n    }\n\n    # Check NetBIOS over TCP/IP (related attack surface)\n    $Adapters = Get-WmiObject Win32_NetworkAdapterConfiguration | Where-Object { $_.IPEnabled -eq $true }\n    $NetBIOSIssues = @()\n    foreach ($Adapter in $Adapters) {\n        # TcpipNetbiosOptions: 0=Default, 1=Enabled, 2=Disabled\n        if ($Adapter.TcpipNetbiosOptions -ne 2) {\n            $NetBIOSIssues += \"$($Adapter.Description): NetBIOS not disabled\"\n        }\n    }\n    $Result.NetBIOSIssues = $NetBIOSIssues\n\n    # Check if WPAD is disabled\n    $WPADKey = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Wpad\"\n    $WpadOverride = (Get-ItemProperty -Path $WPADKey -Name \"WpadOverride\" -ErrorAction SilentlyContinue).WpadOverride\n    $Result.WPADDisabled = ($WpadOverride -eq 1)\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Drifted = $true\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "remediate_script": "# Disable LLMNR and mDNS\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # Disable LLMNR via registry\n    $LLMNRKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\DNSClient\"\n    if (-not (Test-Path $LLMNRKey)) {\n        New-Item -Path $LLMNRKey -Force | Out-Null\n    }\n    Set-ItemProperty -Path $LLMNRKey -Name \"EnableMulticast\" -Value 0 -Type DWord\n    $Result.Actions += \"Disabled LLMNR (EnableMulticast = 0)\"\n\n    # Disable mDNS\n    $mDNSKey = \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\Dnscache\\Parameters\"\n    if (-not (Test-Path $mDNSKey)) {\n        New-Item -Path $mDNSKey -Force | Out-Null\n    }\n    Set-ItemProperty -Path $mDNSKey -Name \"EnableMDNS\" -Value 0 -Type DWord\n    $Result.Actions += \"Disabled mDNS (EnableMDNS = 0)\"\n\n    # Disable WPAD auto-discovery\n    $WPADKey = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Wpad\"\n    if (-not (Test-Path $WPADKey)) {\n        New-Item -Path $WPADKey -Force | Out-Null\n    }\n    Set-ItemProperty -Path $WPADKey -Name \"WpadOverride\" -Value 1 -Type DWord\n    $Result.Actions += \"Disabled WPAD auto-discovery\"\n\n    # Restart DNS Client service to apply changes\n    Restart-Service -Name \"Dnscache\" -Force -ErrorAction SilentlyContinue\n    $Result.Actions += \"Restarted DNS Client service\"\n\n    $Result.Success = $true\n    $Result.Message = \"LLMNR and mDNS disabled to prevent name resolution attacks\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "# Verify LLMNR and mDNS are disabled\ntry {\n    $LLMNRKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\DNSClient\"\n    $EnableMulticast = (Get-ItemProperty -Path $LLMNRKey -Name \"EnableMulticast\" -ErrorAction SilentlyContinue).EnableMulticast\n    $LLMNRDisabled = ($EnableMulticast -eq 0)\n\n    $mDNSKey = \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\Dnscache\\Parameters\"\n    $EnableMDNS = (Get-ItemProperty -Path $mDNSKey -Name \"EnableMDNS\" -ErrorAction SilentlyContinue).EnableMDNS\n    $mDNSDisabled = ($EnableMDNS -eq 0)\n\n    @{\n        LLMNRDisabled = $LLMNRDisabled\n        mDNSDisabled = $mDNSDisabled\n        Verified = ($LLMNRDisabled -and $mDNSDisabled)\n    } | ConvertTo-Json\n} catch {\n    @{ Verified = $false; Error = $_.Exception.Message } | ConvertTo-Json\n}",
    "hipaa_controls": [
      "164.312(e)(1)"
    ],
    "severity": "medium",
    "timeout_seconds": 60
  },
  "RB-WIN-NET-004": {
    "id": "RB-WIN-NET-004",
    "name": "WINS/NetBIOS Configuration",
    "platform": "windows",
    "detect_script": "# Check NetBIOS configuration\n$Result = @{\n    Drifted = $false\n    Adapters = @()\n}\n\n$Adapters = Get-NetAdapter | Where-Object { $_.Status -eq \"Up\" }\n\nforeach ($Adapter in $Adapters) {\n    $NetbiosOption = (Get-WmiObject Win32_NetworkAdapterConfiguration |\n        Where-Object { $_.InterfaceIndex -eq $Adapter.ifIndex }).TcpipNetbiosOptions\n\n    $OptionName = switch ($NetbiosOption) {\n        0 { \"Default\" }\n        1 { \"Enabled\" }\n        2 { \"Disabled\" }\n        default { \"Unknown\" }\n    }\n\n    $AdapterInfo = @{\n        Name = $Adapter.Name\n        NetBIOSOption = $OptionName\n        NetBIOSCode = $NetbiosOption\n    }\n\n    # Get WINS servers\n    $Config = Get-WmiObject Win32_NetworkAdapterConfiguration |\n        Where-Object { $_.InterfaceIndex -eq $Adapter.ifIndex }\n    $AdapterInfo.WINSPrimary = $Config.WINSPrimaryServer\n    $AdapterInfo.WINSSecondary = $Config.WINSSecondaryServer\n\n    $Result.Adapters += $AdapterInfo\n}\n\n# On domain networks, NetBIOS should typically be Default (DHCP-controlled)\n$IsDomainJoined = (Get-WmiObject Win32_ComputerSystem).PartOfDomain\n$Result.IsDomainJoined = $IsDomainJoined\n\n# Note: This is informational - not all environments need WINS\n$Result.Drifted = $false\n\n$Result | ConvertTo-Json -Depth 2",
    "remediate_script": "# Configure NetBIOS settings\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    $IsDomainJoined = (Get-WmiObject Win32_ComputerSystem).PartOfDomain\n\n    $Adapters = Get-WmiObject Win32_NetworkAdapterConfiguration |\n        Where-Object { $_.IPEnabled -eq $true }\n\n    foreach ($Adapter in $Adapters) {\n        if ($IsDomainJoined) {\n            # Set to Default (use DHCP setting)\n            $Adapter.SetTcpipNetbios(0) | Out-Null\n            $Result.Actions += \"Set NetBIOS to Default on $($Adapter.Description)\"\n        } else {\n            # Standalone - disable NetBIOS for security\n            $Adapter.SetTcpipNetbios(2) | Out-Null\n            $Result.Actions += \"Disabled NetBIOS on $($Adapter.Description)\"\n        }\n    }\n\n    $Result.Success = $true\n    $Result.Message = \"NetBIOS configuration updated\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "$Adapters = Get-WmiObject Win32_NetworkAdapterConfiguration | Where-Object { $_.IPEnabled -eq $true }\n$Settings = $Adapters | Select-Object Description, TcpipNetbiosOptions\n@{\n    AdapterCount = @($Settings).Count\n    Settings = $Settings\n    Verified = $true  # Informational runbook\n} | ConvertTo-Json -Depth 2",
    "hipaa_controls": [
      "164.312(b)"
    ],
    "severity": "low",
    "timeout_seconds": 60
  },
  "RB-WIN-NET-003": {
    "id": "RB-WIN-NET-003",
    "name": "Network Profile Remediation",
    "platform": "windows",
    "detect_script": "# Check network profile settings\n$Result = @{\n    Drifted = $false\n    Profiles = @()\n}\n\n$Profiles = Get-NetConnectionProfile\n\nforeach ($Profile in $Profiles) {\n    $ProfileInfo = @{\n        Name = $Profile.Name\n        InterfaceAlias = $Profile.InterfaceAlias\n        NetworkCategory = $Profile.NetworkCategory.ToString()\n        IPv4Connectivity = $Profile.IPv4Connectivity.ToString()\n    }\n    $Result.Profiles += $ProfileInfo\n\n    # Domain-joined machines should have Domain profile\n    $IsDomainJoined = (Get-WmiObject Win32_ComputerSystem).PartOfDomain\n\n    if ($IsDomainJoined -and $Profile.NetworkCategory -eq \"Public\") {\n        $Result.Drifted = $true\n        $Result.DriftReason = \"Domain machine on Public network profile\"\n    }\n\n    # Servers should not be on Public profile\n    $IsServer = (Get-WmiObject Win32_OperatingSystem).ProductType -eq 3\n    if ($IsServer -and $Profile.NetworkCategory -eq \"Public\") {\n        $Result.Drifted = $true\n        $Result.DriftReason = \"Server on Public network profile\"\n    }\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "remediate_script": "# Set appropriate network profile\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    $IsDomainJoined = (Get-WmiObject Win32_ComputerSystem).PartOfDomain\n    $Profiles = Get-NetConnectionProfile\n\n    foreach ($Profile in $Profiles) {\n        if ($Profile.NetworkCategory -eq \"Public\") {\n            if ($IsDomainJoined) {\n                # Can't set to Domain directly, set to Private\n                Set-NetConnectionProfile -InterfaceIndex $Profile.InterfaceIndex -NetworkCategory Private\n                $Result.Actions += \"Changed $($Profile.InterfaceAlias) from Public to Private\"\n            } else {\n                Set-NetConnectionProfile -InterfaceIndex $Profile.InterfaceIndex -NetworkCategory Private\n                $Result.Actions += \"Changed $($Profile.InterfaceAlias) from Public to Private\"\n            }\n        }\n    }\n\n    $Result.Success = $true\n    $Result.Message = \"Network profiles updated\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "$Profiles = Get-NetConnectionProfile\n$PublicCount = ($Profiles | Where-Object { $_.NetworkCategory -eq \"Public\" }).Count\n@{\n    PublicProfileCount = $PublicCount\n    Verified = ($PublicCount -eq 0)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(e)(1)"
    ],
    "severity": "medium",
    "timeout_seconds": 60
  },
  "RB-NET-SECURITY-001": {
    "id": "RB-NET-SECURITY-001",
    "name": "Network Security Posture Verification",
    "platform": "windows",
    "detect_script": "# Comprehensive network security posture check\n$Result = @{\n    Drifted = $false\n    Issues = @()\n    FirewallProfiles = @()\n    NetworkConnections = @()\n    TLSSettings = @{}\n    ListeningPorts = @()\n}\n\n# Check firewall on all profiles\n$Profiles = Get-NetFirewallProfile\nforeach ($Profile in $Profiles) {\n    $ProfileInfo = @{\n        Name = $Profile.Name\n        Enabled = $Profile.Enabled\n        DefaultInbound = $Profile.DefaultInboundAction.ToString()\n        DefaultOutbound = $Profile.DefaultOutboundAction.ToString()\n        LogAllowed = $Profile.LogAllowed\n        LogBlocked = $Profile.LogBlocked\n    }\n    $Result.FirewallProfiles += $ProfileInfo\n\n    if (-not $Profile.Enabled) {\n        $Result.Drifted = $true\n        $Result.Issues += \"Firewall disabled on $($Profile.Name) profile\"\n    }\n\n    # Check for permissive inbound default\n    if ($Profile.DefaultInboundAction -eq \"Allow\") {\n        $Result.Issues += \"Warning: Default inbound action is ALLOW on $($Profile.Name)\"\n    }\n}\n\n# Check TLS settings\n$TLSPath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\"\n$TLSVersions = @(\"SSL 2.0\", \"SSL 3.0\", \"TLS 1.0\", \"TLS 1.1\", \"TLS 1.2\", \"TLS 1.3\")\n$WeakProtocols = @(\"SSL 2.0\", \"SSL 3.0\", \"TLS 1.0\", \"TLS 1.1\")\n\nforeach ($Version in $TLSVersions) {\n    $ServerPath = \"$TLSPath\\$Version\\Server\"\n    $Enabled = (Get-ItemProperty -Path $ServerPath -Name \"Enabled\" -ErrorAction SilentlyContinue).Enabled\n    $Result.TLSSettings[$Version] = @{\n        Enabled = if ($null -eq $Enabled) { \"Default\" } else { $Enabled }\n    }\n\n    # Weak protocols should be disabled\n    if ($Version -in $WeakProtocols -and $Enabled -ne 0) {\n        $Result.Drifted = $true\n        $Result.Issues += \"$Version should be disabled\"\n    }\n}\n\n# Check for suspicious listening ports\n$Listeners = Get-NetTCPConnection -State Listen -ErrorAction SilentlyContinue |\n    Select-Object LocalPort, OwningProcess\n$SuspiciousPorts = @(21, 23, 69, 137, 138, 139, 445, 3389)  # FTP, Telnet, TFTP, NetBIOS, SMB, RDP\n\nforeach ($Listener in $Listeners) {\n    $Process = Get-Process -Id $Listener.OwningProcess -ErrorAction SilentlyContinue\n    $PortInfo = @{\n        Port = $Listener.LocalPort\n        ProcessName = $Process.ProcessName\n        ProcessId = $Listener.OwningProcess\n    }\n    $Result.ListeningPorts += $PortInfo\n\n    if ($Listener.LocalPort -in $SuspiciousPorts) {\n        $Result.Issues += \"Warning: Port $($Listener.LocalPort) is listening ($($Process.ProcessName))\"\n    }\n}\n\n# Check SMB encryption\ntry {\n    $SMBConfig = Get-SmbServerConfiguration\n    $Result.SMBEncryption = @{\n        EncryptData = $SMBConfig.EncryptData\n        RejectUnencryptedAccess = $SMBConfig.RejectUnencryptedAccess\n    }\n    if (-not $SMBConfig.EncryptData) {\n        $Result.Issues += \"SMB encryption not enabled\"\n    }\n} catch {\n    $Result.SMBEncryption = @{ Error = $_.Exception.Message }\n}\n\n# Check IPsec policies\n$IPsecRules = Get-NetIPsecRule -ErrorAction SilentlyContinue\n$Result.IPsecRuleCount = @($IPsecRules).Count\n\n$Result.IssueCount = $Result.Issues.Count\n$Result | ConvertTo-Json -Depth 4",
    "remediate_script": "# Remediate network security issues\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # Enable firewall on all profiles\n    $Profiles = Get-NetFirewallProfile\n    foreach ($Profile in $Profiles) {\n        if (-not $Profile.Enabled) {\n            Set-NetFirewallProfile -Name $Profile.Name -Enabled True\n            $Result.Actions += \"Enabled firewall on $($Profile.Name)\"\n        }\n    }\n\n    # Set default inbound to Block\n    Set-NetFirewallProfile -All -DefaultInboundAction Block -DefaultOutboundAction Allow\n    $Result.Actions += \"Set default inbound action to Block\"\n\n    # Enable firewall logging\n    Set-NetFirewallProfile -All -LogBlocked True -LogAllowed False\n    $Result.Actions += \"Enabled blocked connection logging\"\n\n    # Disable weak TLS/SSL protocols\n    $TLSPath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\"\n    $WeakProtocols = @(\"SSL 2.0\", \"SSL 3.0\", \"TLS 1.0\", \"TLS 1.1\")\n\n    foreach ($Protocol in $WeakProtocols) {\n        $ServerPath = \"$TLSPath\\$Protocol\\Server\"\n        $ClientPath = \"$TLSPath\\$Protocol\\Client\"\n\n        foreach ($Path in @($ServerPath, $ClientPath)) {\n            if (-not (Test-Path $Path)) {\n                New-Item -Path $Path -Force | Out-Null\n            }\n            Set-ItemProperty -Path $Path -Name \"Enabled\" -Value 0 -Type DWord\n            Set-ItemProperty -Path $Path -Name \"DisabledByDefault\" -Value 1 -Type DWord\n        }\n        $Result.Actions += \"Disabled $Protocol\"\n    }\n\n    # Enable TLS 1.2 and 1.3\n    foreach ($Protocol in @(\"TLS 1.2\", \"TLS 1.3\")) {\n        $ServerPath = \"$TLSPath\\$Protocol\\Server\"\n        $ClientPath = \"$TLSPath\\$Protocol\\Client\"\n\n        foreach ($Path in @($ServerPath, $ClientPath)) {\n            if (-not (Test-Path $Path)) {\n                New-Item -Path $Path -Force | Out-Null\n            }\n            Set-ItemProperty -Path $Path -Name \"Enabled\" -Value 1 -Type DWord\n            Set-ItemProperty -Path $Path -Name \"DisabledByDefault\" -Value 0 -Type DWord\n        }\n        $Result.Actions += \"Enabled $Protocol\"\n    }\n\n    # Enable SMB encryption\n    try {\n        Set-SmbServerConfiguration -EncryptData $true -Force\n        $Result.Actions += \"Enabled SMB encryption\"\n    } catch {\n        $Result.Actions += \"SMB encryption: $($_.Exception.Message)\"\n    }\n\n    $Result.Success = $true\n    $Result.Message = \"Network security hardened\"\n    $Result.Warning = \"Some changes require reboot to take full effect\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "verify_script": "$FirewallOk = (Get-NetFirewallProfile | Where-Object { -not $_.Enabled }).Count -eq 0\n\n# Check TLS 1.0 is disabled\n$TLS10Path = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.0\\Server\"\n$TLS10Enabled = (Get-ItemProperty -Path $TLS10Path -Name \"Enabled\" -ErrorAction SilentlyContinue).Enabled\n$TLSOk = ($TLS10Enabled -eq 0)\n\n@{\n    FirewallEnabled = $FirewallOk\n    WeakTLSDisabled = $TLSOk\n    Verified = ($FirewallOk -and $TLSOk)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(e)(1)",
      "164.312(e)(2)(ii)"
    ],
    "severity": "high",
    "timeout_seconds": 180
  },
  "RB-WIN-NET-002": {
    "id": "RB-WIN-NET-002",
    "name": "NIC Reset and Recovery",
    "platform": "windows",
    "detect_script": "# Check network adapter health\n$Result = @{\n    Drifted = $false\n    Adapters = @()\n}\n\n$Adapters = Get-NetAdapter\n\nforeach ($Adapter in $Adapters) {\n    $AdapterInfo = @{\n        Name = $Adapter.Name\n        Status = $Adapter.Status.ToString()\n        LinkSpeed = $Adapter.LinkSpeed\n        MediaConnectionState = $Adapter.MediaConnectionState.ToString()\n        DriverVersion = $Adapter.DriverVersion\n    }\n\n    # Get statistics\n    $Stats = Get-NetAdapterStatistics -Name $Adapter.Name -ErrorAction SilentlyContinue\n    if ($Stats) {\n        $AdapterInfo.ReceivedBytes = $Stats.ReceivedBytes\n        $AdapterInfo.SentBytes = $Stats.SentBytes\n        $AdapterInfo.InboundErrors = $Stats.ReceivedPacketsWithErrors\n        $AdapterInfo.OutboundErrors = $Stats.OutboundPacketErrors\n\n        # High error rate indicates problems\n        if ($Stats.ReceivedPacketsWithErrors -gt 1000 -or $Stats.OutboundPacketErrors -gt 1000) {\n            $AdapterInfo.HighErrorRate = $true\n        }\n    }\n\n    $Result.Adapters += $AdapterInfo\n\n    # Drift if adapter is down but should be up\n    if ($Adapter.Status -eq \"Disabled\" -and $Adapter.AdminStatus -eq \"Up\") {\n        $Result.Drifted = $true\n        $Result.DriftReason = \"Adapter disabled unexpectedly\"\n    }\n}\n\n# Check overall connectivity\n$Gateway = (Get-NetRoute -DestinationPrefix \"0.0.0.0/0\" -ErrorAction SilentlyContinue).NextHop | Select-Object -First 1\nif ($Gateway) {\n    $PingResult = Test-Connection -ComputerName $Gateway -Count 2 -Quiet -ErrorAction SilentlyContinue\n    $Result.GatewayReachable = $PingResult\n    if (-not $PingResult) {\n        $Result.Drifted = $true\n        $Result.DriftReason = \"Cannot reach gateway\"\n    }\n}\n\n$Result | ConvertTo-Json -Depth 3",
    "remediate_script": "# Reset network adapter\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # Get primary network adapter\n    $Adapter = Get-NetAdapter | Where-Object { $_.Status -eq \"Up\" } | Select-Object -First 1\n\n    if (-not $Adapter) {\n        # Try to enable disabled adapters\n        $DisabledAdapter = Get-NetAdapter | Where-Object { $_.Status -eq \"Disabled\" } | Select-Object -First 1\n        if ($DisabledAdapter) {\n            Enable-NetAdapter -Name $DisabledAdapter.Name -Confirm:$false\n            $Result.Actions += \"Enabled adapter: $($DisabledAdapter.Name)\"\n            Start-Sleep -Seconds 5\n        }\n    } else {\n        # Disable and re-enable to reset\n        $AdapterName = $Adapter.Name\n        Disable-NetAdapter -Name $AdapterName -Confirm:$false\n        Start-Sleep -Seconds 3\n        Enable-NetAdapter -Name $AdapterName -Confirm:$false\n        $Result.Actions += \"Reset adapter: $AdapterName\"\n        Start-Sleep -Seconds 5\n    }\n\n    # Release and renew DHCP if applicable\n    $IPConfig = Get-NetIPConfiguration | Where-Object { $_.NetIPv4Interface.Dhcp -eq \"Enabled\" }\n    if ($IPConfig) {\n        ipconfig /release | Out-Null\n        Start-Sleep -Seconds 2\n        ipconfig /renew | Out-Null\n        $Result.Actions += \"Renewed DHCP lease\"\n    }\n\n    # Verify connectivity\n    Start-Sleep -Seconds 3\n    $Gateway = (Get-NetRoute -DestinationPrefix \"0.0.0.0/0\" -ErrorAction SilentlyContinue).NextHop | Select-Object -First 1\n    if ($Gateway) {\n        $Result.GatewayReachable = Test-Connection -ComputerName $Gateway -Count 2 -Quiet\n    }\n\n    $Result.Success = $true\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "$Adapter = Get-NetAdapter | Where-Object { $_.Status -eq \"Up\" } | Select-Object -First 1\n$Gateway = (Get-NetRoute -DestinationPrefix \"0.0.0.0/0\" -ErrorAction SilentlyContinue).NextHop | Select-Object -First 1\n$GatewayOk = if ($Gateway) { Test-Connection -ComputerName $Gateway -Count 2 -Quiet } else { $false }\n@{\n    AdapterUp = ($null -ne $Adapter)\n    GatewayReachable = $GatewayOk\n    Verified = ($null -ne $Adapter -and $GatewayOk)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(a)(1)"
    ],
    "severity": "high",
    "timeout_seconds": 180
  },
  "RB-WIN-STG-001": {
    "id": "RB-WIN-STG-001",
    "name": "Disk Space Cleanup",
    "platform": "windows",
    "detect_script": "# Check disk space\n$Result = @{\n    Drifted = $false\n    Volumes = @()\n}\n\n$Volumes = Get-WmiObject Win32_LogicalDisk -Filter \"DriveType=3\"\n\nforeach ($Vol in $Volumes) {\n    $FreeGB = [math]::Round($Vol.FreeSpace / 1GB, 2)\n    $TotalGB = [math]::Round($Vol.Size / 1GB, 2)\n    $UsedPercent = [math]::Round((($Vol.Size - $Vol.FreeSpace) / $Vol.Size) * 100, 1)\n\n    $VolInfo = @{\n        DriveLetter = $Vol.DeviceID\n        TotalGB = $TotalGB\n        FreeGB = $FreeGB\n        UsedPercent = $UsedPercent\n    }\n    $Result.Volumes += $VolInfo\n\n    # Alert if less than 10% or less than 10GB free\n    if ($UsedPercent -gt 90 -or $FreeGB -lt 10) {\n        $Result.Drifted = $true\n        $VolInfo.LowSpace = $true\n    }\n}\n\n# Check specific cleanup targets\n$TempSize = (Get-ChildItem $env:TEMP -Recurse -ErrorAction SilentlyContinue |\n    Measure-Object -Property Length -Sum).Sum / 1GB\n$WindowsTempSize = (Get-ChildItem \"C:\\Windows\\Temp\" -Recurse -ErrorAction SilentlyContinue |\n    Measure-Object -Property Length -Sum).Sum / 1GB\n$SoftwareDistSize = (Get-ChildItem \"C:\\Windows\\SoftwareDistribution\\Download\" -Recurse -ErrorAction SilentlyContinue |\n    Measure-Object -Property Length -Sum).Sum / 1GB\n\n$Result.CleanupTargets = @{\n    UserTempGB = [math]::Round($TempSize, 2)\n    WindowsTempGB = [math]::Round($WindowsTempSize, 2)\n    SoftwareDistGB = [math]::Round($SoftwareDistSize, 2)\n    TotalRecoverableGB = [math]::Round($TempSize + $WindowsTempSize + $SoftwareDistSize, 2)\n}\n\n$Result | ConvertTo-Json -Depth 3",
    "remediate_script": "# Clean up disk space\n$Result = @{ Success = $false; SpaceRecoveredMB = 0; Actions = @() }\n\ntry {\n    $InitialFree = (Get-WmiObject Win32_LogicalDisk -Filter \"DeviceID='C:'\").FreeSpace\n\n    # Clean user temp\n    Remove-Item \"$env:TEMP\\*\" -Recurse -Force -ErrorAction SilentlyContinue\n    $Result.Actions += \"Cleaned user temp folder\"\n\n    # Clean Windows temp\n    Remove-Item \"C:\\Windows\\Temp\\*\" -Recurse -Force -ErrorAction SilentlyContinue\n    $Result.Actions += \"Cleaned Windows temp folder\"\n\n    # Clean Software Distribution (Windows Update cache)\n    Stop-Service -Name wuauserv -Force -ErrorAction SilentlyContinue\n    Remove-Item \"C:\\Windows\\SoftwareDistribution\\Download\\*\" -Recurse -Force -ErrorAction SilentlyContinue\n    Start-Service -Name wuauserv -ErrorAction SilentlyContinue\n    $Result.Actions += \"Cleaned Windows Update cache\"\n\n    # Clean old Windows Error Reports\n    Remove-Item \"C:\\ProgramData\\Microsoft\\Windows\\WER\\ReportArchive\\*\" -Recurse -Force -ErrorAction SilentlyContinue\n    Remove-Item \"C:\\ProgramData\\Microsoft\\Windows\\WER\\ReportQueue\\*\" -Recurse -Force -ErrorAction SilentlyContinue\n    $Result.Actions += \"Cleaned Windows Error Reports\"\n\n    # Clean old log files (older than 30 days)\n    Get-ChildItem \"C:\\Windows\\Logs\" -Recurse -Include \"*.log\" -ErrorAction SilentlyContinue |\n        Where-Object { $_.LastWriteTime -lt (Get-Date).AddDays(-30) } |\n        Remove-Item -Force -ErrorAction SilentlyContinue\n    $Result.Actions += \"Cleaned old log files\"\n\n    # Calculate space recovered\n    $FinalFree = (Get-WmiObject Win32_LogicalDisk -Filter \"DeviceID='C:'\").FreeSpace\n    $Result.SpaceRecoveredMB = [math]::Round(($FinalFree - $InitialFree) / 1MB, 0)\n\n    $Result.Success = $true\n    $Result.Message = \"Disk cleanup completed\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "$Vol = Get-WmiObject Win32_LogicalDisk -Filter \"DeviceID='C:'\"\n$FreeGB = [math]::Round($Vol.FreeSpace / 1GB, 2)\n$UsedPercent = [math]::Round((($Vol.Size - $Vol.FreeSpace) / $Vol.Size) * 100, 1)\n@{\n    FreeSpaceGB = $FreeGB\n    UsedPercent = $UsedPercent\n    Verified = ($UsedPercent -lt 90 -or $FreeGB -gt 5)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(c)(1)"
    ],
    "severity": "high",
    "timeout_seconds": 600
  },
  "RB-WIN-STG-002": {
    "id": "RB-WIN-STG-002",
    "name": "Shadow Copy Recovery",
    "platform": "windows",
    "detect_script": "# Check Volume Shadow Copy status\n$Result = @{\n    Drifted = $false\n}\n\n# Check VSS service\n$VSSService = Get-Service -Name VSS -ErrorAction SilentlyContinue\n$Result.VSSServiceStatus = if ($VSSService) { $VSSService.Status.ToString() } else { \"NotFound\" }\n$Result.VSSStartType = if ($VSSService) { $VSSService.StartType.ToString() } else { \"Unknown\" }\n\n# Check for shadow storage\n$ShadowStorage = vssadmin list shadowstorage 2>&1\n$Result.ShadowStorageConfigured = $ShadowStorage -notmatch \"No shadow copies\"\n\n# List existing shadow copies\n$Shadows = vssadmin list shadows 2>&1\n$ShadowCount = ($Shadows | Select-String \"Shadow Copy ID\").Count\n$Result.ShadowCopyCount = $ShadowCount\n\n# Get shadow copy providers\n$Providers = vssadmin list providers 2>&1\n$Result.ProvidersAvailable = $Providers -match \"Provider\"\n\n# Check if VSS writers are healthy\n$Writers = vssadmin list writers 2>&1\n$FailedWriters = ($Writers | Select-String \"Last error:\" | Where-Object { $_ -notmatch \"No error\" }).Count\n$Result.FailedWriterCount = $FailedWriters\n\n# Drift conditions\nif ($VSSService.Status -ne \"Running\" -and $VSSService.StartType -ne \"Manual\") {\n    $Result.Drifted = $true\n    $Result.DriftReason = \"VSS service not configured correctly\"\n}\n\nif ($FailedWriters -gt 0) {\n    $Result.Drifted = $true\n    $Result.DriftReason = \"VSS writers in failed state\"\n}\n\n$Result | ConvertTo-Json",
    "remediate_script": "# Fix VSS configuration\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # Ensure VSS service is set to Manual (starts on demand)\n    $Service = Get-Service -Name VSS\n    if ($Service.StartType -ne \"Manual\") {\n        Set-Service -Name VSS -StartupType Manual\n        $Result.Actions += \"Set VSS service to Manual start\"\n    }\n\n    # Ensure service can start\n    if ($Service.Status -ne \"Running\") {\n        Start-Service -Name VSS -ErrorAction SilentlyContinue\n        $Result.Actions += \"Started VSS service\"\n    }\n\n    # Configure shadow storage if not configured\n    $Storage = vssadmin list shadowstorage 2>&1\n    if ($Storage -match \"No shadow copies are configured\") {\n        # Add shadow storage for C: drive (10% of disk)\n        vssadmin add shadowstorage /for=C: /on=C: /maxsize=10% 2>&1 | Out-Null\n        $Result.Actions += \"Configured shadow storage for C: drive\"\n    }\n\n    # Create a shadow copy to verify it works\n    $CreateResult = vssadmin create shadow /for=C: 2>&1\n    if ($CreateResult -match \"Successfully created\") {\n        $Result.Actions += \"Created test shadow copy\"\n    }\n\n    $Result.Success = $true\n    $Result.Message = \"VSS configuration verified\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "$Service = Get-Service -Name VSS -ErrorAction SilentlyContinue\n$Writers = vssadmin list writers 2>&1\n$FailedWriters = ($Writers | Select-String \"Last error:\" | Where-Object { $_ -notmatch \"No error\" }).Count\n@{\n    VSSServiceExists = ($null -ne $Service)\n    FailedWriters = $FailedWriters\n    Verified = ($null -ne $Service -and $FailedWriters -eq 0)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.308(a)(7)(ii)(A)"
    ],
    "severity": "medium",
    "timeout_seconds": 180
  },
  "RB-WIN-STG-003": {
    "id": "RB-WIN-STG-003",
    "name": "Volume Health Check",
    "platform": "windows",
    "detect_script": "# Check disk and volume health\n$Result = @{\n    Drifted = $false\n    Disks = @()\n    Volumes = @()\n}\n\n# Check physical disks\n$Disks = Get-PhysicalDisk -ErrorAction SilentlyContinue\n\nforeach ($Disk in $Disks) {\n    $DiskInfo = @{\n        FriendlyName = $Disk.FriendlyName\n        MediaType = $Disk.MediaType.ToString()\n        Size = [math]::Round($Disk.Size / 1GB, 0)\n        HealthStatus = $Disk.HealthStatus.ToString()\n        OperationalStatus = $Disk.OperationalStatus.ToString()\n    }\n\n    # Get SMART data if available\n    $SmartData = Get-StorageReliabilityCounter -PhysicalDisk $Disk -ErrorAction SilentlyContinue\n    if ($SmartData) {\n        $DiskInfo.Temperature = $SmartData.Temperature\n        $DiskInfo.ReadErrors = $SmartData.ReadErrorsTotal\n        $DiskInfo.WriteErrors = $SmartData.WriteErrorsTotal\n        $DiskInfo.PowerOnHours = $SmartData.PowerOnHours\n    }\n\n    $Result.Disks += $DiskInfo\n\n    # Alert on unhealthy status\n    if ($Disk.HealthStatus -ne \"Healthy\" -or $Disk.OperationalStatus -ne \"OK\") {\n        $Result.Drifted = $true\n        $DiskInfo.Alert = $true\n    }\n}\n\n# Check volumes for file system errors\n$Volumes = Get-Volume | Where-Object { $_.DriveType -eq \"Fixed\" }\n\nforeach ($Vol in $Volumes) {\n    $VolInfo = @{\n        DriveLetter = $Vol.DriveLetter\n        FileSystem = $Vol.FileSystemType\n        HealthStatus = $Vol.HealthStatus.ToString()\n        SizeGB = [math]::Round($Vol.Size / 1GB, 0)\n    }\n\n    # Check for dirty bit\n    if ($Vol.DriveLetter) {\n        $Dirty = fsutil dirty query \"$($Vol.DriveLetter):\" 2>&1\n        $VolInfo.IsDirty = $Dirty -match \"dirty\"\n\n        if ($VolInfo.IsDirty) {\n            $Result.Drifted = $true\n        }\n    }\n\n    $Result.Volumes += $VolInfo\n\n    if ($Vol.HealthStatus -ne \"Healthy\") {\n        $Result.Drifted = $true\n        $VolInfo.Alert = $true\n    }\n}\n\n$Result | ConvertTo-Json -Depth 3",
    "remediate_script": "# Volume health remediation (limited - mainly alerting)\n$Result = @{ Success = $false; Actions = @(); Alerts = @() }\n\ntry {\n    # Check for dirty volumes\n    $Volumes = Get-Volume | Where-Object { $_.DriveType -eq \"Fixed\" -and $_.DriveLetter }\n\n    foreach ($Vol in $Volumes) {\n        $Dirty = fsutil dirty query \"$($Vol.DriveLetter):\" 2>&1\n\n        if ($Dirty -match \"dirty\") {\n            $Result.Alerts += \"Volume $($Vol.DriveLetter): is dirty - schedule chkdsk on next reboot\"\n\n            # Schedule chkdsk (non-destructive)\n            # Note: This requires a reboot to run\n            $Result.Actions += \"Run manually: chkdsk $($Vol.DriveLetter): /f\"\n        }\n    }\n\n    # Check for failing disks\n    $Disks = Get-PhysicalDisk | Where-Object { $_.HealthStatus -ne \"Healthy\" }\n    foreach ($Disk in $Disks) {\n        $Result.Alerts += \"CRITICAL: Disk '$($Disk.FriendlyName)' health is $($Disk.HealthStatus) - replace immediately\"\n    }\n\n    $Result.Success = $true\n    $Result.Message = if ($Result.Alerts.Count -gt 0) {\n        \"Issues detected - review alerts\"\n    } else {\n        \"All volumes healthy\"\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "verify_script": "$Disks = Get-PhysicalDisk\n$UnhealthyDisks = ($Disks | Where-Object { $_.HealthStatus -ne \"Healthy\" }).Count\n$Volumes = Get-Volume | Where-Object { $_.DriveType -eq \"Fixed\" }\n$UnhealthyVolumes = ($Volumes | Where-Object { $_.HealthStatus -ne \"Healthy\" }).Count\n@{\n    UnhealthyDisks = $UnhealthyDisks\n    UnhealthyVolumes = $UnhealthyVolumes\n    Verified = ($UnhealthyDisks -eq 0 -and $UnhealthyVolumes -eq 0)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.310(d)(2)(iv)"
    ],
    "severity": "critical",
    "timeout_seconds": 120
  },
  "RB-WIN-UPD-002": {
    "id": "RB-WIN-UPD-002",
    "name": "WSUS Client Registration Fix",
    "platform": "windows",
    "detect_script": "# Check WSUS client configuration\n$Result = @{\n    Drifted = $false\n}\n\n# Check if WSUS is configured\n$WUServer = (Get-ItemProperty -Path \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\" -ErrorAction SilentlyContinue).WUServer\n$WUStatusServer = (Get-ItemProperty -Path \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\" -ErrorAction SilentlyContinue).WUStatusServer\n$UseWUServer = (Get-ItemProperty -Path \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU\" -ErrorAction SilentlyContinue).UseWUServer\n\n$Result.WSUSConfigured = ($null -ne $WUServer)\n$Result.WUServer = $WUServer\n$Result.WUStatusServer = $WUStatusServer\n$Result.UseWUServer = $UseWUServer\n\nif ($WUServer) {\n    # Test WSUS connectivity\n    $WSUSUri = [System.Uri]$WUServer\n    $TestConnection = Test-NetConnection -ComputerName $WSUSUri.Host -Port $WSUSUri.Port -WarningAction SilentlyContinue\n    $Result.WSUSReachable = $TestConnection.TcpTestSucceeded\n\n    if (-not $TestConnection.TcpTestSucceeded) {\n        $Result.Drifted = $true\n        $Result.DriftReason = \"Cannot connect to WSUS server\"\n    }\n\n    # Check SusClientId\n    $SusClientId = (Get-ItemProperty -Path \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\" -ErrorAction SilentlyContinue).SusClientId\n    $Result.SusClientId = $SusClientId\n\n    if (-not $SusClientId) {\n        $Result.Drifted = $true\n        $Result.DriftReason = \"Missing WSUS client ID\"\n    }\n\n    # Check last report time\n    $LastReportTime = (Get-ItemProperty -Path \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\\Results\\Detect\" -ErrorAction SilentlyContinue).LastSuccessTime\n    if ($LastReportTime) {\n        $LastReport = [DateTime]::ParseExact($LastReportTime, \"yyyy-MM-dd HH:mm:ss\", $null)\n        $DaysSinceReport = ((Get-Date) - $LastReport).Days\n        $Result.DaysSinceLastReport = $DaysSinceReport\n\n        if ($DaysSinceReport -gt 7) {\n            $Result.Drifted = $true\n            $Result.DriftReason = \"No WSUS report in over 7 days\"\n        }\n    }\n} else {\n    $Result.Note = \"WSUS not configured - using Windows Update\"\n}\n\n$Result | ConvertTo-Json",
    "remediate_script": "# Re-register with WSUS\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # Check if WSUS is configured\n    $WUServer = (Get-ItemProperty -Path \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\" -ErrorAction SilentlyContinue).WUServer\n\n    if (-not $WUServer) {\n        $Result.Success = $true\n        $Result.Message = \"WSUS not configured - no action needed\"\n        $Result | ConvertTo-Json\n        return\n    }\n\n    # Stop Windows Update service\n    Stop-Service -Name wuauserv -Force -ErrorAction SilentlyContinue\n    $Result.Actions += \"Stopped Windows Update service\"\n\n    # Clear WSUS registration\n    $WUPath = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\"\n    Remove-ItemProperty -Path $WUPath -Name \"AccountDomainSid\" -ErrorAction SilentlyContinue\n    Remove-ItemProperty -Path $WUPath -Name \"PingID\" -ErrorAction SilentlyContinue\n    Remove-ItemProperty -Path $WUPath -Name \"SusClientId\" -ErrorAction SilentlyContinue\n    Remove-ItemProperty -Path $WUPath -Name \"SusClientIdValidation\" -ErrorAction SilentlyContinue\n    $Result.Actions += \"Cleared WSUS client registration\"\n\n    # Start Windows Update service\n    Start-Service -Name wuauserv\n    $Result.Actions += \"Started Windows Update service\"\n    Start-Sleep -Seconds 3\n\n    # Force re-registration\n    wuauclt /resetauthorization /detectnow 2>&1 | Out-Null\n    $Result.Actions += \"Triggered WSUS re-registration\"\n\n    # Also use the newer command\n    Start-Process -FilePath \"usoclient.exe\" -ArgumentList \"StartScan\" -NoNewWindow -Wait -ErrorAction SilentlyContinue\n    $Result.Actions += \"Triggered update scan\"\n\n    # Report to WSUS\n    wuauclt /reportnow 2>&1 | Out-Null\n    $Result.Actions += \"Reported to WSUS\"\n\n    $Result.Success = $true\n    $Result.Message = \"WSUS client re-registered successfully\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json",
    "verify_script": "$WUServer = (Get-ItemProperty -Path \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\" -ErrorAction SilentlyContinue).WUServer\n$SusClientId = (Get-ItemProperty -Path \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\" -ErrorAction SilentlyContinue).SusClientId\n\nif (-not $WUServer) {\n    @{ Verified = $true; Note = \"WSUS not configured\" } | ConvertTo-Json\n} else {\n    @{\n        WSUSConfigured = $true\n        HasClientId = ($null -ne $SusClientId)\n        Verified = ($null -ne $SusClientId)\n    } | ConvertTo-Json\n}",
    "hipaa_controls": [
      "164.308(a)(5)(ii)(B)"
    ],
    "severity": "medium",
    "timeout_seconds": 180
  },
  "RB-WIN-UPD-001": {
    "id": "RB-WIN-UPD-001",
    "name": "Windows Update Service Reset",
    "platform": "windows",
    "detect_script": "# Check Windows Update service health\n$Result = @{\n    Drifted = $false\n}\n\n# Check Windows Update service\n$WUService = Get-Service -Name wuauserv -ErrorAction SilentlyContinue\n$Result.WUServiceStatus = if ($WUService) { $WUService.Status.ToString() } else { \"NotFound\" }\n$Result.WUServiceStartType = if ($WUService) { $WUService.StartType.ToString() } else { \"Unknown\" }\n\n# Check BITS service\n$BITSService = Get-Service -Name BITS -ErrorAction SilentlyContinue\n$Result.BITSServiceStatus = if ($BITSService) { $BITSService.Status.ToString() } else { \"NotFound\" }\n\n# Check Cryptographic Services\n$CryptService = Get-Service -Name CryptSvc -ErrorAction SilentlyContinue\n$Result.CryptServiceStatus = if ($CryptService) { $CryptService.Status.ToString() } else { \"NotFound\" }\n\n# Check Windows Update log for errors\n$WULog = Get-WindowsUpdateLog -ErrorAction SilentlyContinue\n$RecentErrors = Get-WinEvent -LogName \"Microsoft-Windows-WindowsUpdateClient/Operational\" -MaxEvents 50 -ErrorAction SilentlyContinue |\n    Where-Object { $_.LevelDisplayName -eq \"Error\" -and $_.TimeCreated -gt (Get-Date).AddDays(-7) }\n$Result.RecentErrorCount = @($RecentErrors).Count\n\n# Check SoftwareDistribution folder size (large = potential issue)\n$SDSize = (Get-ChildItem \"C:\\Windows\\SoftwareDistribution\" -Recurse -ErrorAction SilentlyContinue |\n    Measure-Object -Property Length -Sum).Sum / 1GB\n$Result.SoftwareDistributionSizeGB = [math]::Round($SDSize, 2)\n\n# Check last update check time\n$AutoUpdate = (New-Object -ComObject Microsoft.Update.AutoUpdate)\n$Result.LastSearchSuccess = $AutoUpdate.Results.LastSearchSuccessDate\n$Result.LastInstallSuccess = $AutoUpdate.Results.LastInstallationSuccessDate\n\n# Drift conditions\nif ($WUService.Status -eq \"Stopped\" -and $WUService.StartType -ne \"Disabled\") {\n    $Result.Drifted = $true\n    $Result.DriftReason = \"Windows Update service stopped unexpectedly\"\n}\n\nif ($Result.RecentErrorCount -gt 5) {\n    $Result.Drifted = $true\n    $Result.DriftReason = \"Multiple recent Windows Update errors\"\n}\n\nif ($SDSize -gt 5) {\n    $Result.Drifted = $true\n    $Result.DriftReason = \"Large SoftwareDistribution folder may indicate stuck updates\"\n}\n\n$Result | ConvertTo-Json",
    "remediate_script": "# Reset Windows Update components\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # Stop services\n    $Services = @(\"wuauserv\", \"BITS\", \"CryptSvc\", \"msiserver\")\n    foreach ($Svc in $Services) {\n        Stop-Service -Name $Svc -Force -ErrorAction SilentlyContinue\n    }\n    $Result.Actions += \"Stopped Windows Update services\"\n    Start-Sleep -Seconds 3\n\n    # Rename SoftwareDistribution folder\n    if (Test-Path \"C:\\Windows\\SoftwareDistribution\") {\n        $BackupName = \"SoftwareDistribution.old_$(Get-Date -Format 'yyyyMMdd_HHmmss')\"\n        Rename-Item \"C:\\Windows\\SoftwareDistribution\" $BackupName -ErrorAction Stop\n        $Result.Actions += \"Renamed SoftwareDistribution folder\"\n    }\n\n    # Rename catroot2 folder\n    if (Test-Path \"C:\\Windows\\System32\\catroot2\") {\n        $BackupName = \"catroot2.old_$(Get-Date -Format 'yyyyMMdd_HHmmss')\"\n        Rename-Item \"C:\\Windows\\System32\\catroot2\" $BackupName -ErrorAction SilentlyContinue\n        $Result.Actions += \"Renamed catroot2 folder\"\n    }\n\n    # Re-register BITS and Windows Update DLLs\n    $DLLs = @(\n        \"atl.dll\", \"urlmon.dll\", \"mshtml.dll\", \"shdocvw.dll\",\n        \"browseui.dll\", \"jscript.dll\", \"vbscript.dll\", \"scrrun.dll\",\n        \"msxml.dll\", \"msxml3.dll\", \"msxml6.dll\", \"actxprxy.dll\",\n        \"softpub.dll\", \"wintrust.dll\", \"dssenh.dll\", \"rsaenh.dll\",\n        \"gpkcsp.dll\", \"sccbase.dll\", \"slbcsp.dll\", \"cryptdlg.dll\",\n        \"oleaut32.dll\", \"ole32.dll\", \"shell32.dll\", \"wuaueng.dll\",\n        \"wuapi.dll\", \"wups.dll\", \"wups2.dll\", \"wuwebv.dll\", \"qmgr.dll\"\n    )\n\n    foreach ($DLL in $DLLs) {\n        regsvr32 /s $DLL 2>&1 | Out-Null\n    }\n    $Result.Actions += \"Re-registered Windows Update DLLs\"\n\n    # Reset Winsock\n    netsh winsock reset 2>&1 | Out-Null\n    $Result.Actions += \"Reset Winsock\"\n\n    # Reset WinHTTP proxy\n    netsh winhttp reset proxy 2>&1 | Out-Null\n    $Result.Actions += \"Reset WinHTTP proxy\"\n\n    # Start services\n    foreach ($Svc in @(\"BITS\", \"CryptSvc\", \"wuauserv\", \"msiserver\")) {\n        Start-Service -Name $Svc -ErrorAction SilentlyContinue\n    }\n    $Result.Actions += \"Started Windows Update services\"\n\n    # Force detection\n    $AutoUpdate = (New-Object -ComObject Microsoft.Update.AutoUpdate)\n    $AutoUpdate.DetectNow()\n    $Result.Actions += \"Triggered update detection\"\n\n    $Result.Success = $true\n    $Result.Message = \"Windows Update components reset successfully\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "verify_script": "$WUService = Get-Service -Name wuauserv\n$BITSService = Get-Service -Name BITS\n@{\n    WUServiceRunning = ($WUService.Status -eq \"Running\")\n    BITSServiceRunning = ($BITSService.Status -eq \"Running\")\n    Verified = ($WUService.Status -eq \"Running\" -or $WUService.StartType -eq \"Manual\")\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.308(a)(5)(ii)(B)"
    ],
    "severity": "high",
    "timeout_seconds": 300
  },
  "RB-WIN-AD-002": {
    "id": "RB-WIN-AD-002",
    "name": "Computer Account Password Reset",
    "platform": "windows",
    "detect_script": "# Check domain trust relationship\n$Result = @{\n    Drifted = $false\n}\n\n# Check if machine is domain-joined\n$ComputerSystem = Get-WmiObject Win32_ComputerSystem\n$Result.IsDomainJoined = $ComputerSystem.PartOfDomain\n$Result.Domain = $ComputerSystem.Domain\n$Result.ComputerName = $ComputerSystem.Name\n\nif (-not $ComputerSystem.PartOfDomain) {\n    $Result.Note = \"Machine is not domain-joined\"\n    $Result | ConvertTo-Json\n    return\n}\n\n# Test secure channel\ntry {\n    $SecureChannel = Test-ComputerSecureChannel -ErrorAction Stop\n    $Result.SecureChannelValid = $SecureChannel\n\n    if (-not $SecureChannel) {\n        $Result.Drifted = $true\n        $Result.DriftReason = \"Secure channel to domain is broken\"\n    }\n} catch {\n    $Result.SecureChannelValid = $false\n    $Result.Drifted = $true\n    $Result.DriftReason = $_.Exception.Message\n}\n\n# Check machine account password age\ntry {\n    $MachineAccount = Get-ADComputer $env:COMPUTERNAME -Properties PasswordLastSet -ErrorAction Stop\n    $PasswordAge = (Get-Date) - $MachineAccount.PasswordLastSet\n    $Result.PasswordAgeDays = [math]::Round($PasswordAge.TotalDays, 0)\n    $Result.PasswordLastSet = $MachineAccount.PasswordLastSet.ToString(\"o\")\n\n    # Machine account passwords should auto-rotate every 30 days\n    if ($PasswordAge.TotalDays -gt 45) {\n        $Result.Drifted = $true\n        $Result.DriftReason = \"Machine account password is stale\"\n    }\n} catch {\n    # May fail if secure channel is broken\n    $Result.ADQueryFailed = $true\n}\n\n# Check domain controller connectivity\ntry {\n    $DC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().DomainControllers[0]\n    $Result.DomainController = $DC.Name\n    $DCPing = Test-Connection -ComputerName $DC.Name -Count 2 -Quiet\n    $Result.DCReachable = $DCPing\n} catch {\n    $Result.DCReachable = $false\n}\n\n$Result | ConvertTo-Json",
    "remediate_script": "# Reset computer account password\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    $ComputerSystem = Get-WmiObject Win32_ComputerSystem\n\n    if (-not $ComputerSystem.PartOfDomain) {\n        $Result.Success = $true\n        $Result.Message = \"Machine not domain-joined - no action needed\"\n        $Result | ConvertTo-Json\n        return\n    }\n\n    # First, test if secure channel is actually broken\n    $SecureChannel = Test-ComputerSecureChannel -ErrorAction SilentlyContinue\n\n    if ($SecureChannel) {\n        $Result.Success = $true\n        $Result.Message = \"Secure channel is already valid\"\n        $Result | ConvertTo-Json\n        return\n    }\n\n    # Attempt to repair secure channel\n    # This requires local admin rights but NOT domain connectivity\n    $RepairResult = Test-ComputerSecureChannel -Repair -ErrorAction Stop\n\n    if ($RepairResult) {\n        $Result.Success = $true\n        $Result.Actions += \"Repaired secure channel\"\n        $Result.Message = \"Domain trust restored successfully\"\n    } else {\n        # If repair fails, the machine may need to be re-joined\n        $Result.Success = $false\n        $Result.Actions += \"Repair attempt failed\"\n        $Result.Message = \"Manual intervention required - may need domain rejoin\"\n        $Result.ManualSteps = @(\n            \"1. Log in with local administrator account\",\n            \"2. Remove computer from domain: Remove-Computer -UnjoinDomainCredential (Get-Credential) -Force\",\n            \"3. Restart computer\",\n            \"4. Rejoin domain: Add-Computer -DomainName $($ComputerSystem.Domain) -Credential (Get-Credential) -Restart\"\n        )\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n\n    # Provide guidance for manual fix\n    $Result.ManualSteps = @(\n        \"Trust repair failed. To fix manually:\",\n        \"1. Log in with local admin (.\\Administrator)\",\n        \"2. Open PowerShell as Admin\",\n        \"3. Run: Reset-ComputerMachinePassword -Credential (Get-Credential)\",\n        \"4. Enter domain admin credentials when prompted\"\n    )\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "verify_script": "$ComputerSystem = Get-WmiObject Win32_ComputerSystem\nif (-not $ComputerSystem.PartOfDomain) {\n    @{ Verified = $true; Note = \"Not domain-joined\" } | ConvertTo-Json\n} else {\n    $SecureChannel = Test-ComputerSecureChannel -ErrorAction SilentlyContinue\n    @{\n        SecureChannelValid = $SecureChannel\n        Verified = $SecureChannel\n    } | ConvertTo-Json\n}",
    "hipaa_controls": [
      "164.312(a)(1)",
      "164.308(a)(4)(ii)(B)"
    ],
    "severity": "high",
    "timeout_seconds": 180
  },
  "RB-WIN-AD-003": {
    "id": "RB-WIN-AD-003",
    "name": "Group Policy Compliance",
    "platform": "windows",
    "detect_script": "# Check Group Policy application status\n$Result = @{\n    Drifted = $false\n    Issues = @()\n}\n\ntry {\n    # Check if machine is domain-joined\n    $ComputerSystem = Get-WmiObject Win32_ComputerSystem\n    $Result.IsDomainJoined = $ComputerSystem.PartOfDomain\n\n    if (-not $ComputerSystem.PartOfDomain) {\n        $Result.Note = \"Machine is not domain-joined, GPO check not applicable\"\n        $Result | ConvertTo-Json -Depth 2\n        return\n    }\n\n    # Get GPO application status via gpresult\n    $GPResultXml = gpresult /x \"$env:TEMP\\gpreport.xml\" /f 2>&1\n    if (Test-Path \"$env:TEMP\\gpreport.xml\") {\n        [xml]$GPReport = Get-Content \"$env:TEMP\\gpreport.xml\"\n\n        # Check computer GPO status\n        $ComputerResults = $GPReport.Rsop.ComputerResults\n        if ($ComputerResults) {\n            $Result.LastGPUpdateComputer = $ComputerResults.EventsDetails.SinglePassEventsDetails.LastPolicyApplicationTime\n\n            # Check for GPO errors\n            $GPOErrors = $ComputerResults.ExtensionData | Where-Object { $_.Extension.EventsDetails.EventRecord.EventDescription -like \"*failed*\" }\n            if ($GPOErrors) {\n                $Result.Drifted = $true\n                $Result.Issues += \"Computer GPO processing errors detected\"\n            }\n        }\n\n        # Check applied GPOs\n        $AppliedGPOs = @()\n        $ComputerGPOs = $ComputerResults.GPO\n        foreach ($GPO in $ComputerGPOs) {\n            $AppliedGPOs += @{\n                Name = $GPO.Name\n                Enabled = $GPO.Enabled\n                AccessDenied = $GPO.AccessDenied\n                Link = $GPO.Link.SOMPath\n            }\n\n            if ($GPO.AccessDenied -eq \"true\") {\n                $Result.Issues += \"Access denied on GPO: $($GPO.Name)\"\n            }\n        }\n        $Result.AppliedGPOCount = $AppliedGPOs.Count\n        $Result.AppliedGPOs = $AppliedGPOs\n\n        Remove-Item \"$env:TEMP\\gpreport.xml\" -Force -ErrorAction SilentlyContinue\n    }\n\n    # Check last GP update time via registry\n    $GPHistoryKey = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\State\\Machine\\Extension-List\\{00000000-0000-0000-0000-000000000000}\"\n    $LastUpdate = (Get-ItemProperty -Path $GPHistoryKey -Name \"startTimeHi\" -ErrorAction SilentlyContinue)\n    if ($null -ne $LastUpdate) {\n        $LastUpdateTime = [DateTime]::FromFileTime(([Int64]$LastUpdate.startTimeHi -shl 32) -bor $LastUpdate.startTimeLo)\n        $UpdateAge = (Get-Date) - $LastUpdateTime\n        $Result.LastGPUpdateAge = [math]::Round($UpdateAge.TotalHours, 1)\n\n        # GP should update at least every 2 hours (default is 90 minutes)\n        if ($UpdateAge.TotalHours -gt 4) {\n            $Result.Drifted = $true\n            $Result.Issues += \"Group Policy not updated in $([math]::Round($UpdateAge.TotalHours, 1)) hours\"\n        }\n    }\n\n    # Check for pending GPO operations\n    $EventLog = Get-WinEvent -FilterHashtable @{LogName='System';ProviderName='Microsoft-Windows-GroupPolicy';Level=2} -MaxEvents 5 -ErrorAction SilentlyContinue\n    if ($EventLog) {\n        $Result.Drifted = $true\n        $Result.RecentGPOErrors = @($EventLog | Select-Object -First 3 | ForEach-Object {\n            @{ TimeCreated = $_.TimeCreated.ToString(\"o\"); Message = $_.Message.Substring(0, [math]::Min(200, $_.Message.Length)) }\n        })\n        $Result.Issues += \"$(@($EventLog).Count) recent Group Policy errors in event log\"\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Drifted = $true\n}\n\n$Result | ConvertTo-Json -Depth 4",
    "remediate_script": "# Force Group Policy update and clear cache if needed\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    $ComputerSystem = Get-WmiObject Win32_ComputerSystem\n    if (-not $ComputerSystem.PartOfDomain) {\n        $Result.Success = $true\n        $Result.Message = \"Machine not domain-joined - no action needed\"\n        $Result | ConvertTo-Json\n        return\n    }\n\n    # Force GP update\n    $GPUpdate = gpupdate /force /wait:120 2>&1\n    $Result.Actions += \"Forced Group Policy update\"\n    $Result.GPUpdateOutput = ($GPUpdate | Out-String).Trim()\n\n    # Check if update was successful\n    $GPUpdateSuccess = $GPUpdate -match \"completed successfully|successfully\"\n    if (-not $GPUpdateSuccess) {\n        # Clear GP cache and retry\n        $GPCachePath = \"$env:WINDIR\\System32\\GroupPolicy\\Machine\\Registry.pol\"\n        if (Test-Path $GPCachePath) {\n            Remove-Item $GPCachePath -Force -ErrorAction SilentlyContinue\n            $Result.Actions += \"Cleared local GP cache (Registry.pol)\"\n        }\n\n        # Clear GP history\n        $GPHistoryPath = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\History\"\n        if (Test-Path $GPHistoryPath) {\n            Remove-Item -Path $GPHistoryPath -Recurse -Force -ErrorAction SilentlyContinue\n            $Result.Actions += \"Cleared GP history\"\n        }\n\n        # Retry GP update\n        $GPUpdate2 = gpupdate /force /wait:120 2>&1\n        $Result.Actions += \"Retried Group Policy update after cache clear\"\n    }\n\n    $Result.Success = $true\n    $Result.Message = \"Group Policy update forced\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "verify_script": "# Verify GPO application\ntry {\n    $ComputerSystem = Get-WmiObject Win32_ComputerSystem\n    if (-not $ComputerSystem.PartOfDomain) {\n        @{ Verified = $true; Note = \"Not domain-joined\" } | ConvertTo-Json\n        return\n    }\n\n    # Check for recent GP errors\n    $RecentErrors = Get-WinEvent -FilterHashtable @{LogName='System';ProviderName='Microsoft-Windows-GroupPolicy';Level=2;StartTime=(Get-Date).AddMinutes(-10)} -MaxEvents 1 -ErrorAction SilentlyContinue\n    $NoRecentErrors = ($null -eq $RecentErrors)\n\n    # Check last successful update\n    $SuccessEvents = Get-WinEvent -FilterHashtable @{LogName='System';ProviderName='Microsoft-Windows-GroupPolicy';Id=1502} -MaxEvents 1 -ErrorAction SilentlyContinue\n    $RecentSuccess = ($null -ne $SuccessEvents -and (Get-Date) - $SuccessEvents.TimeCreated -lt (New-TimeSpan -Minutes 10))\n\n    @{\n        NoRecentErrors = $NoRecentErrors\n        RecentSuccessfulUpdate = $RecentSuccess\n        Verified = ($NoRecentErrors -or $RecentSuccess)\n    } | ConvertTo-Json\n} catch {\n    @{ Verified = $false; Error = $_.Exception.Message } | ConvertTo-Json\n}",
    "hipaa_controls": [
      "164.308(a)(3)"
    ],
    "severity": "high",
    "timeout_seconds": 300
  },
  "RB-WIN-AD-004": {
    "id": "RB-WIN-AD-004",
    "name": "LAPS (Local Admin Passwords)",
    "platform": "windows",
    "detect_script": "# Check LAPS (Local Administrator Password Solution) status\n$Result = @{\n    Drifted = $false\n    Issues = @()\n}\n\ntry {\n    # Check if machine is domain-joined\n    $ComputerSystem = Get-WmiObject Win32_ComputerSystem\n    $Result.IsDomainJoined = $ComputerSystem.PartOfDomain\n\n    if (-not $ComputerSystem.PartOfDomain) {\n        $Result.Note = \"Machine is not domain-joined, LAPS not applicable\"\n        $Result | ConvertTo-Json -Depth 2\n        return\n    }\n\n    # Check if LAPS CSE (Client Side Extension) is installed\n    $LAPSInstalled = $false\n\n    # Check for legacy LAPS (Microsoft LAPS)\n    $LegacyLAPS = Get-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\" -ErrorAction SilentlyContinue |\n        Where-Object { $_.DisplayName -like \"*Local Administrator Password Solution*\" }\n    if ($LegacyLAPS) {\n        $LAPSInstalled = $true\n        $Result.LAPSType = \"Legacy (Microsoft LAPS)\"\n        $Result.LAPSVersion = $LegacyLAPS.DisplayVersion\n    }\n\n    # Check for Windows LAPS (built-in, Windows Server 2019+ / Windows 10 21H2+)\n    $WindowsLAPSKey = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\LAPS\\Config\"\n    if (Test-Path $WindowsLAPSKey) {\n        $LAPSInstalled = $true\n        $Result.LAPSType = \"Windows LAPS (built-in)\"\n    }\n\n    # Check for LAPS CSE DLL\n    $LAPSDll = Test-Path \"$env:ProgramFiles\\LAPS\\CSE\\AdmPwd.dll\"\n    if ($LAPSDll) {\n        $LAPSInstalled = $true\n    }\n\n    $Result.LAPSInstalled = $LAPSInstalled\n\n    if (-not $LAPSInstalled) {\n        $Result.Drifted = $true\n        $Result.Issues += \"LAPS is not installed on this machine\"\n    }\n\n    # Check if LAPS GPO is configured\n    $LAPSPolicyKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft Services\\AdmPwd\"\n    $LAPSEnabled = (Get-ItemProperty -Path $LAPSPolicyKey -Name \"AdmPwdEnabled\" -ErrorAction SilentlyContinue).AdmPwdEnabled\n    $Result.LAPSPolicyEnabled = ($LAPSEnabled -eq 1)\n\n    if ($LAPSInstalled -and $LAPSEnabled -ne 1) {\n        $Result.Drifted = $true\n        $Result.Issues += \"LAPS is installed but not enabled via policy\"\n    }\n\n    # Check password age settings\n    $PasswordAge = (Get-ItemProperty -Path $LAPSPolicyKey -Name \"PasswordAgeDays\" -ErrorAction SilentlyContinue).PasswordAgeDays\n    $Result.PasswordAgeDays = $PasswordAge\n\n    if ($null -ne $PasswordAge -and $PasswordAge -gt 30) {\n        $Result.Issues += \"LAPS password age exceeds 30 days (current: $PasswordAge)\"\n    }\n\n    # Check password complexity settings\n    $Complexity = (Get-ItemProperty -Path $LAPSPolicyKey -Name \"PasswordComplexity\" -ErrorAction SilentlyContinue).PasswordComplexity\n    $Result.PasswordComplexity = $Complexity\n    # 1=Large letters, 2=Large+small, 3=Large+small+numbers, 4=Large+small+numbers+specials\n\n    # Try to check AD attribute for password expiry\n    try {\n        Import-Module ActiveDirectory -ErrorAction Stop\n        $Computer = Get-ADComputer $env:COMPUTERNAME -Properties \"ms-Mcs-AdmPwdExpirationTime\" -ErrorAction Stop\n        $ExpiryTime = $Computer.\"ms-Mcs-AdmPwdExpirationTime\"\n        if ($ExpiryTime) {\n            $ExpiryDate = [DateTime]::FromFileTime($ExpiryTime)\n            $Result.PasswordExpiryDate = $ExpiryDate.ToString(\"o\")\n            $DaysUntilExpiry = ($ExpiryDate - (Get-Date)).Days\n            $Result.DaysUntilExpiry = $DaysUntilExpiry\n\n            if ($DaysUntilExpiry -lt 0) {\n                $Result.Drifted = $true\n                $Result.Issues += \"LAPS password has expired ($([math]::Abs($DaysUntilExpiry)) days ago)\"\n            }\n        }\n    } catch {\n        $Result.ADQueryNote = \"Could not query AD for LAPS attributes: $($_.Exception.Message)\"\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Drifted = $true\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "remediate_script": "# LAPS remediation - ALERT ONLY\n# LAPS requires AD schema extension and GPO configuration, cannot auto-fix\n$Result = @{\n    Action = \"ALERT\"\n    Success = $false\n    Actions = @()\n}\n\ntry {\n    $ComputerSystem = Get-WmiObject Win32_ComputerSystem\n    if (-not $ComputerSystem.PartOfDomain) {\n        $Result.Message = \"Machine not domain-joined - LAPS not applicable\"\n        $Result.Success = $true\n        $Result | ConvertTo-Json -Depth 2\n        return\n    }\n\n    # Check what's missing\n    $LAPSInstalled = (Test-Path \"$env:ProgramFiles\\LAPS\\CSE\\AdmPwd.dll\") -or\n                     (Test-Path \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\LAPS\\Config\")\n\n    if (-not $LAPSInstalled) {\n        $Result.Message = \"LAPS is not installed. Manual intervention required.\"\n        $Result.Recommendation = @(\n            \"For Legacy LAPS: Download and install from Microsoft - https://www.microsoft.com/en-us/download/details.aspx?id=46899\",\n            \"For Windows LAPS (Server 2019+): Enable via Windows Features or Group Policy\",\n            \"AD schema extension required: Import-Module AdmPwd.PS; Update-AdmPwdADSchema\",\n            \"Configure GPO: Computer Configuration > Admin Templates > LAPS\"\n        )\n    } else {\n        # LAPS is installed but may not be configured\n        $LAPSPolicyKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft Services\\AdmPwd\"\n        $LAPSEnabled = (Get-ItemProperty -Path $LAPSPolicyKey -Name \"AdmPwdEnabled\" -ErrorAction SilentlyContinue).AdmPwdEnabled\n\n        if ($LAPSEnabled -ne 1) {\n            $Result.Message = \"LAPS is installed but not enabled via Group Policy\"\n            $Result.Recommendation = @(\n                \"Enable LAPS via GPO: Computer Configuration > Admin Templates > LAPS > Enable local admin password management\",\n                \"Set password complexity and age requirements\",\n                \"Ensure AD permissions are configured for LAPS attributes\"\n            )\n        } else {\n            $Result.Message = \"LAPS is installed and enabled. Checking for stale password.\"\n            # Try to trigger password reset\n            try {\n                Import-Module AdmPwd.PS -ErrorAction Stop\n                Reset-AdmPwdPassword -ComputerName $env:COMPUTERNAME -ErrorAction Stop\n                $Result.Actions += \"Triggered LAPS password reset\"\n                $Result.Success = $true\n            } catch {\n                $Result.Actions += \"Could not trigger password reset: $($_.Exception.Message)\"\n            }\n        }\n    }\n\n    $Result.Warning = \"LAPS deployment requires AD admin privileges and schema changes\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "verify_script": "# Verify LAPS status\ntry {\n    $LAPSInstalled = (Test-Path \"$env:ProgramFiles\\LAPS\\CSE\\AdmPwd.dll\") -or\n                     (Test-Path \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\LAPS\\Config\")\n\n    $LAPSPolicyKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft Services\\AdmPwd\"\n    $LAPSEnabled = (Get-ItemProperty -Path $LAPSPolicyKey -Name \"AdmPwdEnabled\" -ErrorAction SilentlyContinue).AdmPwdEnabled\n\n    # Try to check password age in AD\n    $PasswordAge = $null\n    try {\n        Import-Module ActiveDirectory -ErrorAction Stop\n        $Computer = Get-ADComputer $env:COMPUTERNAME -Properties \"ms-Mcs-AdmPwdExpirationTime\" -ErrorAction Stop\n        $ExpiryTime = $Computer.\"ms-Mcs-AdmPwdExpirationTime\"\n        if ($ExpiryTime) {\n            $ExpiryDate = [DateTime]::FromFileTime($ExpiryTime)\n            $PasswordAge = ((Get-Date) - $ExpiryDate.AddDays(-30)).Days\n        }\n    } catch { }\n\n    @{\n        LAPSInstalled = $LAPSInstalled\n        LAPSEnabled = ($LAPSEnabled -eq 1)\n        PasswordAgeDays = $PasswordAge\n        Verified = ($LAPSInstalled -and $LAPSEnabled -eq 1)\n    } | ConvertTo-Json\n} catch {\n    @{ Verified = $false; Error = $_.Exception.Message } | ConvertTo-Json\n}",
    "hipaa_controls": [
      "164.312(d)"
    ],
    "severity": "high",
    "timeout_seconds": 120
  },
  "RB-WIN-CERT-001": {
    "id": "RB-WIN-CERT-001",
    "name": "Certificate Expiry Check",
    "platform": "windows",
    "detect_script": "# Check for expiring and expired certificates in LocalMachine store\n$Result = @{\n    Drifted = $false\n    Issues = @()\n    ExpiringCerts = @()\n    ExpiredCerts = @()\n    HealthyCerts = @()\n}\n\ntry {\n    $WarningDays = 30\n    $Now = Get-Date\n\n    # Get all certificates from LocalMachine stores\n    $Stores = @(\"My\", \"WebHosting\", \"Remote Desktop\")\n\n    foreach ($StoreName in $Stores) {\n        $Certs = Get-ChildItem -Path \"Cert:\\LocalMachine\\$StoreName\" -ErrorAction SilentlyContinue\n\n        foreach ($Cert in $Certs) {\n            # Skip CA certs and certs without private keys in My store\n            $CertInfo = @{\n                Subject = $Cert.Subject\n                Thumbprint = $Cert.Thumbprint\n                Issuer = $Cert.Issuer\n                NotAfter = $Cert.NotAfter.ToString(\"o\")\n                NotBefore = $Cert.NotBefore.ToString(\"o\")\n                Store = $StoreName\n                HasPrivateKey = $Cert.HasPrivateKey\n                DaysUntilExpiry = [math]::Round(($Cert.NotAfter - $Now).TotalDays, 0)\n            }\n\n            if ($Cert.NotAfter -lt $Now) {\n                # Already expired\n                $CertInfo.Status = \"Expired\"\n                $Result.ExpiredCerts += $CertInfo\n                $Result.Drifted = $true\n                $Result.Issues += \"EXPIRED: $($Cert.Subject) (expired $([math]::Abs($CertInfo.DaysUntilExpiry)) days ago)\"\n            } elseif ($Cert.NotAfter -lt $Now.AddDays($WarningDays)) {\n                # Expiring soon\n                $CertInfo.Status = \"ExpiringSoon\"\n                $Result.ExpiringCerts += $CertInfo\n                $Result.Drifted = $true\n                $Result.Issues += \"EXPIRING: $($Cert.Subject) (in $($CertInfo.DaysUntilExpiry) days)\"\n            } else {\n                $CertInfo.Status = \"Healthy\"\n                $Result.HealthyCerts += $CertInfo\n            }\n        }\n    }\n\n    $Result.TotalCertsChecked = $Result.ExpiringCerts.Count + $Result.ExpiredCerts.Count + $Result.HealthyCerts.Count\n    $Result.ExpiringCount = $Result.ExpiringCerts.Count\n    $Result.ExpiredCount = $Result.ExpiredCerts.Count\n\n    # Also check for self-signed certs in production (potential issue)\n    $SelfSigned = Get-ChildItem -Path \"Cert:\\LocalMachine\\My\" -ErrorAction SilentlyContinue |\n        Where-Object { $_.Subject -eq $_.Issuer -and $_.HasPrivateKey }\n    $Result.SelfSignedCount = @($SelfSigned).Count\n    if ($SelfSigned) {\n        $Result.Issues += \"$(@($SelfSigned).Count) self-signed certificate(s) found in Personal store\"\n    }\n\n    # Check RDP certificate\n    $RDPCertKey = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\"\n    $RDPThumbprint = (Get-ItemProperty -Path $RDPCertKey -Name \"SSLCertificateSHA1Hash\" -ErrorAction SilentlyContinue).SSLCertificateSHA1Hash\n    if ($RDPThumbprint) {\n        $RDPCertHex = ($RDPThumbprint | ForEach-Object { \"{0:X2}\" -f $_ }) -join \"\"\n        $RDPCert = Get-ChildItem -Path \"Cert:\\LocalMachine\\My\\$RDPCertHex\" -ErrorAction SilentlyContinue\n        if ($RDPCert -and $RDPCert.NotAfter -lt $Now.AddDays($WarningDays)) {\n            $Result.Issues += \"RDP certificate expiring in $([math]::Round(($RDPCert.NotAfter - $Now).TotalDays, 0)) days\"\n        }\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Drifted = $true\n}\n\n$Result | ConvertTo-Json -Depth 3",
    "remediate_script": "# Certificate expiry remediation - ALERT ONLY\n# Certificate renewal requires CA infrastructure and cannot be auto-remediated\n$Result = @{\n    Action = \"ALERT\"\n    Success = $false\n    Actions = @()\n    Report = @()\n}\n\ntry {\n    $Now = Get-Date\n    $WarningDays = 30\n\n    # Generate comprehensive report of certificate issues\n    $Stores = @(\"My\", \"WebHosting\", \"Remote Desktop\")\n\n    foreach ($StoreName in $Stores) {\n        $Certs = Get-ChildItem -Path \"Cert:\\LocalMachine\\$StoreName\" -ErrorAction SilentlyContinue\n\n        foreach ($Cert in $Certs) {\n            $DaysLeft = [math]::Round(($Cert.NotAfter - $Now).TotalDays, 0)\n\n            if ($DaysLeft -lt $WarningDays) {\n                $ReportItem = @{\n                    Subject = $Cert.Subject\n                    Thumbprint = $Cert.Thumbprint\n                    Issuer = $Cert.Issuer\n                    ExpiryDate = $Cert.NotAfter.ToString(\"yyyy-MM-dd HH:mm:ss\")\n                    DaysRemaining = $DaysLeft\n                    Store = $StoreName\n                    Status = if ($DaysLeft -lt 0) { \"EXPIRED\" } else { \"EXPIRING\" }\n                }\n\n                # Determine renewal recommendation\n                if ($Cert.Subject -eq $Cert.Issuer) {\n                    $ReportItem.Recommendation = \"Self-signed certificate - regenerate or replace with CA-issued cert\"\n                } elseif ($Cert.Issuer -like \"*Let's Encrypt*\") {\n                    $ReportItem.Recommendation = \"Let's Encrypt certificate - check auto-renewal (certbot renew)\"\n                } elseif ($Cert.Issuer -like \"*DigiCert*\" -or $Cert.Issuer -like \"*Comodo*\" -or $Cert.Issuer -like \"*GoDaddy*\") {\n                    $ReportItem.Recommendation = \"Commercial CA certificate - submit renewal request to CA\"\n                } else {\n                    $ReportItem.Recommendation = \"Internal CA certificate - request renewal from PKI administrator\"\n                }\n\n                $Result.Report += $ReportItem\n            }\n        }\n    }\n\n    # Remove any expired self-signed certs that are not in use (cleanup)\n    $ExpiredSelfSigned = Get-ChildItem -Path \"Cert:\\LocalMachine\\My\" -ErrorAction SilentlyContinue |\n        Where-Object { $_.NotAfter -lt $Now -and $_.Subject -eq $_.Issuer }\n\n    foreach ($ExpCert in $ExpiredSelfSigned) {\n        # Only log, don't delete - some may still be referenced\n        $Result.Actions += \"Found expired self-signed cert: $($ExpCert.Subject) (Thumbprint: $($ExpCert.Thumbprint))\"\n    }\n\n    $Result.CertsRequiringAction = $Result.Report.Count\n    $Result.Message = if ($Result.Report.Count -gt 0) {\n        \"$($Result.Report.Count) certificate(s) require attention - see report\"\n    } else {\n        \"No certificates require immediate attention\"\n    }\n    $Result.Success = $true\n    $Result.Warning = \"Certificate renewal requires manual intervention or PKI administrator action\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 3",
    "verify_script": "# Verify certificate status\ntry {\n    $Now = Get-Date\n    $WarningDays = 30\n\n    $AllCerts = Get-ChildItem -Path \"Cert:\\LocalMachine\\My\" -ErrorAction SilentlyContinue\n    $ExpiringCerts = @($AllCerts | Where-Object { $_.NotAfter -lt $Now.AddDays($WarningDays) })\n    $ExpiredCerts = @($AllCerts | Where-Object { $_.NotAfter -lt $Now })\n\n    $CertDetails = @($ExpiringCerts | ForEach-Object {\n        @{\n            Subject = $_.Subject\n            ExpiryDate = $_.NotAfter.ToString(\"yyyy-MM-dd\")\n            DaysRemaining = [math]::Round(($_.NotAfter - $Now).TotalDays, 0)\n        }\n    })\n\n    @{\n        TotalCerts = @($AllCerts).Count\n        ExpiringCount = $ExpiringCerts.Count\n        ExpiredCount = $ExpiredCerts.Count\n        ExpiringCerts = $CertDetails\n        Verified = ($ExpiringCerts.Count -eq 0)\n    } | ConvertTo-Json -Depth 3\n} catch {\n    @{ Verified = $false; Error = $_.Exception.Message } | ConvertTo-Json\n}",
    "hipaa_controls": [
      "164.312(e)(2)(ii)"
    ],
    "severity": "high",
    "timeout_seconds": 120
  },
  "RB-WIN-RDP-001": {
    "id": "RB-WIN-RDP-001",
    "name": "Remote Desktop Hardening",
    "platform": "windows",
    "detect_script": "# Comprehensive RDP hardening check\n$Result = @{\n    Drifted = $false\n    Issues = @()\n}\n\ntry {\n    # Check if RDP is enabled\n    $TSKey = \"HKLM:\\System\\CurrentControlSet\\Control\\Terminal Server\"\n    $RDPDisabled = (Get-ItemProperty -Path $TSKey -Name \"fDenyTSConnections\" -ErrorAction SilentlyContinue).fDenyTSConnections\n    $Result.RDPEnabled = ($RDPDisabled -eq 0)\n\n    if ($RDPDisabled -ne 0) {\n        $Result.Note = \"RDP is disabled - hardening check informational only\"\n        $Result | ConvertTo-Json -Depth 2\n        return\n    }\n\n    $RDPTcpKey = \"HKLM:\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\"\n\n    # 1. Check NLA (Network Level Authentication)\n    $NLA = (Get-ItemProperty -Path $RDPTcpKey -Name \"UserAuthentication\" -ErrorAction SilentlyContinue).UserAuthentication\n    $Result.NLAEnabled = ($NLA -eq 1)\n    if ($NLA -ne 1) {\n        $Result.Drifted = $true\n        $Result.Issues += \"Network Level Authentication (NLA) is not enabled\"\n    }\n\n    # 2. Check Security Layer\n    # 0 = RDP Security Layer, 1 = Negotiate, 2 = SSL/TLS\n    $SecurityLayer = (Get-ItemProperty -Path $RDPTcpKey -Name \"SecurityLayer\" -ErrorAction SilentlyContinue).SecurityLayer\n    $Result.SecurityLayer = $SecurityLayer\n    $Result.SecurityLayerName = switch ($SecurityLayer) {\n        0 { \"RDP (insecure)\" }\n        1 { \"Negotiate\" }\n        2 { \"SSL/TLS\" }\n        default { \"Unknown\" }\n    }\n    if ($SecurityLayer -lt 2) {\n        $Result.Drifted = $true\n        $Result.Issues += \"RDP security layer should be SSL/TLS (current: $($Result.SecurityLayerName))\"\n    }\n\n    # 3. Check Encryption Level\n    # 1 = Low, 2 = Client Compatible, 3 = High, 4 = FIPS Compliant\n    $EncryptionLevel = (Get-ItemProperty -Path $RDPTcpKey -Name \"MinEncryptionLevel\" -ErrorAction SilentlyContinue).MinEncryptionLevel\n    $Result.MinEncryptionLevel = $EncryptionLevel\n    $Result.EncryptionLevelName = switch ($EncryptionLevel) {\n        1 { \"Low\" }\n        2 { \"Client Compatible\" }\n        3 { \"High\" }\n        4 { \"FIPS Compliant\" }\n        default { \"Unknown\" }\n    }\n    if ($null -eq $EncryptionLevel -or $EncryptionLevel -lt 3) {\n        $Result.Drifted = $true\n        $Result.Issues += \"RDP encryption level should be High or FIPS (current: $($Result.EncryptionLevelName))\"\n    }\n\n    # 4. Check Idle Timeout\n    $TSPolicyKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\Terminal Services\"\n    $IdleTimeout = (Get-ItemProperty -Path $TSPolicyKey -Name \"MaxIdleTime\" -ErrorAction SilentlyContinue).MaxIdleTime\n    $Result.IdleTimeoutMs = $IdleTimeout\n    $Result.IdleTimeoutMinutes = if ($IdleTimeout) { [math]::Round($IdleTimeout / 60000, 0) } else { \"Not configured\" }\n\n    # Should be 15 minutes (900000 ms) or less\n    if ($null -eq $IdleTimeout -or $IdleTimeout -gt 900000 -or $IdleTimeout -eq 0) {\n        $Result.Drifted = $true\n        $Result.Issues += \"RDP idle timeout not configured or exceeds 15 minutes\"\n    }\n\n    # 5. Check Disconnected Session Timeout\n    $DisconnectTimeout = (Get-ItemProperty -Path $TSPolicyKey -Name \"MaxDisconnectionTime\" -ErrorAction SilentlyContinue).MaxDisconnectionTime\n    $Result.DisconnectTimeoutMs = $DisconnectTimeout\n    if ($null -eq $DisconnectTimeout -or $DisconnectTimeout -gt 300000 -or $DisconnectTimeout -eq 0) {\n        $Result.Issues += \"RDP disconnected session timeout not configured or exceeds 5 minutes\"\n    }\n\n    # 6. Check Restricted Admin Mode\n    $RestrictedAdmin = (Get-ItemProperty -Path \"HKLM:\\System\\CurrentControlSet\\Control\\Lsa\" -Name \"DisableRestrictedAdmin\" -ErrorAction SilentlyContinue).DisableRestrictedAdmin\n    $Result.RestrictedAdminEnabled = ($RestrictedAdmin -eq 0)\n    if ($RestrictedAdmin -ne 0) {\n        $Result.Issues += \"Restricted Admin mode is not enabled (credential theft mitigation)\"\n    }\n\n    # 7. Check RDP Port (default 3389 - note if changed)\n    $RDPPort = (Get-ItemProperty -Path $RDPTcpKey -Name \"PortNumber\" -ErrorAction SilentlyContinue).PortNumber\n    $Result.RDPPort = $RDPPort\n\n    # 8. Check if RDP is restricted to specific users\n    $RDPUsersGroup = [ADSI]\"WinNT://./Remote Desktop Users,group\"\n    $RDPMembers = @($RDPUsersGroup.Invoke(\"Members\")) | ForEach-Object {\n        ([ADSI]$_).Path.Split(\"/\")[-1]\n    }\n    $Result.RDPAllowedUsers = $RDPMembers\n    $Result.RDPUserCount = $RDPMembers.Count\n\n    # 9. Check RDP listening on firewall\n    $RDPFirewallRules = Get-NetFirewallRule -DisplayName \"*Remote Desktop*\" -ErrorAction SilentlyContinue |\n        Where-Object { $_.Enabled -eq $true }\n    $Result.RDPFirewallRulesEnabled = @($RDPFirewallRules).Count\n\n    # 10. Check for RemoteFX compression (should be disabled for security)\n    $RemoteFX = (Get-ItemProperty -Path $TSPolicyKey -Name \"fDisableVirtualChannelFiltering\" -ErrorAction SilentlyContinue).fDisableVirtualChannelFiltering\n    if ($RemoteFX -eq 1) {\n        $Result.Issues += \"Virtual channel filtering is disabled (security risk)\"\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Drifted = $true\n}\n\n$Result | ConvertTo-Json -Depth 3",
    "remediate_script": "# Harden RDP configuration\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    $RDPTcpKey = \"HKLM:\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\"\n    $TSPolicyKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\Terminal Services\"\n\n    # Check if RDP is even enabled\n    $TSKey = \"HKLM:\\System\\CurrentControlSet\\Control\\Terminal Server\"\n    $RDPDisabled = (Get-ItemProperty -Path $TSKey -Name \"fDenyTSConnections\" -ErrorAction SilentlyContinue).fDenyTSConnections\n    if ($RDPDisabled -ne 0) {\n        $Result.Success = $true\n        $Result.Message = \"RDP is disabled - no hardening needed\"\n        $Result | ConvertTo-Json\n        return\n    }\n\n    # 1. Enable NLA (Network Level Authentication)\n    Set-ItemProperty -Path $RDPTcpKey -Name \"UserAuthentication\" -Value 1 -Type DWord\n    $Result.Actions += \"Enabled Network Level Authentication (NLA)\"\n\n    # 2. Set Security Layer to SSL/TLS\n    Set-ItemProperty -Path $RDPTcpKey -Name \"SecurityLayer\" -Value 2 -Type DWord\n    $Result.Actions += \"Set RDP security layer to SSL/TLS\"\n\n    # 3. Set Encryption Level to High\n    Set-ItemProperty -Path $RDPTcpKey -Name \"MinEncryptionLevel\" -Value 3 -Type DWord\n    $Result.Actions += \"Set RDP encryption level to High\"\n\n    # 4. Configure Idle Timeout (15 minutes = 900000 ms)\n    if (-not (Test-Path $TSPolicyKey)) {\n        New-Item -Path $TSPolicyKey -Force | Out-Null\n    }\n    Set-ItemProperty -Path $TSPolicyKey -Name \"MaxIdleTime\" -Value 900000 -Type DWord\n    $Result.Actions += \"Set RDP idle timeout to 15 minutes\"\n\n    # 5. Configure Disconnected Session Timeout (5 minutes = 300000 ms)\n    Set-ItemProperty -Path $TSPolicyKey -Name \"MaxDisconnectionTime\" -Value 300000 -Type DWord\n    $Result.Actions += \"Set disconnected session timeout to 5 minutes\"\n\n    # 6. Enable Restricted Admin Mode\n    Set-ItemProperty -Path \"HKLM:\\System\\CurrentControlSet\\Control\\Lsa\" -Name \"DisableRestrictedAdmin\" -Value 0 -Type DWord\n    $Result.Actions += \"Enabled Restricted Admin mode\"\n\n    # 7. Enable virtual channel filtering\n    Set-ItemProperty -Path $TSPolicyKey -Name \"fDisableVirtualChannelFiltering\" -Value 0 -Type DWord\n    $Result.Actions += \"Enabled virtual channel filtering\"\n\n    # 8. Disable clipboard redirection for security\n    Set-ItemProperty -Path $TSPolicyKey -Name \"fDisableClip\" -Value 1 -Type DWord\n    $Result.Actions += \"Disabled clipboard redirection\"\n\n    # 9. Disable drive redirection for data loss prevention\n    Set-ItemProperty -Path $TSPolicyKey -Name \"fDisableCdm\" -Value 1 -Type DWord\n    $Result.Actions += \"Disabled drive redirection\"\n\n    # 10. Set maximum connection limit\n    Set-ItemProperty -Path $TSPolicyKey -Name \"MaxInstanceCount\" -Value 2 -Type DWord\n    $Result.Actions += \"Set maximum concurrent RDP connections to 2\"\n\n    $Result.Success = $true\n    $Result.Message = \"RDP hardening complete\"\n    $Result.Warning = \"Clipboard and drive redirection have been disabled for security. Re-enable if required for operations.\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "verify_script": "# Verify RDP hardening settings\ntry {\n    $TSKey = \"HKLM:\\System\\CurrentControlSet\\Control\\Terminal Server\"\n    $RDPDisabled = (Get-ItemProperty -Path $TSKey -Name \"fDenyTSConnections\" -ErrorAction SilentlyContinue).fDenyTSConnections\n\n    if ($RDPDisabled -ne 0) {\n        @{ Verified = $true; Note = \"RDP is disabled\" } | ConvertTo-Json\n        return\n    }\n\n    $RDPTcpKey = \"HKLM:\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\"\n    $TSPolicyKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\Terminal Services\"\n\n    $NLA = (Get-ItemProperty -Path $RDPTcpKey -Name \"UserAuthentication\" -ErrorAction SilentlyContinue).UserAuthentication\n    $SecurityLayer = (Get-ItemProperty -Path $RDPTcpKey -Name \"SecurityLayer\" -ErrorAction SilentlyContinue).SecurityLayer\n    $EncryptionLevel = (Get-ItemProperty -Path $RDPTcpKey -Name \"MinEncryptionLevel\" -ErrorAction SilentlyContinue).MinEncryptionLevel\n    $IdleTimeout = (Get-ItemProperty -Path $TSPolicyKey -Name \"MaxIdleTime\" -ErrorAction SilentlyContinue).MaxIdleTime\n\n    @{\n        NLAEnabled = ($NLA -eq 1)\n        SecurityLayerTLS = ($SecurityLayer -eq 2)\n        EncryptionHigh = ($EncryptionLevel -ge 3)\n        IdleTimeoutConfigured = ($null -ne $IdleTimeout -and $IdleTimeout -le 900000 -and $IdleTimeout -gt 0)\n        Verified = (\n            $NLA -eq 1 -and\n            $SecurityLayer -eq 2 -and\n            $EncryptionLevel -ge 3 -and\n            $null -ne $IdleTimeout -and $IdleTimeout -le 900000 -and $IdleTimeout -gt 0\n        )\n    } | ConvertTo-Json\n} catch {\n    @{ Verified = $false; Error = $_.Exception.Message } | ConvertTo-Json\n}",
    "hipaa_controls": [
      "164.312(a)(1)",
      "164.312(e)(1)"
    ],
    "severity": "high",
    "timeout_seconds": 120
  },
  "RB-WIN-NET-009": {
    "id": "RB-WIN-NET-009",
    "name": "DNS Content Filtering Verification",
    "platform": "windows",
    "detect_script": "# Verify DNS content filtering is properly configured\n$ErrorActionPreference = \"Stop\"\n$Result = @{\n    Drifted = $false\n    DNSServers = @()\n    FilteringProvider = \"Unknown\"\n    FilteringActive = $false\n    TestResults = @()\n}\n\n# Known DNS filtering provider IP ranges\n$FilteringProviders = @{\n    \"CiscoUmbrella\" = @(\"208.67.222.222\", \"208.67.220.220\", \"208.67.222.123\", \"208.67.220.123\")\n    \"CloudflareGateway\" = @(\"172.64.36.1\", \"172.64.36.2\", \"1.1.1.2\", \"1.0.0.2\", \"1.1.1.3\", \"1.0.0.3\")\n    \"OpenDNS_FamilyShield\" = @(\"208.67.222.123\", \"208.67.220.123\")\n    \"CleanBrowsing\" = @(\"185.228.168.9\", \"185.228.169.9\", \"185.228.168.10\", \"185.228.169.11\")\n    \"Quad9\" = @(\"9.9.9.9\", \"149.112.112.112\", \"9.9.9.11\", \"149.112.112.11\")\n    \"FortiGuard\" = @(\"208.91.112.53\", \"208.91.112.52\")\n    \"NextDNS\" = @(\"45.90.28.0\", \"45.90.30.0\")\n}\n\ntry {\n    # Get DNS servers from all active adapters\n    $ActiveAdapters = Get-NetAdapter | Where-Object { $_.Status -eq \"Up\" }\n\n    foreach ($Adapter in $ActiveAdapters) {\n        $DNS = Get-DnsClientServerAddress -InterfaceIndex $Adapter.ifIndex -AddressFamily IPv4\n        foreach ($Server in $DNS.ServerAddresses) {\n            if ($Server -and $Server -notin $Result.DNSServers) {\n                $Result.DNSServers += $Server\n            }\n        }\n    }\n\n    # Check if configured DNS matches a known filtering provider\n    $MatchedProvider = $null\n    foreach ($Provider in $FilteringProviders.GetEnumerator()) {\n        foreach ($DNSServer in $Result.DNSServers) {\n            if ($DNSServer -in $Provider.Value) {\n                $MatchedProvider = $Provider.Key\n                break\n            }\n        }\n        if ($MatchedProvider) { break }\n    }\n\n    if ($MatchedProvider) {\n        $Result.FilteringProvider = $MatchedProvider\n    } else {\n        # Check if DNS server is internal (AD DNS that may forward to filtering)\n        $InternalDNS = $Result.DNSServers | Where-Object {\n            $_ -match \"^10\\.\" -or $_ -match \"^172\\.(1[6-9]|2[0-9]|3[01])\\.\" -or $_ -match \"^192\\.168\\.\"\n        }\n        if ($InternalDNS) {\n            $Result.FilteringProvider = \"InternalDNS\"\n            $Result.Note = \"Internal DNS detected - filtering may be configured upstream\"\n        } else {\n            $Result.FilteringProvider = \"None\"\n            $Result.Drifted = $true\n        }\n    }\n\n    # Test DNS filtering by resolving known test/malware domains\n    # These are safe test domains used by security vendors to verify filtering\n    $TestDomains = @(\n        @{ Domain = \"examplemalwaredomain.com\"; Type = \"Malware\"; Expected = \"Blocked\" },\n        @{ Domain = \"internetbadguys.com\"; Type = \"Malware_Umbrella\"; Expected = \"Blocked\" },\n        @{ Domain = \"phishing.testcategory.com\"; Type = \"Phishing\"; Expected = \"Blocked\" },\n        @{ Domain = \"malware.testcategory.com\"; Type = \"Malware_Test\"; Expected = \"Blocked\" }\n    )\n\n    foreach ($Test in $TestDomains) {\n        $TestResult = @{\n            Domain = $Test.Domain\n            Category = $Test.Type\n            Expected = $Test.Expected\n        }\n\n        try {\n            $Resolution = Resolve-DnsName -Name $Test.Domain -Type A -DnsOnly -ErrorAction Stop\n            $ResolvedIP = ($Resolution | Where-Object { $_.QueryType -eq \"A\" } | Select-Object -First 1).IPAddress\n\n            if ($ResolvedIP) {\n                # Check if resolved to a block page IP (common sinkhole IPs)\n                $SinkholeIPs = @(\n                    \"0.0.0.0\", \"127.0.0.1\",\n                    \"146.112.61.104\", \"146.112.61.105\",  # Cisco Umbrella block\n                    \"146.112.61.106\", \"146.112.61.107\",\n                    \"::1\"\n                )\n\n                if ($ResolvedIP -in $SinkholeIPs) {\n                    $TestResult.Result = \"Blocked\"\n                    $TestResult.ResolvedTo = $ResolvedIP\n                } else {\n                    $TestResult.Result = \"Resolved\"\n                    $TestResult.ResolvedTo = $ResolvedIP\n                    $TestResult.Warning = \"Domain resolved to real IP - filtering may not be active\"\n                }\n            } else {\n                $TestResult.Result = \"NoRecord\"\n            }\n        } catch {\n            # NXDOMAIN or timeout can indicate blocking\n            if ($_.Exception.Message -match \"DNS name does not exist|non-existent domain\") {\n                $TestResult.Result = \"NXDOMAIN\"\n                $TestResult.Note = \"Domain blocked at DNS level\"\n            } else {\n                $TestResult.Result = \"Error\"\n                $TestResult.Error = $_.Exception.Message\n            }\n        }\n\n        $Result.TestResults += $TestResult\n    }\n\n    # Determine if filtering is actually working\n    $BlockedCount = ($Result.TestResults | Where-Object {\n        $_.Result -in @(\"Blocked\", \"NXDOMAIN\")\n    }).Count\n    $TotalTests = $Result.TestResults.Count\n\n    $Result.FilteringActive = ($BlockedCount -ge 1)  # At least 1 test domain blocked\n    $Result.BlockRate = \"$BlockedCount/$TotalTests domains blocked\"\n\n    if (-not $Result.FilteringActive -and $Result.FilteringProvider -ne \"InternalDNS\") {\n        $Result.Drifted = $true\n    }\n\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Drifted = $true\n}\n\n$Result | ConvertTo-Json -Depth 3",
    "remediate_script": "# Configure DNS to use approved filtering provider\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # Default to Cisco Umbrella (OpenDNS) - widely used in healthcare\n    # These can be overridden by Central Command configuration\n    $PrimaryDNS = \"208.67.222.222\"    # Cisco Umbrella primary\n    $SecondaryDNS = \"208.67.220.220\"  # Cisco Umbrella secondary\n\n    $ActiveAdapters = Get-NetAdapter | Where-Object { $_.Status -eq \"Up\" }\n\n    # Check if machine is domain-joined (shouldn't change DC DNS directly)\n    $IsDomainJoined = (Get-WmiObject Win32_ComputerSystem).PartOfDomain\n\n    if ($IsDomainJoined) {\n        # On domain-joined machines, DNS should point to DC\n        # Instead, configure DNS forwarders on the DC if this IS a DC\n        $IsDC = $false\n        try {\n            Import-Module ActiveDirectory -ErrorAction Stop\n            $DC = Get-ADDomainController -Identity $env:COMPUTERNAME -ErrorAction Stop\n            $IsDC = $true\n        } catch {\n            $IsDC = $false\n        }\n\n        if ($IsDC) {\n            # Configure DNS server forwarders to use filtering DNS\n            try {\n                Import-Module DnsServer -ErrorAction Stop\n                $CurrentForwarders = (Get-DnsServerForwarder).IPAddress.IPAddressToString\n\n                # Add filtering DNS as forwarders\n                $NewForwarders = @($PrimaryDNS, $SecondaryDNS)\n                Set-DnsServerForwarder -IPAddress $NewForwarders -ErrorAction Stop\n                $Result.Actions += \"Configured DC DNS forwarders to Cisco Umbrella ($PrimaryDNS, $SecondaryDNS)\"\n            } catch {\n                $Result.Actions += \"Failed to set DNS forwarders: $($_.Exception.Message)\"\n            }\n        } else {\n            # Workstation/member server - ensure it points to DC for DNS\n            $Result.Actions += \"Domain-joined workstation - DNS should point to DC. Forwarders must be configured on DC.\"\n            $Result.Escalation = \"Configure DNS filtering forwarders on Domain Controller\"\n        }\n    } else {\n        # Standalone machine - set DNS directly to filtering provider\n        foreach ($Adapter in $ActiveAdapters) {\n            try {\n                Set-DnsClientServerAddress -InterfaceIndex $Adapter.ifIndex `\n                    -ServerAddresses @($PrimaryDNS, $SecondaryDNS)\n                $Result.Actions += \"Set DNS on '$($Adapter.Name)' to Cisco Umbrella ($PrimaryDNS, $SecondaryDNS)\"\n            } catch {\n                $Result.Actions += \"Failed to set DNS on '$($Adapter.Name)': $($_.Exception.Message)\"\n            }\n        }\n\n        # Flush DNS cache to apply changes immediately\n        Clear-DnsClientCache\n        $Result.Actions += \"Flushed DNS client cache\"\n    }\n\n    # Verify the change took effect\n    Start-Sleep -Seconds 2\n    try {\n        $TestResolve = Resolve-DnsName -Name \"internetbadguys.com\" -Type A -DnsOnly -ErrorAction Stop\n        $ResolvedIP = ($TestResolve | Where-Object { $_.QueryType -eq \"A\" } | Select-Object -First 1).IPAddress\n        $SinkholeIPs = @(\"0.0.0.0\", \"127.0.0.1\", \"146.112.61.104\", \"146.112.61.105\", \"146.112.61.106\")\n        if ($ResolvedIP -in $SinkholeIPs) {\n            $Result.Actions += \"DNS filtering verified - test domain blocked successfully\"\n        }\n    } catch {\n        if ($_.Exception.Message -match \"non-existent domain|DNS name does not exist\") {\n            $Result.Actions += \"DNS filtering verified - test domain returned NXDOMAIN\"\n        }\n    }\n\n    $Result.Success = $true\n    $Result.FilteringProvider = \"CiscoUmbrella\"\n    $Result.Message = \"DNS content filtering configured\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "verify_script": "# Re-test DNS filtering to verify it is active\n$Result = @{\n    Compliant = $false\n}\n\ntry {\n    # Check current DNS servers\n    $DNSServers = @()\n    $ActiveAdapters = Get-NetAdapter | Where-Object { $_.Status -eq \"Up\" }\n    foreach ($Adapter in $ActiveAdapters) {\n        $DNS = Get-DnsClientServerAddress -InterfaceIndex $Adapter.ifIndex -AddressFamily IPv4\n        $DNSServers += $DNS.ServerAddresses\n    }\n    $Result.ConfiguredDNS = @($DNSServers | Select-Object -Unique)\n\n    # Test filtering with known test domain\n    $FilteringWorks = $false\n    try {\n        $TestResolve = Resolve-DnsName -Name \"internetbadguys.com\" -Type A -DnsOnly -ErrorAction Stop\n        $ResolvedIP = ($TestResolve | Where-Object { $_.QueryType -eq \"A\" } | Select-Object -First 1).IPAddress\n        $SinkholeIPs = @(\"0.0.0.0\", \"127.0.0.1\", \"146.112.61.104\", \"146.112.61.105\", \"146.112.61.106\", \"146.112.61.107\")\n        if ($ResolvedIP -in $SinkholeIPs) {\n            $FilteringWorks = $true\n            $Result.TestResult = \"Blocked (sinkholed to $ResolvedIP)\"\n        } else {\n            $Result.TestResult = \"NOT BLOCKED (resolved to $ResolvedIP)\"\n        }\n    } catch {\n        if ($_.Exception.Message -match \"non-existent domain|DNS name does not exist\") {\n            $FilteringWorks = $true\n            $Result.TestResult = \"Blocked (NXDOMAIN)\"\n        } else {\n            $Result.TestResult = \"Error: $($_.Exception.Message)\"\n        }\n    }\n\n    $Result.FilteringActive = $FilteringWorks\n    $Result.Compliant = $FilteringWorks\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Compliant = $false\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "hipaa_controls": [
      "164.308(a)(5)(ii)(B)",
      "164.312(e)(1)"
    ],
    "severity": "high",
    "timeout_seconds": 120
  },
  "RB-WIN-NET-008": {
    "id": "RB-WIN-NET-008",
    "name": "Unauthorized Open Ports Detection",
    "platform": "windows",
    "detect_script": "# Detect unauthorized listening ports\n$ErrorActionPreference = \"Stop\"\n$Result = @{\n    Drifted = $false\n    AllListeningPorts = @()\n    AuthorizedPorts = @()\n    UnauthorizedPorts = @()\n}\n\n# Allowed port whitelist for clinic environments\n# These are standard Windows/AD infrastructure ports plus common healthcare\n$AllowedPorts = @(\n    53,    # DNS\n    80,    # HTTP\n    88,    # Kerberos\n    135,   # RPC Endpoint Mapper\n    389,   # LDAP\n    443,   # HTTPS\n    445,   # SMB\n    636,   # LDAPS\n    3389,  # RDP\n    5985,  # WinRM HTTP\n    5986,  # WinRM HTTPS\n    9389,  # AD Web Services\n    49152  # RPC Dynamic (start range)\n)\n\n# RPC dynamic range: 49152-65535 is standard Windows ephemeral\n$RPCDynamicStart = 49152\n$RPCDynamicEnd = 65535\n\ntry {\n    # Get all listening TCP connections\n    $Listeners = Get-NetTCPConnection -State Listen -ErrorAction Stop\n\n    foreach ($Listener in $Listeners) {\n        $Port = $Listener.LocalPort\n        $ProcessId = $Listener.OwningProcess\n        $LocalAddress = $Listener.LocalAddress\n\n        # Get process info\n        $Process = Get-Process -Id $ProcessId -ErrorAction SilentlyContinue\n        $ProcessName = if ($Process) { $Process.ProcessName } else { \"Unknown (PID: $ProcessId)\" }\n        $ProcessPath = if ($Process) { $Process.Path } else { \"Unknown\" }\n\n        $PortInfo = @{\n            Port = $Port\n            LocalAddress = $LocalAddress\n            ProcessName = $ProcessName\n            ProcessPath = $ProcessPath\n            ProcessId = $ProcessId\n        }\n\n        # Check if port is in allowed list or RPC dynamic range\n        $IsAuthorized = ($Port -in $AllowedPorts) -or\n                        ($Port -ge $RPCDynamicStart -and $Port -le $RPCDynamicEnd)\n\n        # Also allow localhost-only listeners\n        $IsLocalOnly = ($LocalAddress -eq \"127.0.0.1\" -or $LocalAddress -eq \"::1\")\n\n        if ($IsAuthorized -or $IsLocalOnly) {\n            $PortInfo.Authorized = $true\n            $PortInfo.Reason = if ($IsLocalOnly) { \"LocalhostOnly\" }\n                              elseif ($Port -ge $RPCDynamicStart) { \"RPCDynamicRange\" }\n                              else { \"Whitelisted\" }\n            $Result.AuthorizedPorts += $PortInfo\n        } else {\n            $PortInfo.Authorized = $false\n            $PortInfo.Risk = switch ($Port) {\n                21    { \"HIGH - FTP (unencrypted file transfer)\" }\n                23    { \"CRITICAL - Telnet (unencrypted remote access)\" }\n                25    { \"MEDIUM - SMTP (potential relay)\" }\n                69    { \"HIGH - TFTP (trivial file transfer)\" }\n                110   { \"HIGH - POP3 (unencrypted email)\" }\n                137   { \"MEDIUM - NetBIOS Name Service\" }\n                138   { \"MEDIUM - NetBIOS Datagram\" }\n                139   { \"HIGH - NetBIOS Session (legacy SMB)\" }\n                161   { \"MEDIUM - SNMP (potential info leak)\" }\n                1433  { \"HIGH - SQL Server (database)\" }\n                1521  { \"HIGH - Oracle DB\" }\n                3306  { \"HIGH - MySQL (database)\" }\n                5432  { \"HIGH - PostgreSQL (database)\" }\n                8080  { \"MEDIUM - HTTP Alt (potential web service)\" }\n                8443  { \"MEDIUM - HTTPS Alt\" }\n                default { \"MEDIUM - Unknown service on port $Port\" }\n            }\n            $Result.UnauthorizedPorts += $PortInfo\n        }\n\n        $Result.AllListeningPorts += $PortInfo\n    }\n\n    # Check for listening UDP ports that could be risky\n    $UDPListeners = Get-NetUDPEndpoint -ErrorAction SilentlyContinue |\n        Where-Object { $_.LocalAddress -ne \"127.0.0.1\" -and $_.LocalAddress -ne \"::1\" }\n\n    $SuspiciousUDP = @(69, 161, 162, 514, 1900, 5353)  # TFTP, SNMP, Syslog, UPnP, mDNS\n    foreach ($UDPEndpoint in $UDPListeners) {\n        if ($UDPEndpoint.LocalPort -in $SuspiciousUDP) {\n            $UDPProcess = Get-Process -Id $UDPEndpoint.OwningProcess -ErrorAction SilentlyContinue\n            $Result.UnauthorizedPorts += @{\n                Port = $UDPEndpoint.LocalPort\n                Protocol = \"UDP\"\n                LocalAddress = $UDPEndpoint.LocalAddress\n                ProcessName = if ($UDPProcess) { $UDPProcess.ProcessName } else { \"Unknown\" }\n                Authorized = $false\n                Risk = \"MEDIUM - Suspicious UDP service on port $($UDPEndpoint.LocalPort)\"\n            }\n        }\n    }\n\n    $Result.TotalListening = $Result.AllListeningPorts.Count\n    $Result.UnauthorizedCount = $Result.UnauthorizedPorts.Count\n    $Result.Drifted = ($Result.UnauthorizedPorts.Count -gt 0)\n\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Drifted = $true\n}\n\n$Result | ConvertTo-Json -Depth 3",
    "remediate_script": "# Stop services on unauthorized ports and block via firewall\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # Allowed ports - same whitelist as detect phase\n    $AllowedPorts = @(53, 80, 88, 135, 389, 443, 445, 636, 3389, 5985, 5986, 9389)\n    $RPCDynamicStart = 49152\n\n    # Get unauthorized listening ports\n    $Listeners = Get-NetTCPConnection -State Listen\n    $Unauthorized = @()\n\n    foreach ($Listener in $Listeners) {\n        $Port = $Listener.LocalPort\n        $IsAuthorized = ($Port -in $AllowedPorts) -or ($Port -ge $RPCDynamicStart)\n        $IsLocalOnly = ($Listener.LocalAddress -eq \"127.0.0.1\" -or $Listener.LocalAddress -eq \"::1\")\n\n        if (-not $IsAuthorized -and -not $IsLocalOnly) {\n            $Unauthorized += $Listener\n        }\n    }\n\n    foreach ($Listener in $Unauthorized) {\n        $Port = $Listener.LocalPort\n        $ProcessId = $Listener.OwningProcess\n        $Process = Get-Process -Id $ProcessId -ErrorAction SilentlyContinue\n\n        if ($Process) {\n            $ProcessName = $Process.ProcessName\n\n            # Don't stop critical Windows services\n            $CriticalProcesses = @(\"System\", \"svchost\", \"lsass\", \"csrss\", \"wininit\",\n                                   \"services\", \"smss\", \"winlogon\")\n\n            if ($ProcessName -notin $CriticalProcesses) {\n                # Try to find and stop the associated Windows service\n                $Service = Get-WmiObject Win32_Service |\n                    Where-Object { $_.ProcessId -eq $ProcessId } |\n                    Select-Object -First 1\n\n                if ($Service) {\n                    try {\n                        Stop-Service -Name $Service.Name -Force -ErrorAction Stop\n                        Set-Service -Name $Service.Name -StartupType Disabled\n                        $Result.Actions += \"Stopped and disabled service '$($Service.Name)' on port $Port\"\n                    } catch {\n                        $Result.Actions += \"Failed to stop service '$($Service.Name)' on port $Port`: $($_.Exception.Message)\"\n                    }\n                } else {\n                    # Not a service - try to stop the process\n                    try {\n                        Stop-Process -Id $ProcessId -Force -ErrorAction Stop\n                        $Result.Actions += \"Stopped process '$ProcessName' (PID $ProcessId) on port $Port\"\n                    } catch {\n                        $Result.Actions += \"Failed to stop process '$ProcessName' on port $Port`: $($_.Exception.Message)\"\n                    }\n                }\n            } else {\n                $Result.Actions += \"SKIPPED: Critical process '$ProcessName' on port $Port (manual review required)\"\n            }\n        }\n\n        # Create firewall rule to block the port\n        $RuleName = \"MSP-Block-UnauthorizedPort-$Port\"\n        $ExistingRule = Get-NetFirewallRule -DisplayName $RuleName -ErrorAction SilentlyContinue\n        if (-not $ExistingRule) {\n            try {\n                New-NetFirewallRule -DisplayName $RuleName `\n                    -Direction Inbound -Protocol TCP -LocalPort $Port `\n                    -Action Block `\n                    -Description \"Auto-block: Unauthorized listening port detected by compliance scan\" | Out-Null\n                $Result.Actions += \"Created firewall rule blocking inbound TCP port $Port\"\n            } catch {\n                $Result.Actions += \"Failed to create firewall rule for port $Port`: $($_.Exception.Message)\"\n            }\n        }\n    }\n\n    if ($Unauthorized.Count -eq 0) {\n        $Result.Actions += \"No unauthorized ports found requiring remediation\"\n    }\n\n    $Result.Success = $true\n    $Result.PortsRemediated = $Unauthorized.Count\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "verify_script": "# Re-scan listening ports to verify remediation\n$AllowedPorts = @(53, 80, 88, 135, 389, 443, 445, 636, 3389, 5985, 5986, 9389)\n$RPCDynamicStart = 49152\n\n$Listeners = Get-NetTCPConnection -State Listen -ErrorAction SilentlyContinue\n$StillUnauthorized = @()\n\nforeach ($Listener in $Listeners) {\n    $Port = $Listener.LocalPort\n    $IsAuthorized = ($Port -in $AllowedPorts) -or ($Port -ge $RPCDynamicStart)\n    $IsLocalOnly = ($Listener.LocalAddress -eq \"127.0.0.1\" -or $Listener.LocalAddress -eq \"::1\")\n\n    if (-not $IsAuthorized -and -not $IsLocalOnly) {\n        $Process = Get-Process -Id $Listener.OwningProcess -ErrorAction SilentlyContinue\n        $StillUnauthorized += @{\n            Port = $Port\n            ProcessName = if ($Process) { $Process.ProcessName } else { \"Unknown\" }\n        }\n    }\n}\n\n@{\n    UnauthorizedRemaining = $StillUnauthorized.Count\n    RemainingPorts = $StillUnauthorized\n    Compliant = ($StillUnauthorized.Count -eq 0)\n} | ConvertTo-Json -Depth 2",
    "hipaa_controls": [
      "164.312(a)(1)",
      "164.312(e)(1)"
    ],
    "severity": "high",
    "timeout_seconds": 120
  },
  "RB-WIN-NET-006": {
    "id": "RB-WIN-NET-006",
    "name": "Rogue DHCP Detection",
    "platform": "windows",
    "detect_script": "# Detect rogue DHCP servers on the network\n$ErrorActionPreference = \"Stop\"\n$Result = @{\n    Drifted = $false\n    ApprovedServers = @()\n    DetectedServers = @()\n    RogueServers = @()\n    Method = \"Unknown\"\n}\n\n# Approved DHCP servers - populated from environment or defaults\n# In production, this should be injected from Central Command config\n$ApprovedDHCPServers = @()\n\n# Method 1: Check AD-authorized DHCP servers (domain-joined environments)\ntry {\n    Import-Module DhcpServer -ErrorAction Stop\n    $ADAuthorized = Get-DhcpServerInDC -ErrorAction Stop\n    $Result.ApprovedServers = @($ADAuthorized | ForEach-Object { $_.IPAddress.ToString() })\n    $Result.Method = \"ActiveDirectory\"\n\n    # Get all DHCP servers that responded\n    foreach ($Server in $ADAuthorized) {\n        try {\n            $ServerInfo = Get-DhcpServerSetting -ComputerName $Server.DnsName -ErrorAction Stop\n            $Result.DetectedServers += @{\n                IPAddress = $Server.IPAddress.ToString()\n                DnsName = $Server.DnsName\n                Authorized = $true\n            }\n        } catch {\n            $Result.DetectedServers += @{\n                IPAddress = $Server.IPAddress.ToString()\n                DnsName = $Server.DnsName\n                Authorized = $true\n                Reachable = $false\n            }\n        }\n    }\n} catch {\n    # Method 2: Network-based DHCP discovery via broadcast\n    $Result.Method = \"NetworkDiscovery\"\n\n    try {\n        # Get current DHCP server from active lease\n        $ActiveAdapters = Get-NetAdapter | Where-Object { $_.Status -eq \"Up\" }\n        foreach ($Adapter in $ActiveAdapters) {\n            $IPConfig = Get-NetIPConfiguration -InterfaceIndex $Adapter.ifIndex -ErrorAction SilentlyContinue\n            if ($IPConfig.NetIPv4Interface.Dhcp -eq \"Enabled\") {\n                $DhcpServer = $IPConfig.IPv4DefaultGateway\n                # Get DHCP server from WMI\n                $WMIAdapter = Get-WmiObject Win32_NetworkAdapterConfiguration |\n                    Where-Object { $_.InterfaceIndex -eq $Adapter.ifIndex -and $_.DHCPEnabled }\n                if ($WMIAdapter -and $WMIAdapter.DHCPServer) {\n                    $Result.DetectedServers += @{\n                        IPAddress = $WMIAdapter.DHCPServer\n                        Source = \"ActiveLease\"\n                        Adapter = $Adapter.Name\n                        LeaseObtained = $WMIAdapter.DHCPLeaseObtained\n                    }\n                }\n            }\n        }\n\n        # Use nbtstat/arp to find potential DHCP servers on the subnet\n        $Gateway = (Get-NetRoute -DestinationPrefix \"0.0.0.0/0\" -ErrorAction SilentlyContinue).NextHop |\n            Select-Object -First 1\n        if ($Gateway) {\n            $Subnet = $Gateway -replace '\\.\\d+$', ''\n            # Check common DHCP server addresses\n            $CommonDHCPAddresses = @(\"$Subnet.1\", \"$Subnet.2\", \"$Subnet.10\", \"$Subnet.254\")\n            foreach ($Addr in $CommonDHCPAddresses) {\n                $Ping = Test-Connection -ComputerName $Addr -Count 1 -Quiet -ErrorAction SilentlyContinue\n                if ($Ping) {\n                    # Check if port 67 (DHCP) is responding\n                    $UdpClient = New-Object System.Net.Sockets.UdpClient\n                    $UdpClient.Client.ReceiveTimeout = 1000\n                    try {\n                        $UdpClient.Connect($Addr, 67)\n                        $Result.DetectedServers += @{\n                            IPAddress = $Addr\n                            Source = \"PortScan\"\n                            DHCPPortOpen = $true\n                        }\n                    } catch {\n                        # Port not open, not a DHCP server\n                    } finally {\n                        $UdpClient.Close()\n                    }\n                }\n            }\n        }\n    } catch {\n        $Result.Error = \"Discovery failed: $($_.Exception.Message)\"\n    }\n}\n\n# Check Windows DHCP server event log for DHCP conflicts\ntry {\n    $DHCPConflicts = Get-WinEvent -FilterHashtable @{\n        LogName = \"System\"\n        ProviderName = \"DHCPClient\", \"Dhcp\"\n        Level = 2, 3  # Error and Warning\n        StartTime = (Get-Date).AddHours(-24)\n    } -MaxEvents 20 -ErrorAction SilentlyContinue\n\n    if ($DHCPConflicts) {\n        $Result.RecentDHCPEvents = @($DHCPConflicts | ForEach-Object {\n            @{\n                TimeCreated = $_.TimeCreated.ToString(\"o\")\n                Id = $_.Id\n                Message = $_.Message.Substring(0, [Math]::Min(200, $_.Message.Length))\n            }\n        })\n    }\n} catch {\n    # Event log query failed - non-critical\n}\n\n# Determine if there are rogue servers\n$ApprovedIPs = $Result.ApprovedServers\n$DetectedIPs = @($Result.DetectedServers | ForEach-Object { $_.IPAddress })\n\nforeach ($DetectedIP in $DetectedIPs) {\n    if ($DetectedIP -and $ApprovedIPs.Count -gt 0 -and $DetectedIP -notin $ApprovedIPs) {\n        $Result.RogueServers += $DetectedIP\n        $Result.Drifted = $true\n    }\n}\n\n# If no approved list and we detected servers, flag for review\nif ($ApprovedIPs.Count -eq 0 -and $DetectedIPs.Count -gt 0) {\n    $Result.Warning = \"No approved DHCP server list configured - manual review required\"\n    $Result.Drifted = $true\n}\n\n$Result | ConvertTo-Json -Depth 3",
    "remediate_script": "# Rogue DHCP remediation - alert and generate evidence (cannot auto-remediate)\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # Collect evidence for the rogue DHCP detection\n    $EvidenceBundle = @{\n        Timestamp = (Get-Date).ToUniversalTime().ToString(\"o\")\n        Hostname = $env:COMPUTERNAME\n        Domain = (Get-WmiObject Win32_ComputerSystem).Domain\n        EventType = \"RogueDHCPDetected\"\n    }\n\n    # Capture current network state\n    $EvidenceBundle.NetworkConfig = @{\n        IPConfiguration = @(Get-NetIPConfiguration | ForEach-Object {\n            @{\n                InterfaceAlias = $_.InterfaceAlias\n                IPv4Address = $_.IPv4Address.IPAddress\n                DHCPServer = $_.IPv4DefaultGateway.NextHop\n            }\n        })\n        DHCPLeases = @(Get-WmiObject Win32_NetworkAdapterConfiguration |\n            Where-Object { $_.DHCPEnabled } | ForEach-Object {\n            @{\n                Description = $_.Description\n                DHCPServer = $_.DHCPServer\n                DHCPLeaseObtained = $_.DHCPLeaseObtained\n                DHCPLeaseExpires = $_.DHCPLeaseExpires\n            }\n        })\n    }\n\n    # Log to Windows Event Log for SIEM collection\n    $EventMessage = \"HIPAA ALERT: Potential rogue DHCP server detected on clinic network. \" +\n        \"Immediate investigation required. Evidence bundle generated at $(Get-Date -Format o).\"\n\n    try {\n        # Create custom event source if it doesn't exist\n        if (-not [System.Diagnostics.EventLog]::SourceExists(\"MSP-Compliance\")) {\n            New-EventLog -LogName Application -Source \"MSP-Compliance\" -ErrorAction SilentlyContinue\n        }\n        Write-EventLog -LogName Application -Source \"MSP-Compliance\" `\n            -EventId 6001 -EntryType Warning -Message $EventMessage\n        $Result.Actions += \"Logged HIPAA alert to Application event log (EventId 6001)\"\n    } catch {\n        $Result.Actions += \"Could not write event log: $($_.Exception.Message)\"\n    }\n\n    # Write evidence bundle to compliance directory\n    $EvidencePath = \"$env:ProgramData\\MSP-Compliance\\Evidence\"\n    if (-not (Test-Path $EvidencePath)) {\n        New-Item -Path $EvidencePath -ItemType Directory -Force | Out-Null\n    }\n    $EvidenceFile = Join-Path $EvidencePath \"rogue-dhcp-$(Get-Date -Format 'yyyyMMdd-HHmmss').json\"\n    $EvidenceBundle | ConvertTo-Json -Depth 5 | Set-Content -Path $EvidenceFile -Encoding UTF8\n    $Result.Actions += \"Evidence bundle saved to $EvidenceFile\"\n\n    # Block rogue DHCP at firewall level if detected\n    $RogueServers = @()  # Populated from detect phase via Central Command\n    foreach ($RogueIP in $RogueServers) {\n        try {\n            $RuleName = \"Block-RogueDHCP-$($RogueIP.Replace('.', '-'))\"\n            $ExistingRule = Get-NetFirewallRule -DisplayName $RuleName -ErrorAction SilentlyContinue\n            if (-not $ExistingRule) {\n                New-NetFirewallRule -DisplayName $RuleName `\n                    -Direction Inbound -Protocol UDP -LocalPort 68 `\n                    -RemoteAddress $RogueIP -Action Block `\n                    -Description \"Auto-block: Rogue DHCP server detected\" | Out-Null\n                $Result.Actions += \"Created firewall rule to block rogue DHCP from $RogueIP\"\n            }\n        } catch {\n            $Result.Actions += \"Failed to block $RogueIP`: $($_.Exception.Message)\"\n        }\n    }\n\n    $Result.Success = $true\n    $Result.Message = \"Rogue DHCP alert generated - requires manual investigation and network remediation\"\n    $Result.Escalation = \"L3-REQUIRED: Contact network administrator to locate and disable rogue DHCP server\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 3",
    "verify_script": "# Re-scan to verify only approved DHCP servers respond\n$Result = @{\n    Compliant = $false\n    DetectedServers = @()\n}\n\ntry {\n    # Re-check active DHCP leases\n    $ActiveAdapters = Get-NetAdapter | Where-Object { $_.Status -eq \"Up\" }\n    foreach ($Adapter in $ActiveAdapters) {\n        $WMIAdapter = Get-WmiObject Win32_NetworkAdapterConfiguration |\n            Where-Object { $_.InterfaceIndex -eq $Adapter.ifIndex -and $_.DHCPEnabled }\n        if ($WMIAdapter -and $WMIAdapter.DHCPServer) {\n            $Result.DetectedServers += $WMIAdapter.DHCPServer\n        }\n    }\n\n    # Check AD-authorized list if available\n    try {\n        Import-Module DhcpServer -ErrorAction Stop\n        $ADAuthorized = Get-DhcpServerInDC -ErrorAction Stop\n        $ApprovedIPs = @($ADAuthorized | ForEach-Object { $_.IPAddress.ToString() })\n\n        $RogueFound = $false\n        foreach ($Server in $Result.DetectedServers) {\n            if ($Server -notin $ApprovedIPs) {\n                $RogueFound = $true\n            }\n        }\n        $Result.Compliant = (-not $RogueFound)\n        $Result.ApprovedCount = $ApprovedIPs.Count\n    } catch {\n        # Without AD, mark compliant if no new DHCP conflicts in last hour\n        $RecentConflicts = Get-WinEvent -FilterHashtable @{\n            LogName = \"System\"\n            ProviderName = \"DHCPClient\", \"Dhcp\"\n            Level = 2, 3\n            StartTime = (Get-Date).AddHours(-1)\n        } -MaxEvents 5 -ErrorAction SilentlyContinue\n\n        $Result.Compliant = ($null -eq $RecentConflicts -or $RecentConflicts.Count -eq 0)\n        $Result.Note = \"AD not available - verified via event log (no conflicts in last hour)\"\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Compliant = $false\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "hipaa_controls": [
      "164.312(a)(1)",
      "164.312(e)(1)"
    ],
    "severity": "critical",
    "timeout_seconds": 120
  },
  "RB-WIN-NET-007": {
    "id": "RB-WIN-NET-007",
    "name": "Network Segmentation / VLAN Audit",
    "platform": "windows",
    "detect_script": "# Check VLAN assignment and network segmentation for ePHI isolation\n$ErrorActionPreference = \"Stop\"\n$Result = @{\n    Drifted = $false\n    Adapters = @()\n    SegmentationIssues = @()\n    VLANInfo = @()\n}\n\ntry {\n    # Get physical adapter VLAN information\n    $PhysicalAdapters = Get-NetAdapter -Physical | Where-Object { $_.Status -eq \"Up\" }\n\n    foreach ($Adapter in $PhysicalAdapters) {\n        $AdapterInfo = @{\n            Name = $Adapter.Name\n            InterfaceDescription = $Adapter.InterfaceDescription\n            MacAddress = $Adapter.MacAddress\n            LinkSpeed = $Adapter.LinkSpeed\n            Status = $Adapter.Status.ToString()\n        }\n\n        # Get VLAN ID if available\n        try {\n            $VlanId = (Get-NetAdapterAdvancedProperty -Name $Adapter.Name -RegistryKeyword \"VlanID\" -ErrorAction SilentlyContinue).RegistryValue\n            if ($VlanId) {\n                $AdapterInfo.VlanId = [int]$VlanId\n            } else {\n                $AdapterInfo.VlanId = \"NotConfigured\"\n            }\n        } catch {\n            $AdapterInfo.VlanId = \"NotSupported\"\n        }\n\n        # Get IP configuration\n        $IPConfig = Get-NetIPConfiguration -InterfaceIndex $Adapter.ifIndex -ErrorAction SilentlyContinue\n        if ($IPConfig) {\n            $AdapterInfo.IPv4Address = ($IPConfig.IPv4Address | Select-Object -First 1).IPAddress\n            $AdapterInfo.SubnetPrefix = ($IPConfig.IPv4Address | Select-Object -First 1).PrefixLength\n            $AdapterInfo.DefaultGateway = ($IPConfig.IPv4DefaultGateway | Select-Object -First 1).NextHop\n            $AdapterInfo.DNSServers = @($IPConfig.DNSServer | Where-Object { $_.AddressFamily -eq 2 } |\n                ForEach-Object { $_.ServerAddresses }) | Select-Object -First 3\n        }\n\n        $Result.Adapters += $AdapterInfo\n    }\n\n    # Check for 802.1Q VLAN sub-interfaces\n    $VlanAdapters = Get-NetAdapter | Where-Object { $_.Name -match \"VLAN|vlan|\\.\\d+$\" }\n    foreach ($VlanAdapter in $VlanAdapters) {\n        $Result.VLANInfo += @{\n            Name = $VlanAdapter.Name\n            Status = $VlanAdapter.Status.ToString()\n            InterfaceDescription = $VlanAdapter.InterfaceDescription\n        }\n    }\n\n    # Determine machine role to check proper VLAN assignment\n    $ComputerSystem = Get-WmiObject Win32_ComputerSystem\n    $OSInfo = Get-WmiObject Win32_OperatingSystem\n    $MachineRole = @{\n        DomainJoined = $ComputerSystem.PartOfDomain\n        Domain = $ComputerSystem.Domain\n        IsServer = ($OSInfo.ProductType -eq 3)\n        IsWorkstation = ($OSInfo.ProductType -eq 1)\n        ComputerName = $env:COMPUTERNAME\n    }\n    $Result.MachineRole = $MachineRole\n\n    # Check if ePHI-related services are running (EHR, database, PACS)\n    $EPHIServices = @(\n        \"MSSQLSERVER\", \"SQLSERVERAGENT\",     # SQL Server (EHR database)\n        \"MySQL\", \"MySQL80\",                   # MySQL\n        \"postgresql*\",                        # PostgreSQL\n        \"W3SVC\",                              # IIS (web-based EHR)\n        \"OrthanC\", \"DCM4CHEE\",               # PACS/DICOM\n        \"HL7*\",                               # HL7 interfaces\n        \"nextgen*\", \"athena*\", \"epic*\"        # Common EHR services\n    )\n\n    $RunningEPHIServices = @()\n    foreach ($ServicePattern in $EPHIServices) {\n        $Found = Get-Service -Name $ServicePattern -ErrorAction SilentlyContinue |\n            Where-Object { $_.Status -eq \"Running\" }\n        if ($Found) {\n            $RunningEPHIServices += $Found.Name\n        }\n    }\n    $Result.EPHIServicesDetected = $RunningEPHIServices\n\n    # Test segmentation by attempting traceroute to common medical device subnets\n    $MedicalDeviceSubnets = @(\"10.10.10.1\", \"10.20.20.1\", \"172.16.100.1\", \"192.168.100.1\")\n    $SegmentationTests = @()\n\n    foreach ($Target in $MedicalDeviceSubnets) {\n        try {\n            $TraceResult = Test-NetConnection -ComputerName $Target -TraceRoute -WarningAction SilentlyContinue -ErrorAction SilentlyContinue\n            if ($TraceResult.PingSucceeded) {\n                $HopCount = ($TraceResult.TraceRoute | Measure-Object).Count\n                $SegmentationTests += @{\n                    Target = $Target\n                    Reachable = $true\n                    HopCount = $HopCount\n                    TraceRoute = @($TraceResult.TraceRoute)\n                }\n\n                # If a workstation can reach medical device subnets directly, flag it\n                if ($MachineRole.IsWorkstation -and $HopCount -le 1) {\n                    $Result.SegmentationIssues += \"Workstation can directly reach medical subnet $Target (no L3 hop)\"\n                    $Result.Drifted = $true\n                }\n            } else {\n                $SegmentationTests += @{\n                    Target = $Target\n                    Reachable = $false\n                }\n            }\n        } catch {\n            $SegmentationTests += @{\n                Target = $Target\n                Reachable = $false\n                Error = $_.Exception.Message\n            }\n        }\n    }\n    $Result.SegmentationTests = $SegmentationTests\n\n    # If ePHI services found on a machine without VLAN tagging, flag it\n    if ($RunningEPHIServices.Count -gt 0) {\n        $HasVlanTag = $Result.Adapters | Where-Object { $_.VlanId -ne \"NotConfigured\" -and $_.VlanId -ne \"NotSupported\" }\n        if (-not $HasVlanTag) {\n            $Result.SegmentationIssues += \"ePHI services running on machine without VLAN isolation\"\n            $Result.Drifted = $true\n        }\n    }\n\n    if ($Result.SegmentationIssues.Count -gt 0) {\n        $Result.Drifted = $true\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Drifted = $true\n}\n\n$Result | ConvertTo-Json -Depth 4",
    "remediate_script": "# VLAN remediation - alert and escalate (cannot auto-move VLANs)\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    $Timestamp = (Get-Date).ToUniversalTime().ToString(\"o\")\n\n    # Collect evidence for the segmentation violation\n    $EvidenceBundle = @{\n        Timestamp = $Timestamp\n        Hostname = $env:COMPUTERNAME\n        Domain = (Get-WmiObject Win32_ComputerSystem).Domain\n        EventType = \"VLANSegmentationViolation\"\n        NetworkConfig = @{\n            Adapters = @(Get-NetAdapter -Physical | Where-Object { $_.Status -eq \"Up\" } | ForEach-Object {\n                @{\n                    Name = $_.Name\n                    MacAddress = $_.MacAddress\n                    LinkSpeed = $_.LinkSpeed\n                }\n            })\n            IPAddresses = @(Get-NetIPAddress -AddressFamily IPv4 |\n                Where-Object { $_.IPAddress -ne \"127.0.0.1\" } | ForEach-Object {\n                @{\n                    IPAddress = $_.IPAddress\n                    PrefixLength = $_.PrefixLength\n                    InterfaceAlias = $_.InterfaceAlias\n                }\n            })\n            Routes = @(Get-NetRoute -AddressFamily IPv4 |\n                Where-Object { $_.DestinationPrefix -ne \"0.0.0.0/0\" -and $_.DestinationPrefix -ne \"255.255.255.255/32\" } |\n                Select-Object -First 20 | ForEach-Object {\n                @{\n                    Destination = $_.DestinationPrefix\n                    NextHop = $_.NextHop\n                    InterfaceAlias = $_.InterfaceAlias\n                }\n            })\n        }\n    }\n\n    # Log to Windows Event Log\n    try {\n        if (-not [System.Diagnostics.EventLog]::SourceExists(\"MSP-Compliance\")) {\n            New-EventLog -LogName Application -Source \"MSP-Compliance\" -ErrorAction SilentlyContinue\n        }\n        $EventMessage = \"HIPAA ALERT: Network segmentation violation detected on $env:COMPUTERNAME. \" +\n            \"ePHI systems may not be properly isolated. Immediate network review required.\"\n        Write-EventLog -LogName Application -Source \"MSP-Compliance\" `\n            -EventId 7001 -EntryType Warning -Message $EventMessage\n        $Result.Actions += \"Logged HIPAA segmentation alert to Application event log (EventId 7001)\"\n    } catch {\n        $Result.Actions += \"Could not write event log: $($_.Exception.Message)\"\n    }\n\n    # Save evidence bundle\n    $EvidencePath = \"$env:ProgramData\\MSP-Compliance\\Evidence\"\n    if (-not (Test-Path $EvidencePath)) {\n        New-Item -Path $EvidencePath -ItemType Directory -Force | Out-Null\n    }\n    $EvidenceFile = Join-Path $EvidencePath \"vlan-audit-$(Get-Date -Format 'yyyyMMdd-HHmmss').json\"\n    $EvidenceBundle | ConvertTo-Json -Depth 5 | Set-Content -Path $EvidenceFile -Encoding UTF8\n    $Result.Actions += \"Evidence bundle saved to $EvidenceFile\"\n\n    $Result.Success = $true\n    $Result.Message = \"VLAN segmentation alert generated - requires network administrator intervention\"\n    $Result.Escalation = \"L3-REQUIRED: Network administrator must verify VLAN assignments and inter-VLAN ACLs\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "verify_script": "# Re-check VLAN assignment after remediation\n$Result = @{\n    Compliant = $false\n}\n\ntry {\n    $PhysicalAdapters = Get-NetAdapter -Physical | Where-Object { $_.Status -eq \"Up\" }\n    $VLANAssignments = @()\n\n    foreach ($Adapter in $PhysicalAdapters) {\n        $VlanId = $null\n        try {\n            $VlanId = (Get-NetAdapterAdvancedProperty -Name $Adapter.Name -RegistryKeyword \"VlanID\" -ErrorAction SilentlyContinue).RegistryValue\n        } catch {}\n\n        $VLANAssignments += @{\n            Name = $Adapter.Name\n            VlanId = if ($VlanId) { [int]$VlanId } else { \"NotConfigured\" }\n            MacAddress = $Adapter.MacAddress\n        }\n    }\n\n    $Result.VLANAssignments = $VLANAssignments\n\n    # Check if ePHI services are on tagged VLANs\n    $EPHIServices = @(\"MSSQLSERVER\", \"MySQL\", \"MySQL80\", \"W3SVC\")\n    $HasEPHI = $false\n    foreach ($Svc in $EPHIServices) {\n        $Running = Get-Service -Name $Svc -ErrorAction SilentlyContinue |\n            Where-Object { $_.Status -eq \"Running\" }\n        if ($Running) { $HasEPHI = $true; break }\n    }\n\n    if ($HasEPHI) {\n        $HasVlanTag = $VLANAssignments | Where-Object { $_.VlanId -ne \"NotConfigured\" }\n        $Result.Compliant = ($null -ne $HasVlanTag)\n        $Result.Note = \"ePHI services detected - VLAN tagging $(if ($Result.Compliant) { 'confirmed' } else { 'missing' })\"\n    } else {\n        $Result.Compliant = $true\n        $Result.Note = \"No ePHI services detected on this machine\"\n    }\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Compliant = $false\n}\n\n$Result | ConvertTo-Json -Depth 3",
    "hipaa_controls": [
      "164.312(a)(1)",
      "164.312(e)(1)"
    ],
    "severity": "high",
    "timeout_seconds": 180
  },
  "RB-WIN-ACCESS-003": {
    "id": "RB-WIN-ACCESS-003",
    "name": "Failed Login Monitoring and Alerting",
    "platform": "windows",
    "detect_script": "# Query Security event log for failed logon attempts in last 24 hours\n$Result = @{\n    Drifted = $false\n    Issues = @()\n    FailedLogons = @{}\n}\n\ntry {\n    $CutoffTime = (Get-Date).AddHours(-24)\n\n    # Query Event ID 4625 (An account failed to log on)\n    $FailedEvents = Get-WinEvent -FilterHashtable @{\n        LogName = 'Security'\n        Id = 4625\n        StartTime = $CutoffTime\n    } -ErrorAction SilentlyContinue\n\n    $TotalFailures = @($FailedEvents).Count\n    $Result.TotalFailedLogons24h = $TotalFailures\n\n    # Group by target account\n    $ByAccount = @{}\n    $BySourceIP = @{}\n\n    foreach ($Event in $FailedEvents) {\n        $Xml = [xml]$Event.ToXml()\n        $TargetAccount = ($Xml.Event.EventData.Data | Where-Object { $_.Name -eq \"TargetUserName\" }).'#text'\n        $SourceIP = ($Xml.Event.EventData.Data | Where-Object { $_.Name -eq \"IpAddress\" }).'#text'\n        $LogonType = ($Xml.Event.EventData.Data | Where-Object { $_.Name -eq \"LogonType\" }).'#text'\n        $FailureReason = ($Xml.Event.EventData.Data | Where-Object { $_.Name -eq \"SubStatus\" }).'#text'\n\n        # Count by account\n        if ($TargetAccount -and $TargetAccount -ne \"-\") {\n            if (-not $ByAccount.ContainsKey($TargetAccount)) {\n                $ByAccount[$TargetAccount] = @{ Count = 0; SourceIPs = @(); LogonTypes = @(); LastFailure = $null }\n            }\n            $ByAccount[$TargetAccount].Count++\n            if ($SourceIP -and $SourceIP -notin $ByAccount[$TargetAccount].SourceIPs) {\n                $ByAccount[$TargetAccount].SourceIPs += $SourceIP\n            }\n            if ($LogonType -and $LogonType -notin $ByAccount[$TargetAccount].LogonTypes) {\n                $ByAccount[$TargetAccount].LogonTypes += $LogonType\n            }\n            $ByAccount[$TargetAccount].LastFailure = $Event.TimeCreated.ToString(\"o\")\n        }\n\n        # Count by source IP\n        if ($SourceIP -and $SourceIP -ne \"-\") {\n            if (-not $BySourceIP.ContainsKey($SourceIP)) {\n                $BySourceIP[$SourceIP] = 0\n            }\n            $BySourceIP[$SourceIP]++\n        }\n    }\n\n    $Result.FailedLogons.ByAccount = $ByAccount\n    $Result.FailedLogons.BySourceIP = $BySourceIP\n    $Result.UniqueAccountsTargeted = $ByAccount.Count\n    $Result.UniqueSourceIPs = $BySourceIP.Count\n\n    # Flag brute force: any account with >10 failures\n    $BruteForceAccounts = @($ByAccount.GetEnumerator() | Where-Object { $_.Value.Count -gt 10 })\n    $Result.BruteForceAccountCount = $BruteForceAccounts.Count\n    $Result.BruteForceAccounts = @($BruteForceAccounts | ForEach-Object {\n        @{ Account = $_.Key; FailureCount = $_.Value.Count; SourceIPs = $_.Value.SourceIPs }\n    })\n\n    if ($BruteForceAccounts.Count -gt 0) {\n        $Result.Drifted = $true\n        $Result.Issues += \"$($BruteForceAccounts.Count) account(s) with >10 failed logon attempts (potential brute force)\"\n    }\n\n    # Flag high-volume source IPs\n    $HighVolumeIPs = @($BySourceIP.GetEnumerator() | Where-Object { $_.Value -gt 20 })\n    $Result.HighVolumeSourceIPs = @($HighVolumeIPs | ForEach-Object { @{ IP = $_.Key; Count = $_.Value } })\n\n    if ($HighVolumeIPs.Count -gt 0) {\n        $Result.Issues += \"$($HighVolumeIPs.Count) source IP(s) with >20 failed attempts\"\n    }\n\n    # Check currently locked out accounts\n    try {\n        Import-Module ActiveDirectory -ErrorAction Stop\n        $LockedAccounts = @(Search-ADAccount -LockedOut -ErrorAction Stop)\n        $Result.LockedAccountCount = $LockedAccounts.Count\n        $Result.LockedAccounts = @($LockedAccounts | Select-Object -First 20 | ForEach-Object {\n            @{ SamAccountName = $_.SamAccountName; LockedOut = $_.LockedOut }\n        })\n    } catch {\n        # Not a DC or AD module unavailable\n        $Result.LockedAccountCount = -1\n        $Result.LockedAccountNote = \"AD module not available - cannot check lockout status\"\n    }\n\n    # Check account lockout policy\n    $LockoutThreshold = (net accounts 2>&1 | Select-String \"Lockout threshold\").ToString() -replace '.*:\\s+', ''\n    $Result.LockoutThreshold = $LockoutThreshold\n\n    if ($LockoutThreshold -eq \"Never\" -or $LockoutThreshold -eq \"0\") {\n        $Result.Drifted = $true\n        $Result.Issues += \"Account lockout threshold is not configured\"\n    }\n\n    $Result.IssueCount = $Result.Issues.Count\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Drifted = $true\n}\n\n$Result | ConvertTo-Json -Depth 4",
    "remediate_script": "# Lock accounts with excessive failures and block offending source IPs\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    $CutoffTime = (Get-Date).AddHours(-24)\n\n    # Get failed logon events\n    $FailedEvents = Get-WinEvent -FilterHashtable @{\n        LogName = 'Security'\n        Id = 4625\n        StartTime = $CutoffTime\n    } -ErrorAction SilentlyContinue\n\n    # Build account failure counts\n    $ByAccount = @{}\n    $BySourceIP = @{}\n\n    foreach ($Event in $FailedEvents) {\n        $Xml = [xml]$Event.ToXml()\n        $TargetAccount = ($Xml.Event.EventData.Data | Where-Object { $_.Name -eq \"TargetUserName\" }).'#text'\n        $SourceIP = ($Xml.Event.EventData.Data | Where-Object { $_.Name -eq \"IpAddress\" }).'#text'\n\n        if ($TargetAccount -and $TargetAccount -ne \"-\") {\n            if (-not $ByAccount.ContainsKey($TargetAccount)) { $ByAccount[$TargetAccount] = 0 }\n            $ByAccount[$TargetAccount]++\n        }\n        if ($SourceIP -and $SourceIP -ne \"-\" -and $SourceIP -ne \"::1\" -and $SourceIP -ne \"127.0.0.1\") {\n            if (-not $BySourceIP.ContainsKey($SourceIP)) { $BySourceIP[$SourceIP] = 0 }\n            $BySourceIP[$SourceIP]++\n        }\n    }\n\n    # Lock accounts with >10 failures (if AD module available)\n    try {\n        Import-Module ActiveDirectory -ErrorAction Stop\n        foreach ($Entry in $ByAccount.GetEnumerator()) {\n            if ($Entry.Value -gt 10) {\n                $Account = $Entry.Key\n                try {\n                    # Check if account exists and is not already locked\n                    $ADUser = Get-ADUser -Identity $Account -Properties LockedOut -ErrorAction Stop\n                    if (-not $ADUser.LockedOut) {\n                        # Disable the account temporarily\n                        Disable-ADAccount -Identity $Account -ErrorAction Stop\n                        $Result.Actions += \"Disabled account '$Account' ($($Entry.Value) failed logons)\"\n                    } else {\n                        $Result.Actions += \"Account '$Account' already locked ($($Entry.Value) failed logons)\"\n                    }\n                } catch {\n                    $Result.Actions += \"Could not lock '$Account': $($_.Exception.Message)\"\n                }\n            }\n        }\n    } catch {\n        $Result.Actions += \"AD module not available - cannot lock accounts programmatically\"\n    }\n\n    # Block high-volume external source IPs via Windows Firewall\n    $InternalPrefixes = @(\"10.\", \"172.16.\", \"172.17.\", \"172.18.\", \"172.19.\", \"172.20.\", \"172.21.\",\n                          \"172.22.\", \"172.23.\", \"172.24.\", \"172.25.\", \"172.26.\", \"172.27.\",\n                          \"172.28.\", \"172.29.\", \"172.30.\", \"172.31.\", \"192.168.\", \"169.254.\")\n\n    foreach ($Entry in $BySourceIP.GetEnumerator()) {\n        if ($Entry.Value -gt 20) {\n            $IP = $Entry.Key\n            $IsInternal = $false\n            foreach ($Prefix in $InternalPrefixes) {\n                if ($IP.StartsWith($Prefix)) { $IsInternal = $true; break }\n            }\n\n            if (-not $IsInternal) {\n                # Block external IP via firewall\n                $RuleName = \"Block-BruteForce-$($IP -replace '\\.', '-')\"\n                $ExistingRule = Get-NetFirewallRule -DisplayName $RuleName -ErrorAction SilentlyContinue\n                if (-not $ExistingRule) {\n                    New-NetFirewallRule -DisplayName $RuleName -Direction Inbound -Action Block `\n                        -RemoteAddress $IP -Protocol Any -Description \"Auto-blocked: $($Entry.Value) failed logons in 24h\" | Out-Null\n                    $Result.Actions += \"Blocked external IP $IP ($($Entry.Value) failed attempts)\"\n                } else {\n                    $Result.Actions += \"Firewall rule already exists for $IP\"\n                }\n            } else {\n                $Result.Actions += \"ALERT: Internal IP $IP has $($Entry.Value) failed attempts - investigate manually\"\n            }\n        }\n    }\n\n    # Generate incident report\n    $Report = @{\n        Timestamp = (Get-Date).ToUniversalTime().ToString(\"o\")\n        TotalFailedLogons = @($FailedEvents).Count\n        AccountsExceedingThreshold = @($ByAccount.GetEnumerator() | Where-Object { $_.Value -gt 10 } | ForEach-Object { $_.Key })\n        HighVolumeSourceIPs = @($BySourceIP.GetEnumerator() | Where-Object { $_.Value -gt 20 } | ForEach-Object { @{ IP = $_.Key; Count = $_.Value } })\n    }\n    $Result.IncidentReport = $Report\n    $Result.Success = $true\n    $Result.Message = \"Failed login monitoring actions completed\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 4",
    "verify_script": "# Re-check failure counts and confirm lockouts applied\ntry {\n    $CutoffTime = (Get-Date).AddHours(-1)\n\n    # Check for very recent failures (post-remediation)\n    $RecentFailures = @(Get-WinEvent -FilterHashtable @{\n        LogName = 'Security'\n        Id = 4625\n        StartTime = $CutoffTime\n    } -ErrorAction SilentlyContinue)\n\n    # Check locked/disabled accounts\n    $LockedCount = 0\n    try {\n        Import-Module ActiveDirectory -ErrorAction Stop\n        $LockedCount = @(Search-ADAccount -LockedOut -ErrorAction Stop).Count\n    } catch { }\n\n    # Verify firewall rules were created\n    $BlockRules = @(Get-NetFirewallRule -DisplayName \"Block-BruteForce-*\" -ErrorAction SilentlyContinue)\n\n    @{\n        RecentFailuresLastHour = $RecentFailures.Count\n        LockedAccountCount = $LockedCount\n        FirewallBlockRules = $BlockRules.Count\n        Compliant = ($RecentFailures.Count -lt 10)\n    } | ConvertTo-Json\n} catch {\n    @{ Compliant = $false; Error = $_.Exception.Message } | ConvertTo-Json\n}",
    "hipaa_controls": [
      "164.312(b)",
      "164.308(a)(1)(ii)(D)",
      "164.312(a)(1)"
    ],
    "severity": "high",
    "timeout_seconds": 300
  },
  "RB-WIN-ACCESS-004": {
    "id": "RB-WIN-ACCESS-004",
    "name": "Guest WiFi Isolation Verification",
    "platform": "windows",
    "detect_script": "# Enumerate wireless profiles and test guest network isolation\n$Result = @{\n    Drifted = $false\n    Issues = @()\n    WirelessProfiles = @()\n    IsolationTests = @()\n}\n\ntry {\n    # Enumerate all wireless profiles\n    $ProfilesRaw = netsh wlan show profiles 2>&1\n    $ProfileNames = @()\n\n    foreach ($Line in $ProfilesRaw) {\n        if ($Line -match \"All User Profile\\s*:\\s*(.+)$\") {\n            $ProfileNames += $Matches[1].Trim()\n        }\n    }\n\n    $Result.TotalProfiles = $ProfileNames.Count\n\n    # Classify profiles as guest/public or internal\n    $GuestKeywords = @(\"guest\", \"public\", \"visitor\", \"patient\", \"lobby\", \"waiting\")\n    $GuestProfiles = @()\n    $InternalProfiles = @()\n\n    foreach ($ProfileName in $ProfileNames) {\n        $IsGuest = $false\n        foreach ($Keyword in $GuestKeywords) {\n            if ($ProfileName -like \"*$Keyword*\") {\n                $IsGuest = $true\n                break\n            }\n        }\n\n        # Get profile details\n        $ProfileDetail = netsh wlan show profile name=\"$ProfileName\" 2>&1\n        $Authentication = ($ProfileDetail | Select-String \"Authentication\\s*:\\s*(.+)$\" | Select-Object -First 1)\n        $AuthType = if ($Authentication) { ($Authentication -split \":\\s*\")[1].Trim() } else { \"Unknown\" }\n\n        $ProfileInfo = @{\n            Name = $ProfileName\n            IsGuest = $IsGuest\n            Authentication = $AuthType\n        }\n\n        $Result.WirelessProfiles += $ProfileInfo\n\n        if ($IsGuest) {\n            $GuestProfiles += $ProfileName\n        } else {\n            $InternalProfiles += $ProfileName\n        }\n    }\n\n    $Result.GuestProfiles = $GuestProfiles\n    $Result.InternalProfiles = $InternalProfiles\n\n    if ($GuestProfiles.Count -eq 0) {\n        $Result.Note = \"No guest/public wireless profiles detected on this machine\"\n        $Result | ConvertTo-Json -Depth 3\n        return\n    }\n\n    # Get current connection info\n    $CurrentConnection = netsh wlan show interfaces 2>&1\n    $ConnectedSSID = ($CurrentConnection | Select-String \"SSID\\s*:\\s*(.+)$\" | Select-Object -First 1)\n    $CurrentSSID = if ($ConnectedSSID) { ($ConnectedSSID -split \":\\s*\")[1].Trim() } else { $null }\n    $Result.CurrentSSID = $CurrentSSID\n\n    # Define internal resources to test isolation against\n    # These should be ePHI-relevant targets\n    $InternalTargets = @()\n\n    # Try to find DC\n    try {\n        $DC = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().DomainControllers[0]\n        $InternalTargets += @{ Name = \"DomainController\"; IP = $DC.IPAddress }\n    } catch { }\n\n    # Common internal subnets to test\n    $Gateway = (Get-NetRoute -DestinationPrefix \"0.0.0.0/0\" -ErrorAction SilentlyContinue).NextHop | Select-Object -First 1\n    if ($Gateway) {\n        $InternalTargets += @{ Name = \"DefaultGateway\"; IP = $Gateway }\n    }\n\n    # Try common EHR/file server ports on gateway subnet\n    if ($Gateway) {\n        $Subnet = ($Gateway -split '\\.')[0..2] -join '.'\n        # Test common server IPs\n        foreach ($LastOctet in @(1, 2, 5, 10, 100)) {\n            $TestIP = \"$Subnet.$LastOctet\"\n            if ($TestIP -ne $Gateway) {\n                $InternalTargets += @{ Name = \"InternalHost-$TestIP\"; IP = $TestIP }\n            }\n        }\n    }\n\n    # Test connectivity from current profile to internal resources\n    foreach ($Target in $InternalTargets) {\n        $TestResult = @{\n            Target = $Target.Name\n            IP = $Target.IP\n            Reachable = $false\n        }\n\n        $Ping = Test-Connection -ComputerName $Target.IP -Count 1 -Quiet -ErrorAction SilentlyContinue\n        $TestResult.Reachable = $Ping\n\n        # Test common ePHI ports (SMB 445, RDP 3389, HTTP 80/443, SQL 1433)\n        $PortTests = @()\n        foreach ($Port in @(445, 3389, 80, 443, 1433)) {\n            $TCPTest = New-Object System.Net.Sockets.TcpClient\n            try {\n                $AsyncResult = $TCPTest.BeginConnect($Target.IP, $Port, $null, $null)\n                $WaitResult = $AsyncResult.AsyncWaitHandle.WaitOne(1000, $false)\n                $PortOpen = $WaitResult -and $TCPTest.Connected\n                if ($PortOpen) {\n                    $PortTests += $Port\n                }\n            } catch { } finally {\n                $TCPTest.Close()\n            }\n        }\n        $TestResult.OpenPorts = $PortTests\n\n        $Result.IsolationTests += $TestResult\n\n        # If on guest network and can reach internal resources, that's a problem\n        $IsOnGuest = $false\n        foreach ($GP in $GuestProfiles) {\n            if ($CurrentSSID -and $CurrentSSID -like \"*$GP*\") {\n                $IsOnGuest = $true\n                break\n            }\n        }\n\n        if ($IsOnGuest -and ($Ping -or $PortTests.Count -gt 0)) {\n            $Result.Drifted = $true\n            $Result.Issues += \"Guest network can reach $($Target.Name) ($($Target.IP)) - ports: $($PortTests -join ', ')\"\n        }\n    }\n\n    $Result.IssueCount = $Result.Issues.Count\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Drifted = $true\n}\n\n$Result | ConvertTo-Json -Depth 4",
    "remediate_script": "# Guest WiFi isolation requires network-level fix - alert/escalate\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    $Result.Actions += \"ALERT: Guest WiFi isolation failure detected - this requires network infrastructure changes\"\n    $Result.Actions += \"ESCALATE: Network administrator must configure VLAN isolation between guest and internal networks\"\n\n    $Recommendations = @(\n        \"1. Verify guest SSID is on a separate VLAN from internal/ePHI networks\",\n        \"2. Configure ACLs on switch/router to block guest VLAN from reaching internal subnets\",\n        \"3. Ensure guest VLAN has no routes to ePHI VLAN (typically VLAN containing DC, file server, EHR)\",\n        \"4. Enable client isolation on the guest wireless network to prevent guest-to-guest attacks\",\n        \"5. Consider implementing a captive portal for guest network access logging\"\n    )\n    $Result.Recommendations = $Recommendations\n\n    # Remove any saved guest profiles from this machine if it's a workstation that should not connect to guest\n    $GuestKeywords = @(\"guest\", \"public\", \"visitor\", \"patient\", \"lobby\", \"waiting\")\n    $ProfilesRaw = netsh wlan show profiles 2>&1\n    foreach ($Line in $ProfilesRaw) {\n        if ($Line -match \"All User Profile\\s*:\\s*(.+)$\") {\n            $ProfileName = $Matches[1].Trim()\n            foreach ($Keyword in $GuestKeywords) {\n                if ($ProfileName -like \"*$Keyword*\") {\n                    netsh wlan delete profile name=\"$ProfileName\" | Out-Null\n                    $Result.Actions += \"Removed guest WiFi profile '$ProfileName' from this workstation\"\n                    break\n                }\n            }\n        }\n    }\n\n    $Result.Success = $true\n    $Result.Message = \"Escalation generated for network isolation fix; guest profiles removed from workstation\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "verify_script": "# Re-test guest isolation\ntry {\n    # Check if guest profiles still exist\n    $ProfilesRaw = netsh wlan show profiles 2>&1\n    $GuestKeywords = @(\"guest\", \"public\", \"visitor\", \"patient\", \"lobby\", \"waiting\")\n    $GuestProfileCount = 0\n\n    foreach ($Line in $ProfilesRaw) {\n        if ($Line -match \"All User Profile\\s*:\\s*(.+)$\") {\n            $ProfileName = $Matches[1].Trim()\n            foreach ($Keyword in $GuestKeywords) {\n                if ($ProfileName -like \"*$Keyword*\") {\n                    $GuestProfileCount++\n                    break\n                }\n            }\n        }\n    }\n\n    # Test connectivity to gateway from current network\n    $Gateway = (Get-NetRoute -DestinationPrefix \"0.0.0.0/0\" -ErrorAction SilentlyContinue).NextHop | Select-Object -First 1\n    $GatewayReachable = if ($Gateway) { Test-Connection -ComputerName $Gateway -Count 1 -Quiet -ErrorAction SilentlyContinue } else { $false }\n\n    @{\n        GuestProfilesRemaining = $GuestProfileCount\n        GatewayReachable = $GatewayReachable\n        Compliant = ($GuestProfileCount -eq 0)\n    } | ConvertTo-Json\n} catch {\n    @{ Compliant = $false; Error = $_.Exception.Message } | ConvertTo-Json\n}",
    "hipaa_controls": [
      "164.312(a)(1)",
      "164.312(e)(1)"
    ],
    "severity": "high",
    "timeout_seconds": 300
  },
  "RB-WIN-ACCESS-002": {
    "id": "RB-WIN-ACCESS-002",
    "name": "MFA Enforcement Audit",
    "platform": "windows",
    "detect_script": "# Check MFA enforcement status across all available mechanisms\n$Result = @{\n    Drifted = $false\n    Issues = @()\n    MFAMethods = @{}\n}\n\ntry {\n    # --- Check Azure AD / Entra ID hybrid join status ---\n    $DSRegStatus = dsregcmd /status 2>&1\n    $AzureADJoined = ($DSRegStatus | Select-String \"AzureAdJoined\\s*:\\s*YES\") -ne $null\n    $DomainJoined = ($DSRegStatus | Select-String \"DomainJoined\\s*:\\s*YES\") -ne $null\n    $Result.AzureADJoined = $AzureADJoined\n    $Result.DomainJoined = $DomainJoined\n\n    if ($AzureADJoined) {\n        # Check Conditional Access policy markers in registry\n        $CAKey = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Authentication\\LogonUI\"\n        $LastLogonMFA = (Get-ItemProperty -Path $CAKey -Name \"LastLoggedOnProvider\" -ErrorAction SilentlyContinue).LastLoggedOnProvider\n\n        # Check if Azure MFA NPS Extension is installed (for RADIUS integration)\n        $NFSExtension = Get-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\" -ErrorAction SilentlyContinue |\n            Where-Object { $_.DisplayName -like \"*NPS Extension for Azure*\" -or $_.DisplayName -like \"*Azure MFA*\" }\n        $Result.MFAMethods.AzureMFANPSExtension = ($null -ne $NFSExtension)\n\n        # Check for Conditional Access compliance via Intune registry key\n        $IntuneKey = \"HKLM:\\SOFTWARE\\Microsoft\\Enrollments\"\n        $IntuneEnrolled = (Get-ChildItem $IntuneKey -ErrorAction SilentlyContinue | Measure-Object).Count -gt 0\n        $Result.MFAMethods.IntuneManaged = $IntuneEnrolled\n\n        if (-not $NFSExtension -and -not $IntuneEnrolled) {\n            $Result.Issues += \"Azure AD joined but no Conditional Access / MFA enforcement detected\"\n            $Result.Drifted = $true\n        }\n    }\n\n    # --- On-prem only: Check smart card requirement ---\n    if ($DomainJoined -and -not $AzureADJoined) {\n        # Check if smart card logon is required via GPO\n        $SCKey = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\"\n        $SCForceOption = (Get-ItemProperty -Path $SCKey -Name \"scforceoption\" -ErrorAction SilentlyContinue).scforceoption\n        $Result.MFAMethods.SmartCardRequired = ($SCForceOption -eq 1)\n\n        # Check if RADIUS/NPS is configured\n        $NPSService = Get-Service -Name \"IAS\" -ErrorAction SilentlyContinue\n        $Result.MFAMethods.RADIUSAvailable = ($null -ne $NPSService -and $NPSService.Status -eq \"Running\")\n\n        if ($SCForceOption -ne 1 -and ($null -eq $NPSService -or $NPSService.Status -ne \"Running\")) {\n            $Result.Issues += \"On-prem only: No smart card or RADIUS MFA enforcement detected\"\n            $Result.Drifted = $true\n        }\n    }\n\n    # --- Check Windows Hello for Business ---\n    $WHfBKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\PassportForWork\"\n    $WHfBEnabled = (Get-ItemProperty -Path $WHfBKey -Name \"Enabled\" -ErrorAction SilentlyContinue).Enabled\n    $Result.MFAMethods.WindowsHelloEnabled = ($WHfBEnabled -eq 1)\n\n    # Check if any user has enrolled Windows Hello\n    $WHfBUserKey = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Authentication\\Credential Providers\\{D6886603-9D2F-4EB2-B667-1971041FA96B}\"\n    $WHfBProviderEnabled = (Get-ItemProperty -Path $WHfBUserKey -Name \"Disabled\" -ErrorAction SilentlyContinue).Disabled\n    $Result.MFAMethods.WindowsHelloProviderActive = ($WHfBProviderEnabled -ne 1)\n\n    # --- Check RDP requires NLA (Network Level Authentication) ---\n    $RDPKey = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\"\n    $NLARequired = (Get-ItemProperty -Path $RDPKey -Name \"UserAuthentication\" -ErrorAction SilentlyContinue).UserAuthentication\n    $Result.MFAMethods.NLAEnabled = ($NLARequired -eq 1)\n\n    # Also check via policy\n    $NLAPolicyKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\Terminal Services\"\n    $NLAPolicy = (Get-ItemProperty -Path $NLAPolicyKey -Name \"UserAuthentication\" -ErrorAction SilentlyContinue).UserAuthentication\n    if ($null -ne $NLAPolicy) {\n        $Result.MFAMethods.NLAPolicy = ($NLAPolicy -eq 1)\n    }\n\n    if ($NLARequired -ne 1) {\n        $Result.Issues += \"RDP Network Level Authentication (NLA) is not enabled\"\n        $Result.Drifted = $true\n    }\n\n    # --- Check if RDP is enabled at all ---\n    $RDPEnabled = (Get-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\" -Name \"fDenyTSConnections\" -ErrorAction SilentlyContinue).fDenyTSConnections\n    $Result.RDPEnabled = ($RDPEnabled -eq 0)\n\n    # Summary\n    $Result.IssueCount = $Result.Issues.Count\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Drifted = $true\n}\n\n$Result | ConvertTo-Json -Depth 3",
    "remediate_script": "# Remediate MFA enforcement gaps\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # Enable NLA for RDP\n    $RDPKey = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\"\n    $CurrentNLA = (Get-ItemProperty -Path $RDPKey -Name \"UserAuthentication\" -ErrorAction SilentlyContinue).UserAuthentication\n    if ($CurrentNLA -ne 1) {\n        Set-ItemProperty -Path $RDPKey -Name \"UserAuthentication\" -Value 1 -Type DWord\n        $Result.Actions += \"Enabled Network Level Authentication (NLA) for RDP\"\n    } else {\n        $Result.Actions += \"NLA already enabled for RDP\"\n    }\n\n    # Configure Windows Hello for Business policy via registry\n    $WHfBKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\PassportForWork\"\n    if (-not (Test-Path $WHfBKey)) {\n        New-Item -Path $WHfBKey -Force | Out-Null\n    }\n    $CurrentWHfB = (Get-ItemProperty -Path $WHfBKey -Name \"Enabled\" -ErrorAction SilentlyContinue).Enabled\n    if ($CurrentWHfB -ne 1) {\n        Set-ItemProperty -Path $WHfBKey -Name \"Enabled\" -Value 1 -Type DWord\n        $Result.Actions += \"Enabled Windows Hello for Business policy\"\n    } else {\n        $Result.Actions += \"Windows Hello for Business policy already enabled\"\n    }\n\n    # Set Windows Hello minimum PIN length\n    $WHfBPinKey = \"$WHfBKey\\PINComplexity\"\n    if (-not (Test-Path $WHfBPinKey)) {\n        New-Item -Path $WHfBPinKey -Force | Out-Null\n    }\n    Set-ItemProperty -Path $WHfBPinKey -Name \"MinimumPINLength\" -Value 6 -Type DWord\n    $Result.Actions += \"Set Windows Hello minimum PIN length to 6\"\n\n    # Check Azure/Entra MFA gaps - alert only (cannot auto-configure Conditional Access)\n    $DSRegStatus = dsregcmd /status 2>&1\n    $AzureADJoined = ($DSRegStatus | Select-String \"AzureAdJoined\\s*:\\s*YES\") -ne $null\n\n    if ($AzureADJoined) {\n        $NFSExtension = Get-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\" -ErrorAction SilentlyContinue |\n            Where-Object { $_.DisplayName -like \"*NPS Extension for Azure*\" -or $_.DisplayName -like \"*Azure MFA*\" }\n        if (-not $NFSExtension) {\n            $Result.Actions += \"ALERT: Azure AD joined but no MFA NPS extension found - configure Conditional Access in Entra portal\"\n        }\n    }\n\n    # Check on-prem MFA gaps - alert only\n    $DomainJoined = ($DSRegStatus | Select-String \"DomainJoined\\s*:\\s*YES\") -ne $null\n    if ($DomainJoined -and -not $AzureADJoined) {\n        $SCKey = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\"\n        $SCForceOption = (Get-ItemProperty -Path $SCKey -Name \"scforceoption\" -ErrorAction SilentlyContinue).scforceoption\n        if ($SCForceOption -ne 1) {\n            $Result.Actions += \"ALERT: On-prem domain - consider enabling smart card requirement or deploying RADIUS MFA\"\n        }\n    }\n\n    $Result.Success = $true\n    $Result.Message = \"MFA enforcement remediation applied where possible; alerts generated for cloud-managed gaps\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "verify_script": "# Re-check MFA enforcement status\ntry {\n    # Verify NLA\n    $RDPKey = \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\"\n    $NLAEnabled = (Get-ItemProperty -Path $RDPKey -Name \"UserAuthentication\" -ErrorAction SilentlyContinue).UserAuthentication -eq 1\n\n    # Verify Windows Hello policy\n    $WHfBKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\PassportForWork\"\n    $WHfBEnabled = (Get-ItemProperty -Path $WHfBKey -Name \"Enabled\" -ErrorAction SilentlyContinue).Enabled -eq 1\n\n    # Check Azure/Entra status\n    $DSRegStatus = dsregcmd /status 2>&1\n    $AzureADJoined = ($DSRegStatus | Select-String \"AzureAdJoined\\s*:\\s*YES\") -ne $null\n\n    @{\n        NLAEnabled = $NLAEnabled\n        WindowsHelloEnabled = $WHfBEnabled\n        AzureADJoined = $AzureADJoined\n        Compliant = ($NLAEnabled -and $WHfBEnabled)\n    } | ConvertTo-Json\n} catch {\n    @{ Compliant = $false; Error = $_.Exception.Message } | ConvertTo-Json\n}",
    "hipaa_controls": [
      "164.312(d)",
      "164.312(a)(2)(i)"
    ],
    "severity": "high",
    "timeout_seconds": 180
  },
  "RB-WIN-ACCESS-005": {
    "id": "RB-WIN-ACCESS-005",
    "name": "USB/Removable Media Device Enumeration",
    "platform": "windows",
    "detect_script": "# Query for removable media devices and USB history\n$Result = @{\n    Drifted = $false\n    Issues = @()\n    CurrentDevices = @()\n    RecentUSBHistory = @()\n    PolicyStatus = @{}\n}\n\ntry {\n    # --- Query currently connected removable drives ---\n    $RemovableDrives = Get-WmiObject Win32_DiskDrive | Where-Object { $_.MediaType -like \"*removable*\" -or $_.InterfaceType -eq \"USB\" }\n\n    foreach ($Drive in $RemovableDrives) {\n        $DriveInfo = @{\n            DeviceID = $Drive.DeviceID\n            Model = $Drive.Model\n            InterfaceType = $Drive.InterfaceType\n            MediaType = $Drive.MediaType\n            Size = if ($Drive.Size) { [math]::Round($Drive.Size / 1GB, 2) } else { 0 }\n            SerialNumber = $Drive.SerialNumber\n            PNPDeviceID = $Drive.PNPDeviceID\n        }\n        $Result.CurrentDevices += $DriveInfo\n    }\n\n    $Result.CurrentRemovableDeviceCount = @($RemovableDrives).Count\n\n    # --- Check event log for USB device connections (Event ID 6416 - external device recognized) ---\n    $CutoffTime = (Get-Date).AddDays(-30)\n\n    # Event ID 6416: A new external device was recognized by the system\n    $USBEvents = Get-WinEvent -FilterHashtable @{\n        LogName = 'Security'\n        Id = 6416\n        StartTime = $CutoffTime\n    } -MaxEvents 100 -ErrorAction SilentlyContinue\n\n    foreach ($Event in $USBEvents) {\n        $Xml = [xml]$Event.ToXml()\n        $DeviceName = ($Xml.Event.EventData.Data | Where-Object { $_.Name -eq \"DeviceDescription\" }).'#text'\n        $DeviceId = ($Xml.Event.EventData.Data | Where-Object { $_.Name -eq \"DeviceId\" }).'#text'\n        $ClassName = ($Xml.Event.EventData.Data | Where-Object { $_.Name -eq \"ClassName\" }).'#text'\n\n        $Result.RecentUSBHistory += @{\n            Timestamp = $Event.TimeCreated.ToString(\"o\")\n            DeviceName = $DeviceName\n            DeviceId = $DeviceId\n            ClassName = $ClassName\n        }\n    }\n\n    $Result.USBEventsLast30Days = @($USBEvents).Count\n\n    # Also check PnP events (Event ID 20001, 20003 for device install)\n    $PnPEvents = Get-WinEvent -FilterHashtable @{\n        LogName = 'System'\n        ProviderName = 'Microsoft-Windows-UserPnp'\n        StartTime = $CutoffTime\n    } -MaxEvents 50 -ErrorAction SilentlyContinue\n\n    # Check USB storage device registry history\n    $USBSTORKey = \"HKLM:\\SYSTEM\\CurrentControlSet\\Enum\\USBSTOR\"\n    $USBHistory = @()\n    if (Test-Path $USBSTORKey) {\n        $USBDevices = Get-ChildItem $USBSTORKey -ErrorAction SilentlyContinue\n        foreach ($Device in $USBDevices) {\n            $SubKeys = Get-ChildItem $Device.PSPath -ErrorAction SilentlyContinue\n            foreach ($SubKey in $SubKeys) {\n                $Props = Get-ItemProperty $SubKey.PSPath -ErrorAction SilentlyContinue\n                $USBHistory += @{\n                    DeviceDesc = $Props.DeviceDesc\n                    FriendlyName = $Props.FriendlyName\n                    HardwareID = $Props.HardwareID | Select-Object -First 1\n                    RegistryPath = $SubKey.PSPath -replace 'Microsoft.PowerShell.Core\\\\Registry::', ''\n                }\n            }\n        }\n    }\n    $Result.USBStorageHistoryCount = $USBHistory.Count\n    $Result.USBStorageHistory = $USBHistory | Select-Object -First 20\n\n    # --- Check Group Policy for USB restrictions ---\n    # RemovableStorageDevices policy keys\n    $GPUSBKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\RemovableStorageDevices\"\n\n    # Check read deny\n    $DenyReadKey = \"$GPUSBKey\\{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}\"\n    $DenyRead = (Get-ItemProperty -Path $DenyReadKey -Name \"Deny_Read\" -ErrorAction SilentlyContinue).Deny_Read\n    $Result.PolicyStatus.DenyUSBRead = ($DenyRead -eq 1)\n\n    # Check write deny\n    $DenyWriteKey = \"$GPUSBKey\\{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}\"\n    $DenyWrite = (Get-ItemProperty -Path $DenyWriteKey -Name \"Deny_Write\" -ErrorAction SilentlyContinue).Deny_Write\n    $Result.PolicyStatus.DenyUSBWrite = ($DenyWrite -eq 1)\n\n    # Check all removable storage deny\n    $DenyAllKey = \"$GPUSBKey\\{53f56307-b6bf-11d0-94f2-00a0c91efb8b}\"\n    $DenyAllRead = (Get-ItemProperty -Path $DenyAllKey -Name \"Deny_Read\" -ErrorAction SilentlyContinue).Deny_Read\n    $DenyAllWrite = (Get-ItemProperty -Path $DenyAllKey -Name \"Deny_Write\" -ErrorAction SilentlyContinue).Deny_Write\n    $Result.PolicyStatus.DenyAllRemovableRead = ($DenyAllRead -eq 1)\n    $Result.PolicyStatus.DenyAllRemovableWrite = ($DenyAllWrite -eq 1)\n\n    # Check device installation restrictions\n    $DeviceInstallKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\DeviceInstall\\Restrictions\"\n    $DenyInstall = (Get-ItemProperty -Path $DeviceInstallKey -Name \"DenyDeviceClasses\" -ErrorAction SilentlyContinue).DenyDeviceClasses\n    $Result.PolicyStatus.DeviceInstallRestricted = ($null -ne $DenyInstall)\n\n    # Determine drift status\n    $NoUSBPolicy = (-not $Result.PolicyStatus.DenyUSBWrite) -and\n                   (-not $Result.PolicyStatus.DenyAllRemovableWrite) -and\n                   (-not $Result.PolicyStatus.DeviceInstallRestricted)\n\n    if ($NoUSBPolicy) {\n        $Result.Drifted = $true\n        $Result.Issues += \"No USB/removable media restriction policy is configured\"\n    }\n\n    if (@($RemovableDrives).Count -gt 0 -and $NoUSBPolicy) {\n        $Result.Issues += \"$(@($RemovableDrives).Count) removable device(s) currently connected with no restriction policy\"\n    }\n\n    $Result.IssueCount = $Result.Issues.Count\n} catch {\n    $Result.Error = $_.Exception.Message\n    $Result.Drifted = $true\n}\n\n$Result | ConvertTo-Json -Depth 4",
    "remediate_script": "# Apply USB restriction GPO settings and alert on unauthorized device history\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # Apply USB write restriction via registry (equivalent to GPO setting)\n    $GPUSBKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\RemovableStorageDevices\"\n\n    # Deny write to removable storage (disk drives)\n    $DiskDriveKey = \"$GPUSBKey\\{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}\"\n    if (-not (Test-Path $DiskDriveKey)) {\n        New-Item -Path $DiskDriveKey -Force | Out-Null\n    }\n    Set-ItemProperty -Path $DiskDriveKey -Name \"Deny_Write\" -Value 1 -Type DWord\n    $Result.Actions += \"Enabled USB storage write deny policy\"\n\n    # Deny write to all removable storage\n    $AllRemovableKey = \"$GPUSBKey\\{53f56307-b6bf-11d0-94f2-00a0c91efb8b}\"\n    if (-not (Test-Path $AllRemovableKey)) {\n        New-Item -Path $AllRemovableKey -Force | Out-Null\n    }\n    Set-ItemProperty -Path $AllRemovableKey -Name \"Deny_Write\" -Value 1 -Type DWord\n    $Result.Actions += \"Enabled all removable storage write deny policy\"\n\n    # Deny write to WPD devices (phones, cameras)\n    $WPDKey = \"$GPUSBKey\\{6AC27878-A6FA-4155-BA85-F98F491D4F33}\"\n    if (-not (Test-Path $WPDKey)) {\n        New-Item -Path $WPDKey -Force | Out-Null\n    }\n    Set-ItemProperty -Path $WPDKey -Name \"Deny_Write\" -Value 1 -Type DWord\n    $Result.Actions += \"Enabled WPD (portable device) write deny policy\"\n\n    # Enable auditing for removable storage\n    $AuditKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\RemovableStorageDevices\"\n    if (-not (Test-Path $AuditKey)) {\n        New-Item -Path $AuditKey -Force | Out-Null\n    }\n    # Enable audit for removable storage access\n    auditpol /set /subcategory:\"Removable Storage\" /success:enable /failure:enable 2>&1 | Out-Null\n    $Result.Actions += \"Enabled audit policy for removable storage access\"\n\n    # Alert on recent unauthorized USB history\n    $USBSTORKey = \"HKLM:\\SYSTEM\\CurrentControlSet\\Enum\\USBSTOR\"\n    if (Test-Path $USBSTORKey) {\n        $DeviceCount = (Get-ChildItem $USBSTORKey -ErrorAction SilentlyContinue | Measure-Object).Count\n        if ($DeviceCount -gt 0) {\n            $Result.Actions += \"ALERT: $DeviceCount USB storage device(s) found in device history - review for unauthorized access\"\n        }\n    }\n\n    $Result.Success = $true\n    $Result.Message = \"USB restriction policies applied and auditing enabled\"\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "verify_script": "# Confirm USB policy applied and check for new connections\ntry {\n    # Verify write deny policies\n    $GPUSBKey = \"HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\RemovableStorageDevices\"\n    $DiskDriveKey = \"$GPUSBKey\\{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}\"\n    $AllRemovableKey = \"$GPUSBKey\\{53f56307-b6bf-11d0-94f2-00a0c91efb8b}\"\n\n    $DiskWriteDenied = (Get-ItemProperty -Path $DiskDriveKey -Name \"Deny_Write\" -ErrorAction SilentlyContinue).Deny_Write -eq 1\n    $AllWriteDenied = (Get-ItemProperty -Path $AllRemovableKey -Name \"Deny_Write\" -ErrorAction SilentlyContinue).Deny_Write -eq 1\n\n    # Check for currently connected removable devices\n    $CurrentRemovable = @(Get-WmiObject Win32_DiskDrive | Where-Object {\n        $_.MediaType -like \"*removable*\" -or $_.InterfaceType -eq \"USB\"\n    })\n\n    # Check audit policy\n    $AuditOutput = auditpol /get /subcategory:\"Removable Storage\" 2>&1\n    $AuditEnabled = ($AuditOutput | Select-String \"Success and Failure|Success|Failure\") -ne $null\n\n    @{\n        USBWriteDenyPolicy = $DiskWriteDenied\n        AllRemovableWriteDeny = $AllWriteDenied\n        CurrentRemovableDevices = $CurrentRemovable.Count\n        AuditEnabled = $AuditEnabled\n        Compliant = ($DiskWriteDenied -and $AllWriteDenied)\n    } | ConvertTo-Json\n} catch {\n    @{ Compliant = $false; Error = $_.Exception.Message } | ConvertTo-Json\n}",
    "hipaa_controls": [
      "164.312(a)(2)(i)",
      "164.310(d)(1)"
    ],
    "severity": "medium",
    "timeout_seconds": 180
  },
  "RB-WIN-DEVICE-003": {
    "id": "RB-WIN-DEVICE-003",
    "name": "Default Credential Scanner",
    "platform": "windows",
    "detect_script": "# Check for common default credentials on network services\n# NOTE: This only tests WELL-KNOWN defaults, NOT brute force\n$ErrorActionPreference = \"SilentlyContinue\"\n$Result = @{\n    Drifted = $false\n    Findings = @()\n    ServicesChecked = 0\n    DefaultCredsFound = 0\n    ScanTimestamp = (Get-Date).ToUniversalTime().ToString(\"o\")\n}\n\n$IPConfig = Get-NetIPAddress -AddressFamily IPv4 |\n    Where-Object { $_.PrefixOrigin -ne \"WellKnown\" -and $_.IPAddress -ne \"127.0.0.1\" } |\n    Select-Object -First 1\n\n$Subnet = ($IPConfig.IPAddress -split '\\.')[0..2] -join '.'\n$LocalIP = $IPConfig.IPAddress\n\n# ---- 1. SNMP Default Community Strings ----\n$ArpEntries = Get-NetNeighbor -AddressFamily IPv4 |\n    Where-Object { $_.State -ne \"Unreachable\" -and $_.IPAddress -like \"$Subnet.*\" }\n\nforeach ($Entry in $ArpEntries) {\n    $IP = $Entry.IPAddress\n    if ($IP -eq $LocalIP) { continue }\n\n    $Result.ServicesChecked++\n\n    try {\n        $UdpClient = New-Object System.Net.Sockets.UdpClient\n        $UdpClient.Client.ReceiveTimeout = 1500\n\n        # SNMP v1 GET with community 'public'\n        $SNMPPacket = [byte[]](\n            0x30, 0x26, 0x02, 0x01, 0x00, 0x04, 0x06, 0x70,\n            0x75, 0x62, 0x6C, 0x69, 0x63, 0xA0, 0x19, 0x02,\n            0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x01, 0x00,\n            0x02, 0x01, 0x00, 0x30, 0x0B, 0x30, 0x09, 0x06,\n            0x05, 0x2B, 0x06, 0x01, 0x02, 0x01, 0x05, 0x00\n        )\n\n        $Endpoint = New-Object System.Net.IPEndPoint([System.Net.IPAddress]::Parse($IP), 161)\n        $UdpClient.Send($SNMPPacket, $SNMPPacket.Length, $Endpoint) | Out-Null\n        $RemoteEP = New-Object System.Net.IPEndPoint([System.Net.IPAddress]::Any, 0)\n\n        try {\n            $Response = $UdpClient.Receive([ref]$RemoteEP)\n            if ($Response.Length -gt 0) {\n                $Result.Findings += @{\n                    Type = \"SNMP\"\n                    IPAddress = $IP\n                    Credential = \"public (community string)\"\n                    Severity = \"HIGH\"\n                    Risk = \"Read access to device configuration via SNMP\"\n                }\n                $Result.DefaultCredsFound++\n                $Result.Drifted = $true\n            }\n        } catch {\n            # Timeout = no default community string (good)\n        }\n\n        $UdpClient.Close()\n    } catch {\n        # Connection error\n    }\n}\n\n# ---- 2. SQL Server SA Default Password ----\n# Check if SQL Server is running locally or on known hosts\n$SQLInstances = @($LocalIP)\n\n# Check local SQL Server instances\n$SQLServices = Get-Service -Name \"MSSQL*\" -ErrorAction SilentlyContinue |\n    Where-Object { $_.Status -eq \"Running\" }\n\nif ($SQLServices) {\n    $Result.ServicesChecked++\n\n    try {\n        # Test SA account with common defaults\n        $DefaultPasswords = @(\"\", \"sa\", \"password\", \"Password1\", \"SQL2019\", \"SQL2022\")\n\n        foreach ($Password in $DefaultPasswords) {\n            $ConnectionString = \"Server=localhost;User Id=sa;Password=$Password;Connection Timeout=3;\"\n            $SqlConnection = New-Object System.Data.SqlClient.SqlConnection($ConnectionString)\n\n            try {\n                $SqlConnection.Open()\n\n                if ($SqlConnection.State -eq \"Open\") {\n                    $PasswordDisplay = if ($Password -eq \"\") { \"(empty)\" } else { \"(default known password)\" }\n                    $Result.Findings += @{\n                        Type = \"SQL Server\"\n                        IPAddress = $LocalIP\n                        Credential = \"SA account with default password $PasswordDisplay\"\n                        Severity = \"CRITICAL\"\n                        Risk = \"Full database access including PHI data\"\n                    }\n                    $Result.DefaultCredsFound++\n                    $Result.Drifted = $true\n                    $SqlConnection.Close()\n                    break\n                }\n            } catch {\n                # Login failed = not default (good)\n            } finally {\n                if ($SqlConnection.State -eq \"Open\") { $SqlConnection.Close() }\n            }\n        }\n    } catch {\n        # SQL connection test failed\n    }\n}\n\n# ---- 3. Printer Web UI Default Credentials ----\n# Check common printer admin ports\nforeach ($Entry in $ArpEntries) {\n    $IP = $Entry.IPAddress\n    $PrinterTest = Test-NetConnection -ComputerName $IP -Port 80 -WarningAction SilentlyContinue -InformationLevel Quiet\n    if (-not $PrinterTest) { continue }\n\n    # Also check if it has printer port open (to confirm it's a printer)\n    $Is9100 = Test-NetConnection -ComputerName $IP -Port 9100 -WarningAction SilentlyContinue -InformationLevel Quiet\n    if (-not $Is9100) { continue }\n\n    $Result.ServicesChecked++\n\n    try {\n        # Try common default credentials via HTTP basic auth\n        $DefaultCreds = @(\n            @{ User = \"admin\"; Pass = \"admin\" },\n            @{ User = \"admin\"; Pass = \"\" },\n            @{ User = \"admin\"; Pass = \"password\" },\n            @{ User = \"admin\"; Pass = \"1234\" }\n        )\n\n        foreach ($Cred in $DefaultCreds) {\n            $Pair = \"$($Cred.User):$($Cred.Pass)\"\n            $EncodedAuth = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes($Pair))\n            $Headers = @{ Authorization = \"Basic $EncodedAuth\" }\n\n            try {\n                $WebResponse = Invoke-WebRequest -Uri \"http://$IP/\" -Headers $Headers -TimeoutSec 3 -UseBasicParsing\n                if ($WebResponse.StatusCode -eq 200 -and $WebResponse.Content -notmatch \"login|sign.in|unauthorized\") {\n                    $PassDisplay = if ($Cred.Pass -eq \"\") { \"(empty)\" } else { $Cred.Pass }\n                    $Result.Findings += @{\n                        Type = \"Printer Web UI\"\n                        IPAddress = $IP\n                        Credential = \"$($Cred.User) / $PassDisplay\"\n                        Severity = \"HIGH\"\n                        Risk = \"Printer admin access - can modify settings, access stored documents\"\n                    }\n                    $Result.DefaultCredsFound++\n                    $Result.Drifted = $true\n                    break\n                }\n            } catch {\n                # Auth failed = not default (good)\n            }\n        }\n    } catch {\n        # Web request failed\n    }\n}\n\n# ---- 4. IPMI Default Credentials ----\n# Check for IPMI/BMC on port 623 (UDP) and web on 80/443\nforeach ($Entry in $ArpEntries) {\n    $IP = $Entry.IPAddress\n\n    $IPMITest = Test-NetConnection -ComputerName $IP -Port 623 -WarningAction SilentlyContinue -InformationLevel Quiet\n    if (-not $IPMITest) { continue }\n\n    $Result.ServicesChecked++\n\n    # Try default IPMI web interface credentials\n    $IPMIDefaults = @(\n        @{ User = \"ADMIN\"; Pass = \"ADMIN\" },\n        @{ User = \"admin\"; Pass = \"admin\" },\n        @{ User = \"root\"; Pass = \"calvin\" },       # Dell iDRAC\n        @{ User = \"ADMIN\"; Pass = \"ADMIN\" },        # Supermicro\n        @{ User = \"Administrator\"; Pass = \"\" }       # HP iLO\n    )\n\n    foreach ($Cred in $IPMIDefaults) {\n        try {\n            $Pair = \"$($Cred.User):$($Cred.Pass)\"\n            $EncodedAuth = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes($Pair))\n            $Headers = @{ Authorization = \"Basic $EncodedAuth\" }\n\n            $WebResponse = Invoke-WebRequest -Uri \"https://$IP/\" -Headers $Headers -TimeoutSec 3 -UseBasicParsing -SkipCertificateCheck\n            if ($WebResponse.StatusCode -eq 200 -and $WebResponse.Content -notmatch \"login|sign.in\") {\n                $PassDisplay = if ($Cred.Pass -eq \"\") { \"(empty)\" } else { \"(default)\" }\n                $Result.Findings += @{\n                    Type = \"IPMI/BMC\"\n                    IPAddress = $IP\n                    Credential = \"$($Cred.User) / $PassDisplay\"\n                    Severity = \"CRITICAL\"\n                    Risk = \"Full hardware management - power control, console access, firmware flash\"\n                }\n                $Result.DefaultCredsFound++\n                $Result.Drifted = $true\n                break\n            }\n        } catch {\n            # Auth failed = not default (good)\n        }\n    }\n}\n\n$Result | ConvertTo-Json -Depth 3",
    "remediate_script": "# Remediate default credentials where possible, escalate otherwise\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # ---- Auto-remediate: SQL Server SA password ----\n    $SQLServices = Get-Service -Name \"MSSQL*\" -ErrorAction SilentlyContinue |\n        Where-Object { $_.Status -eq \"Running\" }\n\n    if ($SQLServices) {\n        $DefaultPasswords = @(\"\", \"sa\", \"password\", \"Password1\", \"SQL2019\", \"SQL2022\")\n\n        foreach ($Password in $DefaultPasswords) {\n            $ConnectionString = \"Server=localhost;User Id=sa;Password=$Password;Connection Timeout=3;\"\n            $SqlConnection = New-Object System.Data.SqlClient.SqlConnection($ConnectionString)\n\n            try {\n                $SqlConnection.Open()\n\n                if ($SqlConnection.State -eq \"Open\") {\n                    # Generate a strong random password\n                    Add-Type -AssemblyName System.Web\n                    $NewPassword = [System.Web.Security.Membership]::GeneratePassword(24, 6)\n\n                    $Command = $SqlConnection.CreateCommand()\n                    $Command.CommandText = \"ALTER LOGIN [sa] WITH PASSWORD = N'$NewPassword';\"\n                    $Command.ExecuteNonQuery() | Out-Null\n\n                    # Also disable SA if not needed\n                    $Command.CommandText = \"ALTER LOGIN [sa] DISABLE;\"\n                    $Command.ExecuteNonQuery() | Out-Null\n\n                    $Result.Actions += \"Changed SQL SA password and disabled SA login\"\n                    $Result.Actions += \"New SA password stored - requires secure documentation\"\n\n                    $SqlConnection.Close()\n                    break\n                }\n            } catch {\n                # Login failed with this password\n            } finally {\n                if ($SqlConnection.State -eq \"Open\") { $SqlConnection.Close() }\n            }\n        }\n    }\n\n    # ---- Escalate: Everything else requires manual remediation ----\n    $Result.Actions += \"ESCALATION: SNMP community strings must be changed on each device individually\"\n    $Result.Actions += \"ESCALATION: Printer admin passwords must be changed via device web UI\"\n    $Result.Actions += \"ESCALATION: IPMI/BMC credentials must be changed via hardware management interface\"\n\n    $Result.Success = $true\n    $Result.EscalationRequired = $true\n    $Result.Recommendations = @(\n        \"Change all SNMP community strings to unique complex values\",\n        \"Change all printer admin passwords to unique complex values\",\n        \"Change all IPMI/BMC default credentials immediately\",\n        \"Disable SA account on SQL Server instances\",\n        \"Implement network segmentation for management interfaces\",\n        \"Document all credential changes in password manager\"\n    )\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "verify_script": "# Re-test default credentials to confirm they have been changed\n$ErrorActionPreference = \"SilentlyContinue\"\n$Result = @{\n    Compliant = $true\n    ServicesChecked = 0\n    DefaultCredsRemaining = 0\n    Details = @()\n}\n\n$IPConfig = Get-NetIPAddress -AddressFamily IPv4 |\n    Where-Object { $_.PrefixOrigin -ne \"WellKnown\" -and $_.IPAddress -ne \"127.0.0.1\" } |\n    Select-Object -First 1\n\n$Subnet = ($IPConfig.IPAddress -split '\\.')[0..2] -join '.'\n$LocalIP = $IPConfig.IPAddress\n\n# Re-check SNMP defaults\n$ArpEntries = Get-NetNeighbor -AddressFamily IPv4 |\n    Where-Object { $_.State -ne \"Unreachable\" -and $_.IPAddress -like \"$Subnet.*\" }\n\nforeach ($Entry in $ArpEntries) {\n    $IP = $Entry.IPAddress\n    if ($IP -eq $LocalIP) { continue }\n\n    $Result.ServicesChecked++\n\n    try {\n        $UdpClient = New-Object System.Net.Sockets.UdpClient\n        $UdpClient.Client.ReceiveTimeout = 1500\n\n        $SNMPPacket = [byte[]](\n            0x30, 0x26, 0x02, 0x01, 0x00, 0x04, 0x06, 0x70,\n            0x75, 0x62, 0x6C, 0x69, 0x63, 0xA0, 0x19, 0x02,\n            0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x01, 0x00,\n            0x02, 0x01, 0x00, 0x30, 0x0B, 0x30, 0x09, 0x06,\n            0x05, 0x2B, 0x06, 0x01, 0x02, 0x01, 0x05, 0x00\n        )\n\n        $Endpoint = New-Object System.Net.IPEndPoint([System.Net.IPAddress]::Parse($IP), 161)\n        $UdpClient.Send($SNMPPacket, $SNMPPacket.Length, $Endpoint) | Out-Null\n        $RemoteEP = New-Object System.Net.IPEndPoint([System.Net.IPAddress]::Any, 0)\n\n        try {\n            $Response = $UdpClient.Receive([ref]$RemoteEP)\n            if ($Response.Length -gt 0) {\n                $Result.Compliant = $false\n                $Result.DefaultCredsRemaining++\n                $Result.Details += \"SNMP default 'public' still active on $IP\"\n            }\n        } catch { }\n\n        $UdpClient.Close()\n    } catch { }\n}\n\n# Re-check SQL SA\n$SQLServices = Get-Service -Name \"MSSQL*\" -ErrorAction SilentlyContinue |\n    Where-Object { $_.Status -eq \"Running\" }\n\nif ($SQLServices) {\n    $Result.ServicesChecked++\n    $DefaultPasswords = @(\"\", \"sa\", \"password\", \"Password1\")\n\n    foreach ($Password in $DefaultPasswords) {\n        try {\n            $Conn = New-Object System.Data.SqlClient.SqlConnection(\"Server=localhost;User Id=sa;Password=$Password;Connection Timeout=3;\")\n            $Conn.Open()\n            if ($Conn.State -eq \"Open\") {\n                $Result.Compliant = $false\n                $Result.DefaultCredsRemaining++\n                $Result.Details += \"SQL SA still has default password\"\n                $Conn.Close()\n                break\n            }\n        } catch { }\n    }\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "hipaa_controls": [
      "164.312(d)",
      "164.312(a)(1)"
    ],
    "severity": "critical",
    "timeout_seconds": 600
  },
  "RB-WIN-DEVICE-004": {
    "id": "RB-WIN-DEVICE-004",
    "name": "EDR/Antimalware Deployment Verification",
    "platform": "windows",
    "detect_script": "# Query AD for all domain computers and verify endpoint protection\n$ErrorActionPreference = \"SilentlyContinue\"\n$Result = @{\n    Drifted = $false\n    TotalEndpoints = 0\n    ProtectedEndpoints = 0\n    UnprotectedEndpoints = @()\n    EndpointDetails = @()\n    Issues = @()\n    ScanTimestamp = (Get-Date).ToUniversalTime().ToString(\"o\")\n}\n\n# Get list of all domain computers\n$Computers = @()\ntry {\n    Import-Module ActiveDirectory -ErrorAction Stop\n    $Computers = Get-ADComputer -Filter { Enabled -eq $true } -Properties OperatingSystem, LastLogonDate, DNSHostName |\n        Where-Object { $_.LastLogonDate -gt (Get-Date).AddDays(-30) } |\n        Select-Object Name, DNSHostName, OperatingSystem, LastLogonDate\n} catch {\n    # If AD not available, check local machine only\n    $Computers = @(@{\n        Name = $env:COMPUTERNAME\n        DNSHostName = \"$env:COMPUTERNAME.$env:USERDNSDOMAIN\"\n        OperatingSystem = (Get-WmiObject Win32_OperatingSystem).Caption\n        LastLogonDate = Get-Date\n    })\n}\n\n$Result.TotalEndpoints = $Computers.Count\n\n# Known AV/EDR product names to search for\n$AVProducts = @(\n    \"Windows Defender\",\n    \"Microsoft Defender\",\n    \"Symantec Endpoint Protection\",\n    \"Norton\",\n    \"McAfee\",\n    \"Trend Micro\",\n    \"Kaspersky\",\n    \"ESET\",\n    \"Sophos\",\n    \"CrowdStrike\",\n    \"SentinelOne\",\n    \"Carbon Black\",\n    \"Webroot\",\n    \"Malwarebytes\",\n    \"Bitdefender\",\n    \"Cylance\",\n    \"Palo Alto Cortex\",\n    \"Huntress\"\n)\n\n# Registry paths where AV/EDR products register\n$AVRegistryPaths = @(\n    \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\",\n    \"HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\"\n)\n\nforeach ($Computer in $Computers) {\n    $CompName = if ($Computer.Name) { $Computer.Name } else { $Computer[\"Name\"] }\n    $CompDNS = if ($Computer.DNSHostName) { $Computer.DNSHostName } else { $Computer[\"DNSHostName\"] }\n    $CompOS = if ($Computer.OperatingSystem) { $Computer.OperatingSystem } else { $Computer[\"OperatingSystem\"] }\n\n    $EndpointInfo = @{\n        ComputerName = $CompName\n        DNSHostName = $CompDNS\n        OperatingSystem = $CompOS\n        AVInstalled = $false\n        AVProducts = @()\n        DefenderStatus = \"Unknown\"\n        Reachable = $false\n    }\n\n    # Test if computer is reachable\n    $Reachable = Test-Connection -ComputerName $CompName -Count 1 -Quiet -ErrorAction SilentlyContinue\n    $EndpointInfo.Reachable = $Reachable\n\n    if (-not $Reachable) {\n        $EndpointInfo.Note = \"Endpoint not reachable - cannot verify protection\"\n        $Result.EndpointDetails += $EndpointInfo\n        continue\n    }\n\n    # Method 1: WMI query for AntiVirusProduct (Windows Security Center)\n    try {\n        $AVFromWMI = Get-CimInstance -Namespace \"root\\SecurityCenter2\" -ClassName \"AntiVirusProduct\" -ComputerName $CompName -ErrorAction Stop\n        if ($AVFromWMI) {\n            foreach ($AV in $AVFromWMI) {\n                $EndpointInfo.AVProducts += @{\n                    DisplayName = $AV.displayName\n                    ProductState = $AV.productState\n                    PathToSignedProductExe = $AV.pathToSignedProductExe\n                }\n                $EndpointInfo.AVInstalled = $true\n            }\n        }\n    } catch {\n        # SecurityCenter2 not available (e.g., Server OS)\n    }\n\n    # Method 2: Check Defender status via WMI\n    try {\n        $DefenderStatus = Invoke-Command -ComputerName $CompName -ScriptBlock {\n            Get-MpComputerStatus | Select-Object RealTimeProtectionEnabled, AntivirusEnabled, AntivirusSignatureLastUpdated\n        } -ErrorAction Stop\n\n        if ($DefenderStatus) {\n            $EndpointInfo.DefenderStatus = @{\n                RealTimeProtection = $DefenderStatus.RealTimeProtectionEnabled\n                AntivirusEnabled = $DefenderStatus.AntivirusEnabled\n                SignatureLastUpdated = $DefenderStatus.AntivirusSignatureLastUpdated\n            }\n            if ($DefenderStatus.AntivirusEnabled) {\n                $EndpointInfo.AVInstalled = $true\n                if ($EndpointInfo.AVProducts.Count -eq 0) {\n                    $EndpointInfo.AVProducts += @{\n                        DisplayName = \"Windows Defender\"\n                        Active = $DefenderStatus.RealTimeProtectionEnabled\n                    }\n                }\n            }\n        }\n    } catch {\n        # Remote command failed\n    }\n\n    # Method 3: Check registry for installed AV products via remote registry\n    if (-not $EndpointInfo.AVInstalled) {\n        try {\n            $InstalledSoftware = Invoke-Command -ComputerName $CompName -ScriptBlock {\n                $Paths = @(\n                    \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\",\n                    \"HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\"\n                )\n                Get-ItemProperty $Paths -ErrorAction SilentlyContinue |\n                    Select-Object DisplayName, Publisher, InstallDate\n            } -ErrorAction Stop\n\n            foreach ($SW in $InstalledSoftware) {\n                foreach ($AVName in $AVProducts) {\n                    if ($SW.DisplayName -match [regex]::Escape($AVName)) {\n                        $EndpointInfo.AVProducts += @{\n                            DisplayName = $SW.DisplayName\n                            Publisher = $SW.Publisher\n                        }\n                        $EndpointInfo.AVInstalled = $true\n                    }\n                }\n            }\n        } catch {\n            # Remote registry query failed\n            $EndpointInfo.RegistryQueryError = $_.Exception.Message\n        }\n    }\n\n    # Classify endpoint\n    if (-not $EndpointInfo.AVInstalled) {\n        $Result.UnprotectedEndpoints += @{\n            ComputerName = $CompName\n            OperatingSystem = $CompOS\n            Reachable = $Reachable\n        }\n        $Result.Issues += \"No endpoint protection found on $CompName\"\n        $Result.Drifted = $true\n    } else {\n        $Result.ProtectedEndpoints++\n    }\n\n    $Result.EndpointDetails += $EndpointInfo\n}\n\n$Result.UnprotectedCount = $Result.UnprotectedEndpoints.Count\n$Result.CoveragePercent = if ($Result.TotalEndpoints -gt 0) {\n    [math]::Round(($Result.ProtectedEndpoints / $Result.TotalEndpoints) * 100, 1)\n} else { 0 }\n\n# Drift if any endpoint lacks protection\nif ($Result.UnprotectedEndpoints.Count -gt 0) {\n    $Result.Drifted = $true\n}\n\n$Result | ConvertTo-Json -Depth 4",
    "remediate_script": "# Generate report of unprotected endpoints and push Defender policy if possible\n$Result = @{ Success = $false; Actions = @() }\n\ntry {\n    # Get unprotected endpoints\n    $Computers = @()\n    try {\n        Import-Module ActiveDirectory -ErrorAction Stop\n        $Computers = Get-ADComputer -Filter { Enabled -eq $true } -Properties OperatingSystem, LastLogonDate, DNSHostName |\n            Where-Object { $_.LastLogonDate -gt (Get-Date).AddDays(-30) }\n    } catch {\n        $Computers = @(@{ Name = $env:COMPUTERNAME })\n    }\n\n    $UnprotectedList = @()\n\n    foreach ($Computer in $Computers) {\n        $CompName = $Computer.Name\n        $Reachable = Test-Connection -ComputerName $CompName -Count 1 -Quiet -ErrorAction SilentlyContinue\n        if (-not $Reachable) { continue }\n\n        # Check if Defender is active\n        $HasAV = $false\n        try {\n            $DefenderStatus = Invoke-Command -ComputerName $CompName -ScriptBlock {\n                (Get-MpComputerStatus).AntivirusEnabled\n            } -ErrorAction Stop\n\n            $HasAV = $DefenderStatus\n        } catch {\n            # Check WMI fallback\n            try {\n                $AV = Get-CimInstance -Namespace \"root\\SecurityCenter2\" -ClassName \"AntiVirusProduct\" -ComputerName $CompName -ErrorAction Stop\n                $HasAV = ($null -ne $AV -and $AV.Count -gt 0)\n            } catch { }\n        }\n\n        if (-not $HasAV) {\n            $UnprotectedList += $CompName\n\n            # Attempt to enable Windows Defender remotely\n            try {\n                Invoke-Command -ComputerName $CompName -ScriptBlock {\n                    Set-MpPreference -DisableRealtimeMonitoring $false -ErrorAction Stop\n                    Update-MpSignature -ErrorAction SilentlyContinue\n                } -ErrorAction Stop\n\n                $Result.Actions += \"Enabled Windows Defender on $CompName\"\n            } catch {\n                $Result.Actions += \"ESCALATION: Cannot enable Defender on $CompName - $($_.Exception.Message)\"\n            }\n        }\n    }\n\n    # Try pushing Defender policy via GPO if available\n    try {\n        Import-Module GroupPolicy -ErrorAction Stop\n        $GPO = Get-GPO -Name \"Endpoint Protection Policy\" -ErrorAction SilentlyContinue\n        if ($GPO) {\n            $Result.Actions += \"GPO 'Endpoint Protection Policy' exists - ensure it is linked to all OUs\"\n        } else {\n            $Result.Actions += \"RECOMMENDATION: Create GPO for Endpoint Protection Policy\"\n        }\n    } catch {\n        $Result.Actions += \"Group Policy module not available\"\n    }\n\n    $Result.Success = $true\n    $Result.UnprotectedEndpoints = $UnprotectedList\n    $Result.UnprotectedCount = $UnprotectedList.Count\n    $Result.Recommendations = @(\n        \"Deploy managed endpoint protection to all workstations and servers\",\n        \"Create GPO to enforce Windows Defender if no third-party EDR\",\n        \"Enable Windows Defender ATP/MDE for advanced threat detection\",\n        \"Configure Defender exclusions only where necessary and documented\",\n        \"Set up centralized AV management console for monitoring\"\n    )\n} catch {\n    $Result.Error = $_.Exception.Message\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "verify_script": "# Re-scan endpoints for AV presence\n$ErrorActionPreference = \"SilentlyContinue\"\n$Result = @{\n    Compliant = $true\n    TotalEndpoints = 0\n    ProtectedEndpoints = 0\n    UnprotectedEndpoints = @()\n}\n\n# Get domain computers\n$Computers = @()\ntry {\n    Import-Module ActiveDirectory -ErrorAction Stop\n    $Computers = Get-ADComputer -Filter { Enabled -eq $true } -Properties LastLogonDate |\n        Where-Object { $_.LastLogonDate -gt (Get-Date).AddDays(-30) }\n} catch {\n    $Computers = @(@{ Name = $env:COMPUTERNAME })\n}\n\n$Result.TotalEndpoints = $Computers.Count\n\nforeach ($Computer in $Computers) {\n    $CompName = $Computer.Name\n    $Reachable = Test-Connection -ComputerName $CompName -Count 1 -Quiet -ErrorAction SilentlyContinue\n    if (-not $Reachable) { continue }\n\n    $HasAV = $false\n\n    # Check Defender\n    try {\n        $DefenderStatus = Invoke-Command -ComputerName $CompName -ScriptBlock {\n            (Get-MpComputerStatus).AntivirusEnabled\n        } -ErrorAction Stop\n        $HasAV = $DefenderStatus\n    } catch { }\n\n    # Check SecurityCenter2\n    if (-not $HasAV) {\n        try {\n            $AV = Get-CimInstance -Namespace \"root\\SecurityCenter2\" -ClassName \"AntiVirusProduct\" -ComputerName $CompName -ErrorAction Stop\n            $HasAV = ($null -ne $AV -and $AV.Count -gt 0)\n        } catch { }\n    }\n\n    if ($HasAV) {\n        $Result.ProtectedEndpoints++\n    } else {\n        $Result.UnprotectedEndpoints += $CompName\n        $Result.Compliant = $false\n    }\n}\n\n$Result.CoveragePercent = if ($Result.TotalEndpoints -gt 0) {\n    [math]::Round(($Result.ProtectedEndpoints / $Result.TotalEndpoints) * 100, 1)\n} else { 0 }\n\n$Result | ConvertTo-Json -Depth 2",
    "hipaa_controls": [
      "164.308(a)(5)(ii)(B)",
      "164.312(b)"
    ],
    "severity": "high",
    "timeout_seconds": 900
  },
  "RB-WIN-DEVICE-002": {
    "id": "RB-WIN-DEVICE-002",
    "name": "IoT/Medical Device Inventory",
    "platform": "windows",
    "detect_script": "# Discover all devices on clinic network and identify medical devices\n$ErrorActionPreference = \"SilentlyContinue\"\n$Result = @{\n    Drifted = $false\n    Devices = @()\n    MedicalDevices = @()\n    UnmanagedDevices = @()\n    Issues = @()\n    ScanTimestamp = (Get-Date).ToUniversalTime().ToString(\"o\")\n}\n\n# Medical device vendor MAC OUI prefixes (first 3 octets)\n$MedicalOUIs = @{\n    \"00-09-FB\" = \"Philips Healthcare\"\n    \"00-1E-8F\" = \"Philips Medical Systems\"\n    \"00-21-A0\" = \"Philips Healthcare\"\n    \"00-80-25\" = \"GE Healthcare\"\n    \"00-19-B3\" = \"GE Healthcare\"\n    \"00-50-F1\" = \"GE Healthcare\"\n    \"00-00-87\" = \"Siemens Healthineers\"\n    \"00-01-E5\" = \"Siemens Medical\"\n    \"08-00-06\" = \"Siemens AG\"\n    \"00-80-F4\" = \"Telemecanique (Baxter)\"\n    \"00-0C-C6\" = \"Baxter International\"\n    \"00-1B-5B\" = \"Welch Allyn\"\n    \"00-90-5F\" = \"Welch Allyn\"\n    \"00-24-7E\" = \"Welch Allyn / Hillrom\"\n    \"00-0D-E1\" = \"Masimo Corporation\"\n    \"00-25-41\" = \"Masimo Corporation\"\n    \"00-1A-6B\" = \"Draeger Medical\"\n    \"00-0F-EA\" = \"Draeger Medical\"\n    \"00-17-C4\" = \"Mindray Medical\"\n    \"00-1D-A5\" = \"Mindray Medical\"\n    \"00-1E-C9\" = \"Nihon Kohden\"\n    \"00-13-FD\" = \"Nihon Kohden\"\n    \"00-04-A5\" = \"Spacelabs Medical\"\n    \"00-1A-2A\" = \"Spacelabs Healthcare\"\n    \"00-0E-C4\" = \"Natus Medical\"\n    \"00-1C-06\" = \"Siemens Healthineers\"\n    \"00-50-04\" = \"3COM (common in older medical)\"\n}\n\n# Get all ARP entries for network discovery\n$ArpEntries = Get-NetNeighbor -AddressFamily IPv4 |\n    Where-Object { $_.State -ne \"Unreachable\" -and $_.State -ne \"Permanent\" }\n\n# Get domain computers for comparison (if domain-joined)\n$DomainComputers = @()\ntry {\n    Import-Module ActiveDirectory -ErrorAction Stop\n    $DomainComputers = @(Get-ADComputer -Filter * -Properties DNSHostName, OperatingSystem |\n        Select-Object -ExpandProperty DNSHostName)\n} catch {\n    # Not domain-joined or AD module not available\n}\n\n# Get DHCP leases if DHCP server role is available\n$DHCPLeases = @{}\ntry {\n    $Scopes = Get-DhcpServerv4Scope -ErrorAction Stop\n    foreach ($Scope in $Scopes) {\n        $Leases = Get-DhcpServerv4Lease -ScopeId $Scope.ScopeId -ErrorAction SilentlyContinue\n        foreach ($Lease in $Leases) {\n            $DHCPLeases[$Lease.IPAddress.ToString()] = @{\n                HostName = $Lease.HostName\n                ClientId = $Lease.ClientId\n                LeaseExpiry = $Lease.LeaseExpiryTime\n            }\n        }\n    }\n} catch {\n    # DHCP server not available on this machine\n}\n\nforeach ($Entry in $ArpEntries) {\n    $IP = $Entry.IPAddress\n    $MAC = $Entry.LinkLayerAddress\n\n    # Skip broadcast and multicast\n    if ($IP -like \"*.255\" -or $IP -like \"224.*\") { continue }\n\n    $Device = @{\n        IPAddress = $IP\n        MACAddress = $MAC\n        Vendor = \"Unknown\"\n        IsMedicalDevice = $false\n        IsManaged = $false\n        HostName = \"Unknown\"\n        NetworkIsolation = \"Unknown\"\n    }\n\n    # Resolve hostname via DNS\n    try {\n        $DNSResult = Resolve-DnsName -Name $IP -ErrorAction Stop\n        if ($DNSResult.NameHost) {\n            $Device.HostName = $DNSResult.NameHost\n        }\n    } catch {\n        # DNS resolution failed\n    }\n\n    # Check DHCP lease info\n    if ($DHCPLeases.ContainsKey($IP)) {\n        $Device.HostName = $DHCPLeases[$IP].HostName\n        $Device.DHCPLease = $true\n    }\n\n    # Extract OUI (first 3 octets of MAC)\n    $OUI = ($MAC -replace '[:-]', '-').Substring(0, 8).ToUpper()\n\n    # Check against medical device vendor OUIs\n    if ($MedicalOUIs.ContainsKey($OUI)) {\n        $Device.Vendor = $MedicalOUIs[$OUI]\n        $Device.IsMedicalDevice = $true\n        $Result.MedicalDevices += $Device\n    }\n\n    # Check if device is a managed domain computer\n    if ($DomainComputers.Count -gt 0) {\n        $IsDomainMember = $DomainComputers | Where-Object { $_ -like \"*$($Device.HostName)*\" }\n        $Device.IsManaged = ($null -ne $IsDomainMember)\n    }\n\n    # Check network isolation by testing if device can reach other subnets\n    # Get local subnet info\n    $LocalAdapter = Get-NetIPAddress -AddressFamily IPv4 |\n        Where-Object { $_.PrefixOrigin -ne \"WellKnown\" -and $_.IPAddress -ne \"127.0.0.1\" } |\n        Select-Object -First 1\n\n    if ($LocalAdapter) {\n        $LocalSubnet = ($LocalAdapter.IPAddress -split '\\.')[0..2] -join '.'\n        $DeviceSubnet = ($IP -split '\\.')[0..2] -join '.'\n        $Device.NetworkIsolation = if ($LocalSubnet -ne $DeviceSubnet) { \"Segmented\" } else { \"Same Subnet\" }\n    }\n\n    if (-not $Device.IsManaged -and -not $Device.IsMedicalDevice) {\n        $Result.UnmanagedDevices += $Device\n    }\n\n    $Result.Devices += $Device\n}\n\n# Determine drift\n$Result.TotalDevices = $Result.Devices.Count\n$Result.MedicalDeviceCount = $Result.MedicalDevices.Count\n$Result.UnmanagedCount = $Result.UnmanagedDevices.Count\n\n# Drift if medical devices not isolated or unmanaged devices exist\nforeach ($MedDevice in $Result.MedicalDevices) {\n    if ($MedDevice.NetworkIsolation -eq \"Same Subnet\") {\n        $Result.Drifted = $true\n        $Result.Issues += \"Medical device $($MedDevice.Vendor) ($($MedDevice.IPAddress)) not on isolated network segment\"\n    }\n}\n\nif ($Result.UnmanagedCount -gt 0) {\n    $Result.Drifted = $true\n    $Result.Issues += \"$($Result.UnmanagedCount) unmanaged device(s) detected on clinic network\"\n}\n\n$Result | ConvertTo-Json -Depth 4",
    "remediate_script": "# IoT/Medical device remediation requires manual intervention\n# Cannot auto-remediate physical network segmentation or device firmware\n$Result = @{ Success = $true; Actions = @() }\n\n$Result.Actions += \"Generated device inventory report for review\"\n$Result.Escalation = \"REQUIRED - Medical device network isolation must be configured manually\"\n\n# Build inventory summary\n$ArpEntries = Get-NetNeighbor -AddressFamily IPv4 |\n    Where-Object { $_.State -ne \"Unreachable\" -and $_.State -ne \"Permanent\" }\n\n$Inventory = @{\n    TotalDevices = $ArpEntries.Count\n    ScanDate = (Get-Date).ToUniversalTime().ToString(\"o\")\n    Recommendations = @(\n        \"Segment medical devices onto dedicated VLAN\",\n        \"Implement ACLs to restrict medical device communication\",\n        \"Deploy network monitoring for anomalous medical device traffic\",\n        \"Maintain device inventory with firmware versions\",\n        \"Establish patching schedule with device vendors\",\n        \"Review and document all unmanaged devices\"\n    )\n}\n\n$Result.Inventory = $Inventory\n$Result.Actions += \"Medical devices must be isolated on dedicated network segment per HIPAA 164.312(a)(1)\"\n\n$Result | ConvertTo-Json -Depth 3",
    "verify_script": "# Re-scan network and compare against baseline inventory\n$ErrorActionPreference = \"SilentlyContinue\"\n$Result = @{\n    Compliant = $true\n    DevicesFound = 0\n    MedicalDevicesIsolated = $true\n}\n\n# Medical device vendor MAC OUI prefixes\n$MedicalOUIs = @(\n    \"00-09-FB\", \"00-1E-8F\", \"00-21-A0\",\n    \"00-80-25\", \"00-19-B3\", \"00-50-F1\",\n    \"00-00-87\", \"00-01-E5\", \"08-00-06\",\n    \"00-80-F4\", \"00-0C-C6\",\n    \"00-1B-5B\", \"00-90-5F\", \"00-24-7E\",\n    \"00-0D-E1\", \"00-25-41\",\n    \"00-1A-6B\", \"00-0F-EA\",\n    \"00-17-C4\", \"00-1D-A5\",\n    \"00-1E-C9\", \"00-13-FD\",\n    \"00-04-A5\", \"00-1A-2A\",\n    \"00-0E-C4\", \"00-1C-06\"\n)\n\n$LocalAdapter = Get-NetIPAddress -AddressFamily IPv4 |\n    Where-Object { $_.PrefixOrigin -ne \"WellKnown\" -and $_.IPAddress -ne \"127.0.0.1\" } |\n    Select-Object -First 1\n\n$LocalSubnet = ($LocalAdapter.IPAddress -split '\\.')[0..2] -join '.'\n\n$ArpEntries = Get-NetNeighbor -AddressFamily IPv4 |\n    Where-Object { $_.State -ne \"Unreachable\" -and $_.State -ne \"Permanent\" }\n\n$Result.DevicesFound = $ArpEntries.Count\n\nforeach ($Entry in $ArpEntries) {\n    $OUI = ($Entry.LinkLayerAddress -replace '[:-]', '-').Substring(0, 8).ToUpper()\n    $DeviceSubnet = ($Entry.IPAddress -split '\\.')[0..2] -join '.'\n\n    if ($OUI -in $MedicalOUIs -and $DeviceSubnet -eq $LocalSubnet) {\n        $Result.MedicalDevicesIsolated = $false\n        $Result.Compliant = $false\n        break\n    }\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "hipaa_controls": [
      "164.312(a)(1)",
      "164.308(a)(1)(ii)(A)"
    ],
    "severity": "high",
    "timeout_seconds": 600
  },
  "RB-WIN-DEVICE-001": {
    "id": "RB-WIN-DEVICE-001",
    "name": "Network Printer/Copier Security Audit",
    "platform": "windows",
    "detect_script": "# Scan subnet for network printers and audit security posture\n$ErrorActionPreference = \"SilentlyContinue\"\n$Result = @{\n    Drifted = $false\n    Printers = @()\n    Issues = @()\n    ScanTimestamp = (Get-Date).ToUniversalTime().ToString(\"o\")\n}\n\n# Get local subnet from primary adapter\n$IPConfig = Get-NetIPAddress -AddressFamily IPv4 |\n    Where-Object { $_.PrefixOrigin -ne \"WellKnown\" -and $_.IPAddress -ne \"127.0.0.1\" } |\n    Select-Object -First 1\n\nif (-not $IPConfig) {\n    @{ Error = \"No active network adapter found\"; Drifted = $true } | ConvertTo-Json\n    return\n}\n\n$LocalIP = $IPConfig.IPAddress\n$Prefix = $IPConfig.PrefixLength\n$Subnet = ($LocalIP -split '\\.')[0..2] -join '.'\n\n# Common printer ports: 9100 (RAW), 515 (LPR), 631 (IPP)\n$PrinterPorts = @(9100, 515, 631)\n$FoundPrinters = @()\n\n# Scan subnet for devices with printer ports open\n$ScanRange = 1..254\n$Jobs = @()\n\nforeach ($Octet in $ScanRange) {\n    $TargetIP = \"$Subnet.$Octet\"\n    if ($TargetIP -eq $LocalIP) { continue }\n\n    # Test primary printer port (9100) with short timeout\n    $Job = Test-NetConnection -ComputerName $TargetIP -Port 9100 -WarningAction SilentlyContinue -InformationLevel Quiet\n    if ($Job) {\n        $FoundPrinters += $TargetIP\n    }\n}\n\n# Also check ports 515 and 631 on ARP-discovered devices\n$ArpEntries = Get-NetNeighbor -AddressFamily IPv4 |\n    Where-Object { $_.State -ne \"Unreachable\" -and $_.IPAddress -like \"$Subnet.*\" }\n\nforeach ($Entry in $ArpEntries) {\n    $IP = $Entry.IPAddress\n    if ($IP -in $FoundPrinters) { continue }\n    foreach ($Port in @(515, 631)) {\n        $Test = Test-NetConnection -ComputerName $IP -Port $Port -WarningAction SilentlyContinue -InformationLevel Quiet\n        if ($Test) {\n            $FoundPrinters += $IP\n            break\n        }\n    }\n}\n\n$FoundPrinters = $FoundPrinters | Select-Object -Unique\n\nforeach ($PrinterIP in $FoundPrinters) {\n    $PrinterInfo = @{\n        IPAddress = $PrinterIP\n        OpenPorts = @()\n        Issues = @()\n        DefaultSNMP = $false\n        HTTPSAdmin = $false\n        FirmwareVersion = \"Unknown\"\n        HardDriveEncryption = \"Unknown\"\n    }\n\n    # Check which printer ports are open\n    foreach ($Port in $PrinterPorts) {\n        $PortTest = Test-NetConnection -ComputerName $PrinterIP -Port $Port -WarningAction SilentlyContinue\n        if ($PortTest.TcpTestSucceeded) {\n            $PrinterInfo.OpenPorts += $Port\n        }\n    }\n\n    # Check SNMP default community strings (public/private)\n    # Use .NET SNMP query if available, otherwise use snmpwalk if installed\n    try {\n        # Try SNMP query with 'public' community string (OID: sysDescr.0)\n        $UdpClient = New-Object System.Net.Sockets.UdpClient\n        $UdpClient.Client.ReceiveTimeout = 2000\n\n        # SNMP GET for sysDescr.0 (1.3.6.1.2.1.1.1.0) with community 'public'\n        # Simplified SNMP v1 GET packet\n        $SNMPPacket = [byte[]](\n            0x30, 0x26, 0x02, 0x01, 0x00, 0x04, 0x06, 0x70,\n            0x75, 0x62, 0x6C, 0x69, 0x63, 0xA0, 0x19, 0x02,\n            0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x01, 0x00,\n            0x02, 0x01, 0x00, 0x30, 0x0B, 0x30, 0x09, 0x06,\n            0x05, 0x2B, 0x06, 0x01, 0x02, 0x01, 0x05, 0x00\n        )\n\n        $Endpoint = New-Object System.Net.IPEndPoint([System.Net.IPAddress]::Parse($PrinterIP), 161)\n        $UdpClient.Send($SNMPPacket, $SNMPPacket.Length, $Endpoint) | Out-Null\n        $RemoteEP = New-Object System.Net.IPEndPoint([System.Net.IPAddress]::Any, 0)\n\n        try {\n            $Response = $UdpClient.Receive([ref]$RemoteEP)\n            if ($Response.Length -gt 0) {\n                $PrinterInfo.DefaultSNMP = $true\n                $PrinterInfo.Issues += \"Default SNMP community string 'public' accepted\"\n                $Result.Drifted = $true\n\n                # Try to extract sysDescr from response for firmware info\n                $ResponseStr = [System.Text.Encoding]::ASCII.GetString($Response)\n                if ($ResponseStr -match '[A-Za-z].*\\d+\\.\\d+') {\n                    $PrinterInfo.FirmwareVersion = $Matches[0].Trim()\n                }\n            }\n        } catch {\n            # Timeout = community string rejected (good)\n            $PrinterInfo.DefaultSNMP = $false\n        }\n\n        $UdpClient.Close()\n\n        # Also test 'private' community string\n        $UdpClient2 = New-Object System.Net.Sockets.UdpClient\n        $UdpClient2.Client.ReceiveTimeout = 2000\n\n        $SNMPPacketPrivate = [byte[]](\n            0x30, 0x27, 0x02, 0x01, 0x00, 0x04, 0x07, 0x70,\n            0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0xA0, 0x19,\n            0x02, 0x04, 0x00, 0x00, 0x00, 0x02, 0x02, 0x01,\n            0x00, 0x02, 0x01, 0x00, 0x30, 0x0B, 0x30, 0x09,\n            0x06, 0x05, 0x2B, 0x06, 0x01, 0x02, 0x01, 0x05,\n            0x00\n        )\n\n        $Endpoint2 = New-Object System.Net.IPEndPoint([System.Net.IPAddress]::Parse($PrinterIP), 161)\n        $UdpClient2.Send($SNMPPacketPrivate, $SNMPPacketPrivate.Length, $Endpoint2) | Out-Null\n\n        try {\n            $Response2 = $UdpClient2.Receive([ref]$RemoteEP)\n            if ($Response2.Length -gt 0) {\n                $PrinterInfo.Issues += \"Default SNMP community string 'private' accepted (READ-WRITE)\"\n                $Result.Drifted = $true\n            }\n        } catch {\n            # Timeout = community string rejected (good)\n        }\n\n        $UdpClient2.Close()\n    } catch {\n        $PrinterInfo.SNMPError = $_.Exception.Message\n    }\n\n    # Check if web admin portal uses HTTPS\n    try {\n        # Test HTTPS (port 443)\n        $HTTPSTest = Test-NetConnection -ComputerName $PrinterIP -Port 443 -WarningAction SilentlyContinue\n        $HTTPTest = Test-NetConnection -ComputerName $PrinterIP -Port 80 -WarningAction SilentlyContinue\n\n        if ($HTTPSTest.TcpTestSucceeded) {\n            $PrinterInfo.HTTPSAdmin = $true\n        }\n\n        if ($HTTPTest.TcpTestSucceeded -and -not $HTTPSTest.TcpTestSucceeded) {\n            $PrinterInfo.Issues += \"Web admin accessible via HTTP only (no HTTPS)\"\n            $Result.Drifted = $true\n        }\n\n        if (-not $HTTPSTest.TcpTestSucceeded -and -not $HTTPTest.TcpTestSucceeded) {\n            $PrinterInfo.WebAdminAvailable = $false\n        }\n    } catch {\n        $PrinterInfo.WebAdminError = $_.Exception.Message\n    }\n\n    # Check hard drive encryption via SNMP OID if SNMP is accessible\n    # Common OID for storage info: 1.3.6.1.2.1.25.2 (hrStorage)\n    if ($PrinterInfo.DefaultSNMP) {\n        $PrinterInfo.HardDriveEncryption = \"SNMP accessible with defaults - cannot verify encryption status securely\"\n        $PrinterInfo.Issues += \"Hard drive encryption status unverifiable due to default SNMP credentials\"\n    }\n\n    $Result.Printers += $PrinterInfo\n    $Result.Issues += $PrinterInfo.Issues\n}\n\n$Result.PrinterCount = $FoundPrinters.Count\n$Result.NonCompliantCount = ($Result.Printers | Where-Object { $_.Issues.Count -gt 0 }).Count\n\nif ($Result.PrinterCount -eq 0) {\n    $Result.Message = \"No network printers detected on subnet $Subnet.0/$Prefix\"\n}\n\n$Result | ConvertTo-Json -Depth 4",
    "remediate_script": "# Printer security issues require manual/escalated remediation\n# Printers cannot be safely auto-remediated remotely\n$Result = @{ Success = $true; Actions = @() }\n\n# Re-scan to build current findings report\n$IPConfig = Get-NetIPAddress -AddressFamily IPv4 |\n    Where-Object { $_.PrefixOrigin -ne \"WellKnown\" -and $_.IPAddress -ne \"127.0.0.1\" } |\n    Select-Object -First 1\n\n$Subnet = ($IPConfig.IPAddress -split '\\.')[0..2] -join '.'\n$Findings = @()\n\n# Check known printer ports on ARP table\n$ArpEntries = Get-NetNeighbor -AddressFamily IPv4 |\n    Where-Object { $_.State -ne \"Unreachable\" -and $_.IPAddress -like \"$Subnet.*\" }\n\nforeach ($Entry in $ArpEntries) {\n    $IP = $Entry.IPAddress\n    $PrinterTest = Test-NetConnection -ComputerName $IP -Port 9100 -WarningAction SilentlyContinue -InformationLevel Quiet\n    if ($PrinterTest) {\n        $Finding = @{\n            IPAddress = $IP\n            MACAddress = $Entry.LinkLayerAddress\n            Recommendations = @(\n                \"Change SNMP community strings from defaults\",\n                \"Enable HTTPS on web admin portal\",\n                \"Enable hard drive encryption if available\",\n                \"Update firmware to latest version\",\n                \"Restrict web admin access to management VLAN\"\n            )\n        }\n        $Findings += $Finding\n    }\n}\n\n$Result.Actions += \"Generated printer security findings report\"\n$Result.Findings = $Findings\n$Result.FindingsCount = $Findings.Count\n$Result.Escalation = \"REQUIRED - Printer remediation must be performed manually or via vendor tools\"\n$Result.Priority = \"HIGH - Default SNMP credentials expose device configuration\"\n\n$Result | ConvertTo-Json -Depth 3",
    "verify_script": "# Re-scan printers and verify SNMP community strings changed\n$ErrorActionPreference = \"SilentlyContinue\"\n$Result = @{\n    Compliant = $true\n    PrintersChecked = 0\n    StillNonCompliant = @()\n}\n\n$IPConfig = Get-NetIPAddress -AddressFamily IPv4 |\n    Where-Object { $_.PrefixOrigin -ne \"WellKnown\" -and $_.IPAddress -ne \"127.0.0.1\" } |\n    Select-Object -First 1\n\n$Subnet = ($IPConfig.IPAddress -split '\\.')[0..2] -join '.'\n\n# Check ARP table for printer devices\n$ArpEntries = Get-NetNeighbor -AddressFamily IPv4 |\n    Where-Object { $_.State -ne \"Unreachable\" -and $_.IPAddress -like \"$Subnet.*\" }\n\nforeach ($Entry in $ArpEntries) {\n    $IP = $Entry.IPAddress\n    $PrinterTest = Test-NetConnection -ComputerName $IP -Port 9100 -WarningAction SilentlyContinue -InformationLevel Quiet\n    if (-not $PrinterTest) { continue }\n\n    $Result.PrintersChecked++\n\n    # Test default SNMP community string 'public'\n    try {\n        $UdpClient = New-Object System.Net.Sockets.UdpClient\n        $UdpClient.Client.ReceiveTimeout = 2000\n\n        $SNMPPacket = [byte[]](\n            0x30, 0x26, 0x02, 0x01, 0x00, 0x04, 0x06, 0x70,\n            0x75, 0x62, 0x6C, 0x69, 0x63, 0xA0, 0x19, 0x02,\n            0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x01, 0x00,\n            0x02, 0x01, 0x00, 0x30, 0x0B, 0x30, 0x09, 0x06,\n            0x05, 0x2B, 0x06, 0x01, 0x02, 0x01, 0x05, 0x00\n        )\n\n        $Endpoint = New-Object System.Net.IPEndPoint([System.Net.IPAddress]::Parse($IP), 161)\n        $UdpClient.Send($SNMPPacket, $SNMPPacket.Length, $Endpoint) | Out-Null\n        $RemoteEP = New-Object System.Net.IPEndPoint([System.Net.IPAddress]::Any, 0)\n\n        try {\n            $Response = $UdpClient.Receive([ref]$RemoteEP)\n            if ($Response.Length -gt 0) {\n                $Result.Compliant = $false\n                $Result.StillNonCompliant += @{\n                    IPAddress = $IP\n                    Issue = \"Default SNMP community string 'public' still accepted\"\n                }\n            }\n        } catch {\n            # Timeout = good, community string rejected\n        }\n\n        $UdpClient.Close()\n    } catch {\n        # SNMP check failed\n    }\n}\n\n$Result | ConvertTo-Json -Depth 3",
    "hipaa_controls": [
      "164.312(a)(1)",
      "164.312(e)(2)(ii)",
      "164.310(d)(1)"
    ],
    "severity": "high",
    "timeout_seconds": 600
  },
  "LIN-ACCT-001": {
    "id": "LIN-ACCT-001",
    "name": "No UID 0 Except Root",
    "platform": "linux",
    "detect_script": "UID0_USERS=$(awk -F: '$3 == 0 && $1 != \"root\" {print $1}' /etc/passwd)\n        if [ -z \"$UID0_USERS\" ]; then\n            echo \"COMPLIANT:only_root_uid0\"\n            exit 0\n        else\n            echo \"DRIFT:other_uid0_users=$UID0_USERS\"\n            exit 1\n        fi",
    "remediate_script": "# UID 0 accounts other than root are dangerous  remediation requires human review\nUID0_USERS=$(awk -F: '$3 == 0 && $1 != \"root\" {print $1}' /etc/passwd)\nif [ -z \"$UID0_USERS\" ]; then\n    echo \"REMEDIATED:no_extra_uid0\"\n    exit 0\nfi\nfor USER in $UID0_USERS; do\n    echo \"ALERT:uid0_account=$USER requires manual review\"\ndone\necho \"REMEDIATED:partial  flagged accounts for L3 review\"",
    "verify_script": "UID0_USERS=$(awk -F: '$3 == 0 && $1 != \"root\" {print $1}' /etc/passwd)\nif [ -z \"$UID0_USERS\" ]; then\n    echo \"VERIFIED:only_root_uid0\"\n    exit 0\nelse\n    echo \"VERIFY_FAILED:extra_uid0=$UID0_USERS\"\n    exit 1\nfi",
    "hipaa_controls": [
      "164.312(a)(1)"
    ],
    "severity": "critical",
    "timeout_seconds": 15
  },
  "LIN-ACCT-002": {
    "id": "LIN-ACCT-002",
    "name": "Password Expiry Policy",
    "platform": "linux",
    "detect_script": "MAX_DAYS=$(grep \"^PASS_MAX_DAYS\" /etc/login.defs | awk '{print $2}')\n        if [ -n \"$MAX_DAYS\" ] && [ \"$MAX_DAYS\" -le 90 ]; then\n            echo \"COMPLIANT:pass_max_days=$MAX_DAYS\"\n            exit 0\n        else\n            echo \"DRIFT:pass_max_days=${MAX_DAYS:-not_set}\"\n            exit 1\n        fi",
    "remediate_script": "# NixOS: /etc/login.defs is read-only  managed by configuration.nix\nif [ -f /etc/NIXOS ]; then\n    MAX_DAYS=$(grep '^PASS_MAX_DAYS' /etc/login.defs 2>/dev/null | awk '{print $2}')\n    if [ -n \"$MAX_DAYS\" ] && [ \"$MAX_DAYS\" -le 90 ]; then\n        echo \"REMEDIATED:nixos_pass_max_days_ok=$MAX_DAYS\"\n        exit 0\n    fi\n    echo \"SKIP:nixos_requires_configuration_change  set users.users.<name>.passwordPolicy or security.pam in configuration.nix\"\n    exit 0\nfi\n# Standard Linux\nsed -i 's/^PASS_MAX_DAYS.*/PASS_MAX_DAYS 90/' /etc/login.defs\nif ! grep -q '^PASS_MAX_DAYS' /etc/login.defs; then\n    echo 'PASS_MAX_DAYS 90' >> /etc/login.defs\nfi\necho \"REMEDIATED\"",
    "verify_script": "MAX_DAYS=$(grep '^PASS_MAX_DAYS' /etc/login.defs 2>/dev/null | awk '{print $2}')\nif [ -n \"$MAX_DAYS\" ] && [ \"$MAX_DAYS\" -le 90 ]; then\n    echo \"VERIFIED:pass_max_days=$MAX_DAYS\"\n    exit 0\nelse\n    echo \"VERIFY_FAILED:pass_max_days=${MAX_DAYS:-not_set}\"\n    exit 1\nfi",
    "hipaa_controls": [
      "164.312(a)(1)",
      "164.308(a)(5)(ii)(D)"
    ],
    "severity": "medium",
    "timeout_seconds": 15
  },
  "LIN-AUDIT-001": {
    "id": "LIN-AUDIT-001",
    "name": "Audit Rules for Identity Files",
    "platform": "linux",
    "detect_script": "if auditctl -l 2>/dev/null | grep -q \"/etc/passwd\" &&            auditctl -l 2>/dev/null | grep -q \"/etc/shadow\"; then\n            echo \"COMPLIANT:identity_files_audited\"\n            exit 0\n        else\n            echo \"DRIFT:identity_files_not_audited\"\n            exit 1\n        fi",
    "remediate_script": "# Add audit rules\n        auditctl -w /etc/passwd -p wa -k identity\n        auditctl -w /etc/shadow -p wa -k identity\n        auditctl -w /etc/group -p wa -k identity\n        # Make persistent\n        cat >> /etc/audit/rules.d/identity.rules << 'EOF'\n-w /etc/passwd -p wa -k identity\n-w /etc/shadow -p wa -k identity\n-w /etc/group -p wa -k identity\nEOF\n        echo \"REMEDIATED\"",
    "verify_script": "if auditctl -l 2>/dev/null | grep -q '/etc/passwd' && auditctl -l 2>/dev/null | grep -q '/etc/shadow'; then\n    echo \"VERIFIED:identity_files_audited\"\n    exit 0\nelse\n    echo \"VERIFY_FAILED:audit_rules_missing\"\n    exit 1\nfi",
    "hipaa_controls": [
      "164.312(b)",
      "164.308(a)(1)(ii)(D)"
    ],
    "severity": "high",
    "timeout_seconds": 30
  },
  "LIN-AUDIT-002": {
    "id": "LIN-AUDIT-002",
    "name": "Audit Rules for Auth Logs",
    "platform": "linux",
    "detect_script": "if auditctl -l 2>/dev/null | grep -q \"auth.log\\|secure\"; then\n            echo \"COMPLIANT:auth_logs_audited\"\n            exit 0\n        else\n            echo \"DRIFT:auth_logs_not_audited\"\n            exit 1\n        fi",
    "remediate_script": "# Add audit rules at runtime (works on all Linux including NixOS)\nif [ -f /var/log/auth.log ]; then\n    auditctl -w /var/log/auth.log -p wa -k auth 2>/dev/null\nfi\nif [ -f /var/log/secure ]; then\n    auditctl -w /var/log/secure -p wa -k auth 2>/dev/null\nfi\n# Persist rules  NixOS uses /etc/audit which may be read-only\nif [ -f /etc/NIXOS ]; then\n    echo \"REMEDIATED:runtime_audit_rules_added  persist via security.auditd.rules in configuration.nix\"\n    exit 0\nfi\n# Standard Linux: persist to rules.d\nmkdir -p /etc/audit/rules.d\nif [ -f /var/log/auth.log ]; then\n    echo '-w /var/log/auth.log -p wa -k auth' >> /etc/audit/rules.d/auth.rules\nfi\nif [ -f /var/log/secure ]; then\n    echo '-w /var/log/secure -p wa -k auth' >> /etc/audit/rules.d/auth.rules\nfi\necho \"REMEDIATED\"",
    "verify_script": "if auditctl -l 2>/dev/null | grep -q 'auth.log\\|secure'; then\n    echo \"VERIFIED:auth_logs_audited\"\n    exit 0\nelse\n    echo \"VERIFY_FAILED:auth_log_audit_rules_missing\"\n    exit 1\nfi",
    "hipaa_controls": [
      "164.312(b)"
    ],
    "severity": "high",
    "timeout_seconds": 30
  },
  "LIN-BANNER-001": {
    "id": "LIN-BANNER-001",
    "name": "Login Banner",
    "platform": "linux",
    "detect_script": "COMPLIANT=true\n        DRIFT_ISSUES=\"\"\n\n        # Check /etc/issue for authorized-use warning\n        if [ -f /etc/issue ]; then\n            if ! grep -qi \"authorized\" /etc/issue 2>/dev/null; then\n                DRIFT_ISSUES=\"$DRIFT_ISSUES issue_no_warning\"\n                COMPLIANT=false\n            fi\n        else\n            DRIFT_ISSUES=\"$DRIFT_ISSUES issue_missing\"\n            COMPLIANT=false\n        fi\n\n        # Check /etc/issue.net for authorized-use warning\n        if [ -f /etc/issue.net ]; then\n            if ! grep -qi \"authorized\" /etc/issue.net 2>/dev/null; then\n                DRIFT_ISSUES=\"$DRIFT_ISSUES issue_net_no_warning\"\n                COMPLIANT=false\n            fi\n        else\n            DRIFT_ISSUES=\"$DRIFT_ISSUES issue_net_missing\"\n            COMPLIANT=false\n        fi\n\n        if $COMPLIANT; then\n            echo \"COMPLIANT:banners_configured\"\n            exit 0\n        else\n            echo \"DRIFT:$DRIFT_ISSUES\"\n            exit 1\n        fi",
    "remediate_script": "# NixOS: /etc/issue and /etc/issue.net are managed by configuration.nix\nif [ -f /etc/NIXOS ]; then\n    if grep -qi 'authorized' /etc/issue 2>/dev/null; then\n        echo \"REMEDIATED:nixos_banner_already_configured\"\n        exit 0\n    fi\n    echo \"SKIP:nixos_requires_configuration_change  set services.openssh.banner and environment.etc.issue in configuration.nix\"\n    exit 0\nfi\n# Standard Linux\nBANNER_TEXT='WARNING: This system is for authorized use only. All activities are monitored and recorded. Unauthorized access is prohibited and may result in disciplinary action and/or criminal prosecution. This system processes PHI under HIPAA.'\necho \"$BANNER_TEXT\" > /etc/issue\nchmod 644 /etc/issue\nchown root:root /etc/issue\necho \"$BANNER_TEXT\" > /etc/issue.net\nchmod 644 /etc/issue.net\nchown root:root /etc/issue.net\nif [ -f /etc/ssh/sshd_config ]; then\n    sed -i 's|^#*Banner.*|Banner /etc/issue.net|' /etc/ssh/sshd_config\n    if ! grep -q '^Banner' /etc/ssh/sshd_config; then\n        echo 'Banner /etc/issue.net' >> /etc/ssh/sshd_config\n    fi\n    systemctl reload sshd 2>/dev/null || true\nfi\necho \"REMEDIATED\"",
    "verify_script": "FAIL=false\n\n        if [ -f /etc/issue ]; then\n            if ! grep -qi \"authorized\" /etc/issue; then\n                FAIL=true\n            fi\n        else\n            FAIL=true\n        fi\n\n        if [ -f /etc/issue.net ]; then\n            if ! grep -qi \"authorized\" /etc/issue.net; then\n                FAIL=true\n            fi\n        else\n            FAIL=true\n        fi\n\n        if $FAIL; then\n            echo \"VERIFY_FAILED\"\n            exit 1\n        else\n            echo \"VERIFIED\"\n            exit 0\n        fi",
    "hipaa_controls": [
      "164.310(b)"
    ],
    "severity": "low",
    "timeout_seconds": 30
  },
  "LIN-BOOT-001": {
    "id": "LIN-BOOT-001",
    "name": "Bootloader Security",
    "platform": "linux",
    "detect_script": "DRIFT_ISSUES=\"\"\n        COMPLIANT=true\n\n        # Check GRUB password configuration\n        GRUB_PW_SET=false\n        if [ -f /etc/grub.d/40_custom ] && grep -q \"password_pbkdf2\\|password \" /etc/grub.d/40_custom 2>/dev/null; then\n            GRUB_PW_SET=true\n        fi\n        if [ -f /boot/grub2/user.cfg ] && grep -q \"GRUB2_PASSWORD\" /boot/grub2/user.cfg 2>/dev/null; then\n            GRUB_PW_SET=true\n        fi\n        if [ -f /boot/grub/grub.cfg ] && grep -q \"password_pbkdf2\\|password \" /boot/grub/grub.cfg 2>/dev/null; then\n            GRUB_PW_SET=true\n        fi\n\n        if ! $GRUB_PW_SET; then\n            DRIFT_ISSUES=\"$DRIFT_ISSUES grub_password_not_set\"\n            COMPLIANT=false\n        fi\n\n        # Check grub.cfg permissions (should be 0600 or 0400)\n        GRUB_CFG=\"\"\n        if [ -f /boot/grub/grub.cfg ]; then\n            GRUB_CFG=\"/boot/grub/grub.cfg\"\n        elif [ -f /boot/grub2/grub.cfg ]; then\n            GRUB_CFG=\"/boot/grub2/grub.cfg\"\n        fi\n\n        if [ -n \"$GRUB_CFG\" ]; then\n            PERMS=$(stat -c \"%a\" \"$GRUB_CFG\" 2>/dev/null)\n            if [ \"$PERMS\" != \"600\" ] && [ \"$PERMS\" != \"400\" ]; then\n                DRIFT_ISSUES=\"$DRIFT_ISSUES grub_cfg_perms=$PERMS\"\n                COMPLIANT=false\n            fi\n        fi\n\n        if $COMPLIANT; then\n            echo \"COMPLIANT:bootloader_secured\"\n            exit 0\n        else\n            echo \"DRIFT:$DRIFT_ISSUES\"\n            exit 1\n        fi",
    "remediate_script": "FIXED=\"\"\n\n        # Fix grub.cfg permissions (safe to auto-fix)\n        GRUB_CFG=\"\"\n        if [ -f /boot/grub/grub.cfg ]; then\n            GRUB_CFG=\"/boot/grub/grub.cfg\"\n        elif [ -f /boot/grub2/grub.cfg ]; then\n            GRUB_CFG=\"/boot/grub2/grub.cfg\"\n        fi\n\n        if [ -n \"$GRUB_CFG\" ]; then\n            chmod 600 \"$GRUB_CFG\"\n            chown root:root \"$GRUB_CFG\"\n            FIXED=\"$FIXED permissions_fixed\"\n        fi\n\n        # GRUB password: ALERT ONLY - too risky to auto-configure\n        GRUB_PW_SET=false\n        if [ -f /etc/grub.d/40_custom ] && grep -q \"password_pbkdf2\\|password \" /etc/grub.d/40_custom 2>/dev/null; then\n            GRUB_PW_SET=true\n        fi\n        if [ -f /boot/grub2/user.cfg ] && grep -q \"GRUB2_PASSWORD\" /boot/grub2/user.cfg 2>/dev/null; then\n            GRUB_PW_SET=true\n        fi\n\n        if ! $GRUB_PW_SET; then\n            echo \"ALERT:grub_password_not_set requires manual configuration\"\n            echo \"REMEDIATED:partial - permissions fixed, password requires L2 review\"\n        else\n            echo \"REMEDIATED\"\n        fi",
    "verify_script": "GRUB_CFG=\"\"\n        if [ -f /boot/grub/grub.cfg ]; then\n            GRUB_CFG=\"/boot/grub/grub.cfg\"\n        elif [ -f /boot/grub2/grub.cfg ]; then\n            GRUB_CFG=\"/boot/grub2/grub.cfg\"\n        fi\n\n        if [ -n \"$GRUB_CFG\" ]; then\n            PERMS=$(stat -c \"%a\" \"$GRUB_CFG\" 2>/dev/null)\n            if [ \"$PERMS\" = \"600\" ] || [ \"$PERMS\" = \"400\" ]; then\n                echo \"VERIFIED:grub_cfg_perms=$PERMS\"\n                exit 0\n            fi\n        fi\n        echo \"VERIFY_FAILED\"\n        exit 1",
    "hipaa_controls": [
      "164.310(a)(1)"
    ],
    "severity": "medium",
    "timeout_seconds": 30
  },
  "LIN-CRON-001": {
    "id": "LIN-CRON-001",
    "name": "Cron Job Auditing",
    "platform": "linux",
    "detect_script": "DRIFT_ISSUES=\"\"\n        COMPLIANT=true\n\n        # Check /etc/crontab permissions (should be 0600)\n        if [ -f /etc/crontab ]; then\n            PERMS=$(stat -c \"%a\" /etc/crontab 2>/dev/null)\n            if [ \"$PERMS\" != \"600\" ] && [ \"$PERMS\" != \"400\" ]; then\n                DRIFT_ISSUES=\"$DRIFT_ISSUES crontab_perms=$PERMS\"\n                COMPLIANT=false\n            fi\n        fi\n\n        # Check /etc/cron.d/ permissions\n        if [ -d /etc/cron.d ]; then\n            PERMS=$(stat -c \"%a\" /etc/cron.d 2>/dev/null)\n            if [ \"$PERMS\" != \"700\" ] && [ \"$PERMS\" != \"750\" ]; then\n                DRIFT_ISSUES=\"$DRIFT_ISSUES cron_d_perms=$PERMS\"\n                COMPLIANT=false\n            fi\n        fi\n\n        # Check cron.allow exists\n        if [ ! -f /etc/cron.allow ]; then\n            DRIFT_ISSUES=\"$DRIFT_ISSUES cron_allow_missing\"\n            COMPLIANT=false\n        fi\n\n        # Check for world-writable cron files\n        WW_CRON=$(find /etc/cron* -type f -perm -0002 2>/dev/null | head -5)\n        if [ -n \"$WW_CRON\" ]; then\n            DRIFT_ISSUES=\"$DRIFT_ISSUES world_writable_cron_files\"\n            COMPLIANT=false\n        fi\n\n        if $COMPLIANT; then\n            echo \"COMPLIANT:cron_secured\"\n            exit 0\n        else\n            echo \"DRIFT:$DRIFT_ISSUES\"\n            exit 1\n        fi",
    "remediate_script": "# Fix /etc/crontab permissions\n        if [ -f /etc/crontab ]; then\n            chmod 600 /etc/crontab\n            chown root:root /etc/crontab\n        fi\n\n        # Fix /etc/cron.d/ permissions\n        if [ -d /etc/cron.d ]; then\n            chmod 700 /etc/cron.d\n            chown root:root /etc/cron.d\n        fi\n\n        # Fix cron.hourly/daily/weekly/monthly permissions\n        for DIR in /etc/cron.hourly /etc/cron.daily /etc/cron.weekly /etc/cron.monthly; do\n            if [ -d \"$DIR\" ]; then\n                chmod 700 \"$DIR\"\n                chown root:root \"$DIR\"\n            fi\n        done\n\n        # Create cron.allow if missing (only root by default)\n        if [ ! -f /etc/cron.allow ]; then\n            echo \"root\" > /etc/cron.allow\n            chmod 600 /etc/cron.allow\n            chown root:root /etc/cron.allow\n        fi\n\n        # Remove world-writable permissions from cron files\n        find /etc/cron* -type f -perm -0002 -exec chmod o-w {} \\; 2>/dev/null\n\n        echo \"REMEDIATED\"",
    "verify_script": "FAIL=false\n\n        # Check crontab permissions\n        if [ -f /etc/crontab ]; then\n            PERMS=$(stat -c \"%a\" /etc/crontab 2>/dev/null)\n            if [ \"$PERMS\" != \"600\" ] && [ \"$PERMS\" != \"400\" ]; then\n                FAIL=true\n            fi\n        fi\n\n        # Check cron.allow\n        if [ ! -f /etc/cron.allow ]; then\n            FAIL=true\n        fi\n\n        # Check no world-writable cron files\n        WW_CRON=$(find /etc/cron* -type f -perm -0002 2>/dev/null | head -1)\n        if [ -n \"$WW_CRON\" ]; then\n            FAIL=true\n        fi\n\n        if $FAIL; then\n            echo \"VERIFY_FAILED\"\n            exit 1\n        else\n            echo \"VERIFIED\"\n            exit 0\n        fi",
    "hipaa_controls": [
      "164.308(a)(1)(ii)(D)"
    ],
    "severity": "medium",
    "timeout_seconds": 30
  },
  "LIN-CRYPTO-001": {
    "id": "LIN-CRYPTO-001",
    "name": "Cryptographic Policy",
    "platform": "linux",
    "detect_script": "SSHD_CONFIG=\"/etc/ssh/sshd_config\"\n        DRIFT_ISSUES=\"\"\n        COMPLIANT=true\n\n        # Weak cipher patterns to reject\n        WEAK_CIPHERS=\"3des|arcfour|blowfish|cast128|rc4\"\n        # Weak MAC patterns to reject\n        WEAK_MACS=\"md5|sha1-96|umac-64\"\n        # Weak KexAlgorithm patterns to reject\n        WEAK_KEX=\"diffie-hellman-group1-sha1|diffie-hellman-group14-sha1|diffie-hellman-group-exchange-sha1\"\n\n        # Check configured ciphers\n        CIPHERS_LINE=$(grep -E \"^Ciphers \" \"$SSHD_CONFIG\" 2>/dev/null | awk '{print $2}')\n        if [ -n \"$CIPHERS_LINE\" ]; then\n            if echo \"$CIPHERS_LINE\" | grep -qiE \"$WEAK_CIPHERS\"; then\n                DRIFT_ISSUES=\"$DRIFT_ISSUES weak_ciphers_found\"\n                COMPLIANT=false\n            fi\n        else\n            # No explicit cipher config - check ssh defaults for weak ciphers\n            ACTIVE_CIPHERS=$(sshd -T 2>/dev/null | grep \"^ciphers \" | awk '{print $2}')\n            if echo \"$ACTIVE_CIPHERS\" | grep -qiE \"$WEAK_CIPHERS\"; then\n                DRIFT_ISSUES=\"$DRIFT_ISSUES weak_default_ciphers\"\n                COMPLIANT=false\n            fi\n        fi\n\n        # Check configured MACs\n        MACS_LINE=$(grep -E \"^MACs \" \"$SSHD_CONFIG\" 2>/dev/null | awk '{print $2}')\n        if [ -n \"$MACS_LINE\" ]; then\n            if echo \"$MACS_LINE\" | grep -qiE \"$WEAK_MACS\"; then\n                DRIFT_ISSUES=\"$DRIFT_ISSUES weak_macs_found\"\n                COMPLIANT=false\n            fi\n        else\n            ACTIVE_MACS=$(sshd -T 2>/dev/null | grep \"^macs \" | awk '{print $2}')\n            if echo \"$ACTIVE_MACS\" | grep -qiE \"$WEAK_MACS\"; then\n                DRIFT_ISSUES=\"$DRIFT_ISSUES weak_default_macs\"\n                COMPLIANT=false\n            fi\n        fi\n\n        # Check configured KexAlgorithms\n        KEX_LINE=$(grep -E \"^KexAlgorithms \" \"$SSHD_CONFIG\" 2>/dev/null | awk '{print $2}')\n        if [ -n \"$KEX_LINE\" ]; then\n            if echo \"$KEX_LINE\" | grep -qiE \"$WEAK_KEX\"; then\n                DRIFT_ISSUES=\"$DRIFT_ISSUES weak_kex_found\"\n                COMPLIANT=false\n            fi\n        else\n            ACTIVE_KEX=$(sshd -T 2>/dev/null | grep \"^kexalgorithms \" | awk '{print $2}')\n            if echo \"$ACTIVE_KEX\" | grep -qiE \"$WEAK_KEX\"; then\n                DRIFT_ISSUES=\"$DRIFT_ISSUES weak_default_kex\"\n                COMPLIANT=false\n            fi\n        fi\n\n        if $COMPLIANT; then\n            echo \"COMPLIANT:strong_crypto_only\"\n            exit 0\n        else\n            echo \"DRIFT:$DRIFT_ISSUES\"\n            exit 1\n        fi",
    "remediate_script": "# NixOS: sshd_config is read-only  managed by services.openssh in configuration.nix\nif [ -f /etc/NIXOS ]; then\n    WEAK_CIPHERS='3des|arcfour|blowfish|cast128|rc4'\n    ACTIVE_CIPHERS=$(sshd -T 2>/dev/null | grep '^ciphers ' | awk '{print $2}')\n    if echo \"$ACTIVE_CIPHERS\" | grep -qiE \"$WEAK_CIPHERS\"; then\n        echo \"SKIP:nixos_requires_configuration_change  set services.openssh.settings.Ciphers/MACs/KexAlgorithms in configuration.nix\"\n        exit 0\n    fi\n    echo \"REMEDIATED:nixos_crypto_already_strong\"\n    exit 0\nfi\n# Standard Linux\nSSHD_CONFIG='/etc/ssh/sshd_config'\nSTRONG_CIPHERS='aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr,chacha20-poly1305@openssh.com'\nSTRONG_MACS='hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512,hmac-sha2-256'\nSTRONG_KEX='curve25519-sha256,curve25519-sha256@libssh.org,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,diffie-hellman-group-exchange-sha256'\nsed -i \"s/^#*Ciphers .*/Ciphers $STRONG_CIPHERS/\" \"$SSHD_CONFIG\"\ngrep -q '^Ciphers ' \"$SSHD_CONFIG\" || echo \"Ciphers $STRONG_CIPHERS\" >> \"$SSHD_CONFIG\"\nsed -i \"s/^#*MACs .*/MACs $STRONG_MACS/\" \"$SSHD_CONFIG\"\ngrep -q '^MACs ' \"$SSHD_CONFIG\" || echo \"MACs $STRONG_MACS\" >> \"$SSHD_CONFIG\"\nsed -i \"s/^#*KexAlgorithms .*/KexAlgorithms $STRONG_KEX/\" \"$SSHD_CONFIG\"\ngrep -q '^KexAlgorithms ' \"$SSHD_CONFIG\" || echo \"KexAlgorithms $STRONG_KEX\" >> \"$SSHD_CONFIG\"\nif sshd -t 2>/dev/null; then\n    systemctl reload sshd\n    echo \"REMEDIATED\"\nelse\n    echo \"ERROR:sshd_config_validation_failed\"\n    exit 1\nfi",
    "verify_script": "# Brief pause to ensure sshd has reloaded after remediate\n        sleep 2\n        WEAK_CIPHERS=\"3des|arcfour|blowfish|cast128|rc4\"\n        WEAK_MACS=\"md5|sha1-96|umac-64\"\n        WEAK_KEX=\"diffie-hellman-group1-sha1|diffie-hellman-group14-sha1|diffie-hellman-group-exchange-sha1\"\n        FAIL=false\n\n        # Use sshd -T to check ACTIVE config (handles Include directives, defaults)\n        # Fall back to grepping the config file if sshd -T not available\n        ACTIVE_CONFIG=$(sshd -T 2>/dev/null)\n\n        if [ -n \"$ACTIVE_CONFIG\" ]; then\n            CIPHERS=$(echo \"$ACTIVE_CONFIG\" | grep \"^ciphers \" | awk '{print $2}')\n            if echo \"$CIPHERS\" | grep -qiE \"$WEAK_CIPHERS\"; then FAIL=true; fi\n            MACS=$(echo \"$ACTIVE_CONFIG\" | grep \"^macs \" | awk '{print $2}')\n            if echo \"$MACS\" | grep -qiE \"$WEAK_MACS\"; then FAIL=true; fi\n            KEX=$(echo \"$ACTIVE_CONFIG\" | grep \"^kexalgorithms \" | awk '{print $2}')\n            if echo \"$KEX\" | grep -qiE \"$WEAK_KEX\"; then FAIL=true; fi\n        else\n            # Fallback: check the config file directly\n            SSHD_CONFIG=\"/etc/ssh/sshd_config\"\n            CIPHERS=$(grep -E \"^Ciphers \" \"$SSHD_CONFIG\" 2>/dev/null | awk '{print $2}')\n            if [ -n \"$CIPHERS\" ] && echo \"$CIPHERS\" | grep -qiE \"$WEAK_CIPHERS\"; then FAIL=true; fi\n            MACS=$(grep -E \"^MACs \" \"$SSHD_CONFIG\" 2>/dev/null | awk '{print $2}')\n            if [ -n \"$MACS\" ] && echo \"$MACS\" | grep -qiE \"$WEAK_MACS\"; then FAIL=true; fi\n            KEX=$(grep -E \"^KexAlgorithms \" \"$SSHD_CONFIG\" 2>/dev/null | awk '{print $2}')\n            if [ -n \"$KEX\" ] && echo \"$KEX\" | grep -qiE \"$WEAK_KEX\"; then FAIL=true; fi\n        fi\n\n        if $FAIL; then\n            echo \"VERIFY_FAILED\"\n            exit 1\n        else\n            echo \"VERIFIED:strong_crypto_configured\"\n            exit 0\n        fi",
    "hipaa_controls": [
      "164.312(e)(2)(ii)"
    ],
    "severity": "high",
    "timeout_seconds": 30
  },
  "LIN-FW-001": {
    "id": "LIN-FW-001",
    "name": "Firewall Active",
    "platform": "linux",
    "detect_script": "# Check ufw (Ubuntu/Debian)\n        if command -v ufw &>/dev/null; then\n            STATUS=$(ufw status 2>/dev/null | head -1)\n            if echo \"$STATUS\" | grep -q \"Status: active\"; then\n                echo \"COMPLIANT:ufw_active\"\n                exit 0\n            fi\n        fi\n        # Check firewalld (RHEL/CentOS)\n        if command -v firewall-cmd &>/dev/null; then\n            if firewall-cmd --state 2>/dev/null | grep -q \"running\"; then\n                echo \"COMPLIANT:firewalld_active\"\n                exit 0\n            fi\n        fi\n        # Check iptables as fallback\n        if iptables -L -n 2>/dev/null | grep -q \"Chain INPUT\"; then\n            RULES=$(iptables -L -n | wc -l)\n            if [ \"$RULES\" -gt 10 ]; then\n                echo \"COMPLIANT:iptables_configured\"\n                exit 0\n            fi\n        fi\n        echo \"DRIFT:no_active_firewall\"\n        exit 1",
    "remediate_script": "# NixOS: firewall is managed declaratively via nftables\nif [ -f /etc/NIXOS ]; then\n    # Check if nftables service exists and reload it\n    if systemctl is-enabled nftables.service >/dev/null 2>&1 || systemctl is-enabled firewall.service >/dev/null 2>&1; then\n        systemctl restart nftables.service 2>/dev/null || systemctl restart firewall.service 2>/dev/null || true\n        RULES=$(nft list ruleset 2>/dev/null | grep -c 'rule' || echo 0)\n        if [ \"$RULES\" -gt 0 ]; then\n            echo \"REMEDIATED:nixos_nftables_reloaded\"\n            exit 0\n        fi\n    fi\n    echo \"SKIP:nixos_requires_configuration_change\"\n    exit 0\nfi\n\n# Standard Linux: try ufw first, then firewalld\nif command -v ufw >/dev/null 2>&1; then\n    ufw --force enable\n    ufw default deny incoming\n    ufw default allow outgoing\n    ufw allow ssh\n    echo \"REMEDIATED:ufw_enabled\"\nelif command -v firewall-cmd >/dev/null 2>&1; then\n    systemctl enable --now firewalld\n    firewall-cmd --set-default-zone=drop\n    firewall-cmd --permanent --add-service=ssh\n    firewall-cmd --reload\n    echo \"REMEDIATED:firewalld_enabled\"\nelse\n    echo \"SKIP:no_firewall_tool_available\"\n    exit 1\nfi",
    "verify_script": "# Check nftables (NixOS)\nif command -v nft >/dev/null 2>&1; then\n    RULES=$(nft list ruleset 2>/dev/null | grep -c 'rule' || echo 0)\n    if [ \"$RULES\" -gt 0 ]; then\n        echo \"VERIFIED:nftables_active\"\n        exit 0\n    fi\nfi\n# Check ufw\nif command -v ufw >/dev/null 2>&1; then\n    if ufw status 2>/dev/null | grep -q 'Status: active'; then\n        echo \"VERIFIED:ufw_active\"\n        exit 0\n    fi\nfi\n# Check firewalld\nif command -v firewall-cmd >/dev/null 2>&1; then\n    if firewall-cmd --state 2>/dev/null | grep -q running; then\n        echo \"VERIFIED:firewalld_active\"\n        exit 0\n    fi\nfi\necho \"VERIFY_FAILED\"\nexit 1",
    "hipaa_controls": [
      "164.312(e)(1)"
    ],
    "severity": "critical",
    "timeout_seconds": 120
  },
  "LIN-INTEGRITY-001": {
    "id": "LIN-INTEGRITY-001",
    "name": "File Integrity Monitoring",
    "platform": "linux",
    "detect_script": "# Check for AIDE\n        if command -v aide &>/dev/null; then\n            if [ -f /var/lib/aide/aide.db ]; then\n                # Check if database is recent (within 30 days)\n                DB_AGE=$(find /var/lib/aide/aide.db -mtime -30 2>/dev/null | wc -l)\n                if [ \"$DB_AGE\" -gt 0 ]; then\n                    echo \"COMPLIANT:aide_configured\"\n                    exit 0\n                else\n                    echo \"DRIFT:aide_db_stale\"\n                    exit 1\n                fi\n            else\n                echo \"DRIFT:aide_db_missing\"\n                exit 1\n            fi\n        fi\n\n        # Check for Samhain\n        if command -v samhain &>/dev/null; then\n            if systemctl is-active samhain &>/dev/null; then\n                echo \"COMPLIANT:samhain_active\"\n                exit 0\n            fi\n        fi\n\n        # Check for OSSEC\n        if [ -d /var/ossec ]; then\n            if systemctl is-active ossec-hids &>/dev/null; then\n                echo \"COMPLIANT:ossec_active\"\n                exit 0\n            fi\n        fi\n\n        echo \"DRIFT:no_integrity_monitoring\"\n        exit 1",
    "remediate_script": "# Initialize or update AIDE database if aide is installed\nif command -v aide >/dev/null 2>&1; then\n    if [ ! -f /var/lib/aide/aide.db ]; then\n        aide --init 2>/dev/null\n        if [ -f /var/lib/aide/aide.db.new ]; then\n            mv /var/lib/aide/aide.db.new /var/lib/aide/aide.db\n            echo \"REMEDIATED:aide_db_initialized\"\n            exit 0\n        fi\n    else\n        aide --update 2>/dev/null\n        if [ -f /var/lib/aide/aide.db.new ]; then\n            mv /var/lib/aide/aide.db.new /var/lib/aide/aide.db\n            echo \"REMEDIATED:aide_db_updated\"\n            exit 0\n        fi\n    fi\nfi\necho \"ALERT:no_fim_tool_installed  install aide or equivalent and initialize database\"\nexit 0",
    "verify_script": "if command -v aide &>/dev/null && [ -f /var/lib/aide/aide.db ]; then\n            echo \"VERIFIED:aide_configured\"\n            exit 0\n        fi\n        echo \"VERIFY_FAILED\"\n        exit 1",
    "hipaa_controls": [
      "164.312(c)(1)",
      "164.312(c)(2)",
      "164.312(b)"
    ],
    "severity": "high",
    "timeout_seconds": 300
  },
  "LIN-IR-001": {
    "id": "LIN-IR-001",
    "name": "Incident Response Readiness",
    "platform": "linux",
    "detect_script": "RESULT=\"COMPLIANT\"\n        ISSUES=\"\"\n\n        # Check if critical logs exist and are being written\n        if [ -f /var/log/auth.log ] || [ -f /var/log/secure ]; then\n            LOG_FILE=$(ls /var/log/auth.log /var/log/secure 2>/dev/null | head -1)\n            LOG_AGE=$(find \"$LOG_FILE\" -mmin -60 2>/dev/null | wc -l)\n            if [ \"$LOG_AGE\" -eq 0 ]; then\n                RESULT=\"DRIFT\"\n                ISSUES=\"$ISSUES auth_log_stale\"\n            fi\n        else\n            RESULT=\"DRIFT\"\n            ISSUES=\"$ISSUES auth_log_missing\"\n        fi\n\n        # Check if auditd is running\n        if ! systemctl is-active auditd &>/dev/null; then\n            RESULT=\"DRIFT\"\n            ISSUES=\"$ISSUES auditd_not_running\"\n        fi\n\n        # Check for log rotation\n        if [ ! -f /etc/logrotate.d/rsyslog ] && [ ! -f /etc/logrotate.d/syslog ]; then\n            ISSUES=\"$ISSUES logrotate_not_configured\"\n        fi\n\n        # Check for remote syslog (optional but recommended)\n        if grep -q \"^[^#]*@\" /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null; then\n            echo \"INFO: Remote syslog configured\"\n        fi\n\n        # Check for forensic tools\n        TOOLS_INSTALLED=0\n        for tool in tcpdump strace lsof netstat ss; do\n            if command -v $tool &>/dev/null; then\n                TOOLS_INSTALLED=$((TOOLS_INSTALLED + 1))\n            fi\n        done\n\n        if [ \"$TOOLS_INSTALLED\" -lt 3 ]; then\n            ISSUES=\"$ISSUES forensic_tools_missing\"\n        fi\n\n        if [ \"$RESULT\" = \"COMPLIANT\" ]; then\n            echo \"COMPLIANT:ir_ready\"\n            exit 0\n        else\n            echo \"DRIFT:$ISSUES\"\n            exit 1\n        fi",
    "remediate_script": "# Ensure auditd and rsyslog are running\nif systemctl list-unit-files auditd.service 2>/dev/null | grep -q auditd; then\n    systemctl restart auditd 2>/dev/null || true\nfi\nif systemctl list-unit-files rsyslog.service 2>/dev/null | grep -q rsyslog; then\n    systemctl restart rsyslog 2>/dev/null || true\nfi\n# On NixOS, journald handles logging  check it\nif [ -f /etc/NIXOS ]; then\n    systemctl restart systemd-journald 2>/dev/null || true\n    echo \"REMEDIATED:nixos_logging_services_restarted\"\n    exit 0\nfi\necho \"REMEDIATED:logging_services_restarted\"",
    "verify_script": "OK=true\n\n        if ! systemctl is-active auditd &>/dev/null; then\n            OK=false\n        fi\n\n        if ! systemctl is-active rsyslog &>/dev/null; then\n            OK=false\n        fi\n\n        if ! command -v tcpdump &>/dev/null; then\n            OK=false\n        fi\n\n        if $OK; then\n            echo \"VERIFIED:ir_ready\"\n            exit 0\n        else\n            echo \"VERIFY_FAILED\"\n            exit 1\n        fi",
    "hipaa_controls": [
      "164.308(a)(6)",
      "164.312(b)"
    ],
    "severity": "high",
    "timeout_seconds": 180
  },
  "LIN-KERN-001": {
    "id": "LIN-KERN-001",
    "name": "Kernel Hardening (sysctl)",
    "platform": "linux",
    "detect_script": "DRIFT_PARAMS=\"\"\n        COMPLIANT=true\n\n        check_param() {\n            PARAM=\"$1\"\n            EXPECTED=\"$2\"\n            ACTUAL=$(sysctl -n \"$PARAM\" 2>/dev/null)\n            if [ \"$ACTUAL\" != \"$EXPECTED\" ]; then\n                DRIFT_PARAMS=\"$DRIFT_PARAMS $PARAM=$ACTUAL(expected=$EXPECTED)\"\n                COMPLIANT=false\n            fi\n        }\n\n        check_param \"net.ipv4.ip_forward\" \"0\"\n        check_param \"net.ipv4.conf.all.send_redirects\" \"0\"\n        check_param \"net.ipv4.conf.all.accept_redirects\" \"0\"\n        check_param \"kernel.randomize_va_space\" \"2\"\n        check_param \"fs.suid_dumpable\" \"0\"\n\n        if $COMPLIANT; then\n            echo \"COMPLIANT:all_sysctl_params_set\"\n            exit 0\n        else\n            echo \"DRIFT:$DRIFT_PARAMS\"\n            exit 1\n        fi",
    "remediate_script": "# Apply immediately via sysctl -w (works on all Linux including NixOS)\nsysctl -w net.ipv4.ip_forward=0\nsysctl -w net.ipv4.conf.all.send_redirects=0\nsysctl -w net.ipv4.conf.all.accept_redirects=0\nsysctl -w kernel.randomize_va_space=2\nsysctl -w fs.suid_dumpable=0\n\n# NixOS: kernel params are managed by boot.kernel.sysctl in configuration.nix\n# sysctl -w applies immediately but won't persist across reboot  that's OK,\n# the NixOS config (configuration.nix) handles persistence declaratively\nif [ -f /etc/NIXOS ]; then\n    echo \"REMEDIATED:nixos_sysctl_applied_runtime\"\n    exit 0\nfi\n\n# Standard Linux: persist to sysctl.d\ncat > /etc/sysctl.d/99-hipaa-hardening.conf << 'SYSCTLEOF'\nnet.ipv4.ip_forward = 0\nnet.ipv4.conf.all.send_redirects = 0\nnet.ipv4.conf.all.accept_redirects = 0\nkernel.randomize_va_space = 2\nfs.suid_dumpable = 0\nSYSCTLEOF\nsysctl --system >/dev/null 2>&1\necho \"REMEDIATED\"",
    "verify_script": "FAIL=false\n        for PARAM in \"net.ipv4.ip_forward=0\" \"net.ipv4.conf.all.send_redirects=0\"                      \"net.ipv4.conf.all.accept_redirects=0\" \"kernel.randomize_va_space=2\"                      \"fs.suid_dumpable=0\"; do\n            KEY=$(echo \"$PARAM\" | cut -d= -f1)\n            EXPECTED=$(echo \"$PARAM\" | cut -d= -f2)\n            ACTUAL=$(sysctl -n \"$KEY\" 2>/dev/null)\n            if [ \"$ACTUAL\" != \"$EXPECTED\" ]; then\n                FAIL=true\n            fi\n        done\n        if $FAIL; then\n            echo \"VERIFY_FAILED\"\n            exit 1\n        else\n            echo \"VERIFIED\"\n            exit 0\n        fi",
    "hipaa_controls": [
      "164.312(a)(1)"
    ],
    "severity": "high",
    "timeout_seconds": 30
  },
  "LIN-KERN-002": {
    "id": "LIN-KERN-002",
    "name": "Kernel Module Restrictions",
    "platform": "linux",
    "detect_script": "BLACKLIST_FILE=\"/etc/modprobe.d/hipaa-blacklist.conf\"\n        MISSING_MODULES=\"\"\n        COMPLIANT=true\n\n        for MODULE in usb-storage firewire-core bluetooth; do\n            # Check if blocked in any modprobe.d config\n            if ! grep -rq \"install $MODULE /bin/true\" /etc/modprobe.d/ 2>/dev/null &&                ! grep -rq \"install $MODULE /bin/false\" /etc/modprobe.d/ 2>/dev/null &&                ! grep -rq \"blacklist $MODULE\" /etc/modprobe.d/ 2>/dev/null; then\n                MISSING_MODULES=\"$MISSING_MODULES $MODULE\"\n                COMPLIANT=false\n            fi\n        done\n\n        if $COMPLIANT; then\n            echo \"COMPLIANT:all_modules_blacklisted\"\n            exit 0\n        else\n            echo \"DRIFT:not_blacklisted=$MISSING_MODULES\"\n            exit 1\n        fi",
    "remediate_script": "BLACKLIST_FILE=\"/etc/modprobe.d/hipaa-blacklist.conf\"\n\n        cat > \"$BLACKLIST_FILE\" << 'MODEOF'\n# HIPAA Module Blacklist - managed by compliance-agent\n# Do not edit manually - changes will be overwritten\n\n# Disable USB storage (prevent unauthorized data exfiltration)\ninstall usb-storage /bin/true\nblacklist usb-storage\n\n# Disable FireWire (prevent DMA attacks)\ninstall firewire-core /bin/true\nblacklist firewire-core\n\n# Disable Bluetooth (reduce attack surface in healthcare environments)\ninstall bluetooth /bin/true\nblacklist bluetooth\nMODEOF\n\n        chmod 644 \"$BLACKLIST_FILE\"\n        echo \"REMEDIATED\"",
    "verify_script": "BLACKLIST_FILE=\"/etc/modprobe.d/hipaa-blacklist.conf\"\n        if [ -f \"$BLACKLIST_FILE\" ]; then\n            FOUND=0\n            for MODULE in usb-storage firewire-core bluetooth; do\n                if grep -q \"install $MODULE /bin/true\" \"$BLACKLIST_FILE\"; then\n                    FOUND=$((FOUND + 1))\n                fi\n            done\n            if [ \"$FOUND\" -eq 3 ]; then\n                echo \"VERIFIED\"\n                exit 0\n            fi\n        fi\n        echo \"VERIFY_FAILED\"\n        exit 1",
    "hipaa_controls": [
      "164.310(d)(1)"
    ],
    "severity": "medium",
    "timeout_seconds": 30
  },
  "LIN-LOG-001": {
    "id": "LIN-LOG-001",
    "name": "Log Retention & Forwarding",
    "platform": "linux",
    "detect_script": "DRIFT_ISSUES=\"\"\n        COMPLIANT=true\n\n        # Check journald MaxRetentionSec\n        if [ -f /etc/systemd/journald.conf ]; then\n            RETENTION=$(grep -E \"^MaxRetentionSec\" /etc/systemd/journald.conf 2>/dev/null | cut -d= -f2 | tr -d ' ')\n            if [ -z \"$RETENTION\" ]; then\n                DRIFT_ISSUES=\"$DRIFT_ISSUES journald_retention=not_set\"\n                COMPLIANT=false\n            else\n                # Convert to seconds for comparison (90 days = 7776000)\n                # Handle common suffixes\n                case \"$RETENTION\" in\n                    *d|*day|*days)\n                        DAYS=$(echo \"$RETENTION\" | sed 's/[^0-9]//g')\n                        if [ \"$DAYS\" -lt 90 ]; then\n                            DRIFT_ISSUES=\"$DRIFT_ISSUES journald_retention=${DAYS}d\"\n                            COMPLIANT=false\n                        fi\n                        ;;\n                    *)\n                        # Assume seconds\n                        SECS=$(echo \"$RETENTION\" | sed 's/[^0-9]//g')\n                        if [ -n \"$SECS\" ] && [ \"$SECS\" -lt 7776000 ]; then\n                            DRIFT_ISSUES=\"$DRIFT_ISSUES journald_retention=${SECS}s\"\n                            COMPLIANT=false\n                        fi\n                        ;;\n                esac\n            fi\n        else\n            DRIFT_ISSUES=\"$DRIFT_ISSUES journald_conf_missing\"\n            COMPLIANT=false\n        fi\n\n        # Check rsyslog remote forwarding (informational)\n        if command -v rsyslogd &>/dev/null; then\n            if ! grep -rq \"^[^#]*@@\\?\" /etc/rsyslog.conf /etc/rsyslog.d/*.conf 2>/dev/null; then\n                echo \"INFO:no_remote_syslog_forwarding\"\n            fi\n        fi\n\n        # Check logrotate retention\n        if [ -f /etc/logrotate.conf ]; then\n            ROTATE_COUNT=$(grep -E \"^rotate \" /etc/logrotate.conf 2>/dev/null | awk '{print $2}')\n            if [ -n \"$ROTATE_COUNT\" ] && [ \"$ROTATE_COUNT\" -lt 90 ]; then\n                DRIFT_ISSUES=\"$DRIFT_ISSUES logrotate_count=$ROTATE_COUNT\"\n                COMPLIANT=false\n            fi\n        fi\n\n        if $COMPLIANT; then\n            echo \"COMPLIANT:log_retention_adequate\"\n            exit 0\n        else\n            echo \"DRIFT:$DRIFT_ISSUES\"\n            exit 1\n        fi",
    "remediate_script": "# NixOS: journald is configured declaratively \u2014 cannot modify /etc symlinks\nif [ -f /etc/NIXOS ]; then\n    STORAGE=$(grep -E \"^Storage=\" /etc/systemd/journald.conf 2>/dev/null | cut -d= -f2 | tr -d ' ' || true)\n    if [ \"$STORAGE\" = \"persistent\" ]; then\n        echo \"REMEDIATED:nixos_journald_persistent_ok\"\n        exit 0\n    fi\n    # NixOS /etc is read-only \u2014 requires configuration.nix change, escalate\n    echo \"SKIP:nixos_requires_configuration_change\"\n    exit 0\nfi\n\n# Standard Linux: modify journald.conf and logrotate\nJOURNALD_CONF=\"/etc/systemd/journald.conf\"\nif [ -f \"$JOURNALD_CONF\" ]; then\n    sed -i 's/^#*MaxRetentionSec=.*/MaxRetentionSec=7776000/' \"$JOURNALD_CONF\"\n    if ! grep -q \"^MaxRetentionSec\" \"$JOURNALD_CONF\"; then\n        echo \"MaxRetentionSec=7776000\" >> \"$JOURNALD_CONF\"\n    fi\n    sed -i 's/^#*Storage=.*/Storage=persistent/' \"$JOURNALD_CONF\"\n    if ! grep -q \"^Storage\" \"$JOURNALD_CONF\"; then\n        echo \"Storage=persistent\" >> \"$JOURNALD_CONF\"\n    fi\n    systemctl restart systemd-journald\nfi\n\nif [ -f /etc/logrotate.conf ]; then\n    sed -i 's/^rotate .*/rotate 90/' /etc/logrotate.conf\nfi\n\necho \"REMEDIATED\"",
    "verify_script": "# Check journald storage and retention\nJOURNALD_CONF=\"/etc/systemd/journald.conf\"\nSTORAGE=$(grep -E \"^Storage=\" \"$JOURNALD_CONF\" 2>/dev/null | cut -d= -f2 | tr -d ' ' || true)\n\nif [ -f /etc/NIXOS ]; then\n    # NixOS: persistent storage is managed declaratively\n    if [ \"$STORAGE\" = \"persistent\" ]; then\n        echo \"VERIFIED:nixos_journald_persistent\"\n        exit 0\n    fi\nfi\n\nRETENTION=$(grep -E \"^MaxRetentionSec=\" \"$JOURNALD_CONF\" 2>/dev/null | cut -d= -f2 | tr -d ' ' || true)\nif [ \"$STORAGE\" = \"persistent\" ]; then\n    echo \"VERIFIED:storage=$STORAGE,retention=$RETENTION\"\n    exit 0\nelse\n    echo \"VERIFY_FAILED:storage=$STORAGE,retention=$RETENTION\"\n    exit 1\nfi",
    "hipaa_controls": [
      "164.312(b)"
    ],
    "severity": "high",
    "timeout_seconds": 60
  },
  "LIN-MAC-001": {
    "id": "LIN-MAC-001",
    "name": "SELinux/AppArmor Active",
    "platform": "linux",
    "detect_script": "# Check SELinux (RHEL)\n        if command -v getenforce &>/dev/null; then\n            STATUS=$(getenforce 2>/dev/null)\n            if [ \"$STATUS\" = \"Enforcing\" ]; then\n                echo \"COMPLIANT:selinux_enforcing\"\n                exit 0\n            elif [ \"$STATUS\" = \"Permissive\" ]; then\n                echo \"DRIFT:selinux_permissive\"\n                exit 1\n            fi\n        fi\n        # Check AppArmor (Ubuntu)\n        if command -v aa-status &>/dev/null; then\n            PROFILES=$(aa-status 2>/dev/null | grep \"profiles are loaded\" | awk '{print $1}')\n            if [ -n \"$PROFILES\" ] && [ \"$PROFILES\" -gt 0 ]; then\n                echo \"COMPLIANT:apparmor_active\"\n                exit 0\n            fi\n        fi\n        echo \"DRIFT:no_mac_active\"\n        exit 1",
    "remediate_script": "# Try to enable SELinux or AppArmor\nif command -v getenforce >/dev/null 2>&1; then\n    STATUS=$(getenforce 2>/dev/null)\n    if [ \"$STATUS\" = \"Permissive\" ]; then\n        setenforce 1 2>/dev/null && echo \"REMEDIATED:selinux_set_enforcing\" && exit 0\n    fi\n    echo \"ALERT:selinux_disabled  requires manual configuration and reboot\"\n    exit 0\nfi\nif command -v aa-status >/dev/null 2>&1; then\n    PROFILES=$(aa-status 2>/dev/null | grep 'profiles are loaded' | awk '{print $1}')\n    if [ -n \"$PROFILES\" ] && [ \"$PROFILES\" -gt 0 ]; then\n        echo \"REMEDIATED:apparmor_already_active\"\n        exit 0\n    fi\n    systemctl restart apparmor 2>/dev/null && echo \"REMEDIATED:apparmor_restarted\" && exit 0\nfi\necho \"ALERT:no_mac_framework  install and configure SELinux or AppArmor\"",
    "verify_script": "# Check SELinux\nif command -v getenforce >/dev/null 2>&1; then\n    STATUS=$(getenforce 2>/dev/null)\n    if [ \"$STATUS\" = \"Enforcing\" ]; then\n        echo \"VERIFIED:selinux_enforcing\"\n        exit 0\n    fi\nfi\n# Check AppArmor\nif command -v aa-status >/dev/null 2>&1; then\n    PROFILES=$(aa-status 2>/dev/null | grep 'profiles are loaded' | awk '{print $1}')\n    if [ -n \"$PROFILES\" ] && [ \"$PROFILES\" -gt 0 ]; then\n        echo \"VERIFIED:apparmor_active\"\n        exit 0\n    fi\nfi\necho \"VERIFY_FAILED:no_mac_active\"\nexit 1",
    "hipaa_controls": [
      "164.312(a)(1)",
      "164.312(c)(1)"
    ],
    "severity": "high",
    "timeout_seconds": 120
  },
  "LIN-NET-001": {
    "id": "LIN-NET-001",
    "name": "Network Hardening",
    "platform": "linux",
    "detect_script": "DRIFT_PARAMS=\"\"\n        COMPLIANT=true\n\n        check_param() {\n            PARAM=\"$1\"\n            EXPECTED=\"$2\"\n            ACTUAL=$(sysctl -n \"$PARAM\" 2>/dev/null)\n            if [ \"$ACTUAL\" != \"$EXPECTED\" ]; then\n                DRIFT_PARAMS=\"$DRIFT_PARAMS $PARAM=$ACTUAL(expected=$EXPECTED)\"\n                COMPLIANT=false\n            fi\n        }\n\n        check_param \"net.ipv4.ip_forward\" \"0\"\n        check_param \"net.ipv4.tcp_syncookies\" \"1\"\n        check_param \"net.ipv4.icmp_echo_ignore_broadcasts\" \"1\"\n        check_param \"net.ipv4.conf.all.rp_filter\" \"1\"\n        check_param \"net.ipv4.conf.all.log_martians\" \"1\"\n\n        if $COMPLIANT; then\n            echo \"COMPLIANT:all_network_params_set\"\n            exit 0\n        else\n            echo \"DRIFT:$DRIFT_PARAMS\"\n            exit 1\n        fi",
    "remediate_script": "# Apply immediately\n        sysctl -w net.ipv4.ip_forward=0\n        sysctl -w net.ipv4.tcp_syncookies=1\n        sysctl -w net.ipv4.icmp_echo_ignore_broadcasts=1\n        sysctl -w net.ipv4.conf.all.rp_filter=1\n        sysctl -w net.ipv4.conf.all.log_martians=1\n\n        # Persist to config file\n        cat > /etc/sysctl.d/99-hipaa-network.conf << 'SYSCTLEOF'\n# HIPAA Network Hardening - managed by compliance-agent\n# Do not edit manually - changes will be overwritten\n\n# Disable IP forwarding (not a router)\nnet.ipv4.ip_forward = 0\n\n# Enable SYN cookies (SYN flood protection)\nnet.ipv4.tcp_syncookies = 1\n\n# Ignore ICMP broadcast requests\nnet.ipv4.icmp_echo_ignore_broadcasts = 1\n\n# Enable reverse path filtering (anti-spoofing)\nnet.ipv4.conf.all.rp_filter = 1\n\n# Log martian packets (impossible source addresses)\nnet.ipv4.conf.all.log_martians = 1\nSYSCTLEOF\n\n        # Reload sysctl\n        sysctl --system >/dev/null 2>&1\n        echo \"REMEDIATED\"",
    "verify_script": "FAIL=false\n        for PARAM in \"net.ipv4.ip_forward=0\" \"net.ipv4.tcp_syncookies=1\"                      \"net.ipv4.icmp_echo_ignore_broadcasts=1\"                      \"net.ipv4.conf.all.rp_filter=1\" \"net.ipv4.conf.all.log_martians=1\"; do\n            KEY=$(echo \"$PARAM\" | cut -d= -f1)\n            EXPECTED=$(echo \"$PARAM\" | cut -d= -f2)\n            ACTUAL=$(sysctl -n \"$KEY\" 2>/dev/null)\n            if [ \"$ACTUAL\" != \"$EXPECTED\" ]; then\n                FAIL=true\n            fi\n        done\n        if $FAIL; then\n            echo \"VERIFY_FAILED\"\n            exit 1\n        else\n            echo \"VERIFIED\"\n            exit 0\n        fi",
    "hipaa_controls": [
      "164.312(e)(1)"
    ],
    "severity": "medium",
    "timeout_seconds": 30
  },
  "LIN-NTP-001": {
    "id": "LIN-NTP-001",
    "name": "NTP Time Synchronization",
    "platform": "linux",
    "detect_script": "# Check for chrony or ntpd\n        SYNC_STATUS=\"NOT_CONFIGURED\"\n        TIME_DRIFT=0\n\n        if command -v chronyc &>/dev/null; then\n            if systemctl is-active chronyd &>/dev/null; then\n                SYNC_STATUS=$(chronyc tracking 2>/dev/null | grep \"Leap status\" | awk '{print $4}')\n                TIME_DRIFT=$(chronyc tracking 2>/dev/null | grep \"System time\" | awk '{print $4}')\n                if [ \"$SYNC_STATUS\" = \"Normal\" ]; then\n                    echo \"COMPLIANT:chrony_synced,drift=${TIME_DRIFT}s\"\n                    exit 0\n                fi\n            fi\n        fi\n\n        if command -v ntpq &>/dev/null; then\n            if systemctl is-active ntpd &>/dev/null || systemctl is-active ntp &>/dev/null; then\n                PEERS=$(ntpq -p 2>/dev/null | grep -c \"^\\*\")\n                if [ \"$PEERS\" -gt 0 ]; then\n                    echo \"COMPLIANT:ntp_synced,peers=$PEERS\"\n                    exit 0\n                fi\n            fi\n        fi\n\n        # Check systemd-timesyncd\n        if systemctl is-active systemd-timesyncd &>/dev/null; then\n            SYNC=$(timedatectl show --property=NTPSynchronized --value 2>/dev/null)\n            if [ \"$SYNC\" = \"yes\" ]; then\n                echo \"COMPLIANT:timesyncd_synced\"\n                exit 0\n            fi\n        fi\n\n        echo \"DRIFT:time_not_synchronized\"\n        exit 1",
    "remediate_script": "# Try to restart time sync service\nif command -v chronyc >/dev/null 2>&1; then\n    systemctl restart chronyd 2>/dev/null\n    chronyc makestep 2>/dev/null\n    echo \"REMEDIATED:chronyd_restarted\"\n    exit 0\nfi\nif systemctl list-unit-files ntpd.service 2>/dev/null | grep -q ntpd; then\n    systemctl restart ntpd 2>/dev/null\n    echo \"REMEDIATED:ntpd_restarted\"\n    exit 0\nfi\nif systemctl list-unit-files systemd-timesyncd.service 2>/dev/null | grep -q timesyncd; then\n    systemctl restart systemd-timesyncd 2>/dev/null\n    timedatectl set-ntp true 2>/dev/null\n    echo \"REMEDIATED:timesyncd_restarted\"\n    exit 0\nfi\necho \"ALERT:no_ntp_service_found  install chrony or enable systemd-timesyncd\"",
    "verify_script": "if command -v chronyc &>/dev/null && systemctl is-active chronyd &>/dev/null; then\n            SYNC=$(chronyc tracking 2>/dev/null | grep \"Leap status\" | awk '{print $4}')\n            if [ \"$SYNC\" = \"Normal\" ]; then\n                echo \"VERIFIED:chrony_synced\"\n                exit 0\n            fi\n        fi\n        echo \"VERIFY_FAILED\"\n        exit 1",
    "hipaa_controls": [
      "164.312(b)",
      "164.308(a)(1)(ii)(D)"
    ],
    "severity": "high",
    "timeout_seconds": 120
  },
  "LIN-PATCH-001": {
    "id": "LIN-PATCH-001",
    "name": "Auto-Update Timer Enabled",
    "platform": "linux",
    "detect_script": "# NixOS: check if auto-upgrade timer is active\nif [ -f /etc/NIXOS ]; then\n    if systemctl is-active nixos-upgrade.timer >/dev/null 2>&1; then\n        echo \"COMPLIANT:nixos_upgrade_timer_active\"\n        exit 0\n    else\n        echo \"DRIFT:nixos_upgrade_timer_not_active\"\n        exit 1\n    fi\nfi\n# Debian/Ubuntu\nif command -v apt-get >/dev/null 2>&1; then\n    apt-get update -qq 2>/dev/null\n    SECURITY=$(apt-get -s upgrade 2>/dev/null | grep -i security | wc -l)\n    if [ \"$SECURITY\" -eq 0 ]; then\n        echo \"COMPLIANT:no_security_updates\"\n        exit 0\n    else\n        echo \"DRIFT:security_updates_available=$SECURITY\"\n        exit 1\n    fi\nfi\n# RHEL/CentOS\nif command -v yum >/dev/null 2>&1; then\n    SECURITY=$(yum check-update --security 2>/dev/null | grep -v '^$' | wc -l)\n    if [ \"$SECURITY\" -le 1 ]; then\n        echo \"COMPLIANT:no_security_updates\"\n        exit 0\n    else\n        echo \"DRIFT:security_updates_available=$SECURITY\"\n        exit 1\n    fi\nfi\necho \"UNKNOWN:no_package_manager\"\nexit 1",
    "remediate_script": "# Enable auto-update timer based on distro\nif [ -f /etc/NIXOS ]; then\n    # NixOS: enable nixos-upgrade.timer if the unit file exists\n    if systemctl list-unit-files nixos-upgrade.timer 2>/dev/null | grep -q nixos-upgrade; then\n        systemctl enable --now nixos-upgrade.timer 2>/dev/null\n        echo \"REMEDIATED:nixos_upgrade_timer_enabled\"\n    else\n        # Timer unit doesn't exist \u2014 needs system.autoUpgrade in configuration.nix\n        echo \"SKIP:nixos_autoUpgrade_not_configured\"\n        exit 0\n    fi\nelif command -v apt-get &>/dev/null; then\n    DEBIAN_FRONTEND=noninteractive apt-get install -y unattended-upgrades 2>/dev/null\n    systemctl enable --now unattended-upgrades.timer 2>/dev/null\n    echo \"REMEDIATED:unattended_upgrades_enabled\"\nelif command -v dnf &>/dev/null; then\n    dnf install -y dnf-automatic 2>/dev/null\n    systemctl enable --now dnf-automatic.timer 2>/dev/null\n    echo \"REMEDIATED:dnf_automatic_enabled\"\nelse\n    echo \"SKIP:unknown_distro\"\n    exit 0\nfi",
    "verify_script": "if systemctl is-active nixos-upgrade.timer &>/dev/null; then\n    echo \"VERIFIED:nixos_upgrade_timer_active\"\n    exit 0\nelif systemctl is-active unattended-upgrades.timer &>/dev/null; then\n    echo \"VERIFIED:unattended_upgrades_active\"\n    exit 0\nelif systemctl is-active dnf-automatic.timer &>/dev/null; then\n    echo \"VERIFIED:dnf_automatic_active\"\n    exit 0\nelse\n    echo \"VERIFY_FAILED:no_auto_update_timer\"\n    exit 1\nfi",
    "hipaa_controls": [
      "164.308(a)(5)(ii)(B)"
    ],
    "severity": "high",
    "timeout_seconds": 600
  },
  "LIN-PERM-001": {
    "id": "LIN-PERM-001",
    "name": "Shadow File Permissions",
    "platform": "linux",
    "detect_script": "PERMS=$(stat -c \"%a\" /etc/shadow 2>/dev/null)\n        if [ \"$PERMS\" = \"640\" ] || [ \"$PERMS\" = \"600\" ] || [ \"$PERMS\" = \"000\" ]; then\n            echo \"COMPLIANT:shadow_perms=$PERMS\"\n            exit 0\n        else\n            echo \"DRIFT:shadow_perms=$PERMS\"\n            exit 1\n        fi",
    "remediate_script": "chmod 640 /etc/shadow\n        chown root:shadow /etc/shadow 2>/dev/null || chown root:root /etc/shadow\n        echo \"REMEDIATED\"",
    "verify_script": "PERMS=$(stat -c '%a' /etc/shadow 2>/dev/null)\nif [ \"$PERMS\" = \"640\" ] || [ \"$PERMS\" = \"600\" ] || [ \"$PERMS\" = \"000\" ]; then\n    echo \"VERIFIED:shadow_perms=$PERMS\"\n    exit 0\nelse\n    echo \"VERIFY_FAILED:shadow_perms=$PERMS\"\n    exit 1\nfi",
    "hipaa_controls": [
      "164.312(a)(1)",
      "164.312(c)(1)"
    ],
    "severity": "critical",
    "timeout_seconds": 15
  },
  "LIN-PERM-002": {
    "id": "LIN-PERM-002",
    "name": "SSH Config Permissions",
    "platform": "linux",
    "detect_script": "PERMS=$(stat -c \"%a\" /etc/ssh/sshd_config 2>/dev/null)\n        if [ \"$PERMS\" = \"600\" ] || [ \"$PERMS\" = \"644\" ]; then\n            echo \"COMPLIANT:sshd_config_perms=$PERMS\"\n            exit 0\n        else\n            echo \"DRIFT:sshd_config_perms=$PERMS\"\n            exit 1\n        fi",
    "remediate_script": "chmod 600 /etc/ssh/sshd_config\n        chown root:root /etc/ssh/sshd_config\n        echo \"REMEDIATED\"",
    "verify_script": "PERMS=$(stat -c '%a' /etc/ssh/sshd_config 2>/dev/null)\nif [ \"$PERMS\" = \"600\" ] || [ \"$PERMS\" = \"644\" ]; then\n    echo \"VERIFIED:sshd_config_perms=$PERMS\"\n    exit 0\nelse\n    echo \"VERIFY_FAILED:sshd_config_perms=$PERMS\"\n    exit 1\nfi",
    "hipaa_controls": [
      "164.312(a)(1)"
    ],
    "severity": "high",
    "timeout_seconds": 15
  },
  "LIN-PERM-003": {
    "id": "LIN-PERM-003",
    "name": "No World-Writable Files in /etc",
    "platform": "linux",
    "detect_script": "WW_FILES=$(find /etc -type f -perm -0002 2>/dev/null | head -10)\n        if [ -z \"$WW_FILES\" ]; then\n            echo \"COMPLIANT:no_world_writable\"\n            exit 0\n        else\n            echo \"DRIFT:world_writable_found\"\n            echo \"$WW_FILES\"\n            exit 1\n        fi",
    "remediate_script": "find /etc -type f -perm -0002 -exec chmod o-w {} \\;\n        echo \"REMEDIATED\"",
    "verify_script": "WW_FILES=$(find /etc -type f -perm -0002 2>/dev/null | head -1)\nif [ -z \"$WW_FILES\" ]; then\n    echo \"VERIFIED:no_world_writable\"\n    exit 0\nelse\n    echo \"VERIFY_FAILED:world_writable_still_found\"\n    exit 1\nfi",
    "hipaa_controls": [
      "164.312(c)(1)"
    ],
    "severity": "high",
    "timeout_seconds": 60
  },
  "LIN-PERM-004": {
    "id": "LIN-PERM-004",
    "name": "Sudo Configuration",
    "platform": "linux",
    "detect_script": "DRIFT_ISSUES=\"\"\n        COMPLIANT=true\n\n        # Check for NOPASSWD entries in /etc/sudoers\n        NOPASSWD_MAIN=$(grep -c \"NOPASSWD\" /etc/sudoers 2>/dev/null || echo \"0\")\n\n        # Check for NOPASSWD entries in /etc/sudoers.d/\n        NOPASSWD_DIR=0\n        if [ -d /etc/sudoers.d ]; then\n            NOPASSWD_DIR=$(grep -rc \"NOPASSWD\" /etc/sudoers.d/ 2>/dev/null | awk -F: '{sum+=$2} END {print sum+0}')\n        fi\n\n        NOPASSWD_TOTAL=$((NOPASSWD_MAIN + NOPASSWD_DIR))\n        if [ \"$NOPASSWD_TOTAL\" -gt 0 ]; then\n            DRIFT_ISSUES=\"$DRIFT_ISSUES nopasswd_entries=$NOPASSWD_TOTAL\"\n            COMPLIANT=false\n        fi\n\n        # Check sudoers file permissions (should be 0440)\n        SUDOERS_PERMS=$(stat -c \"%a\" /etc/sudoers 2>/dev/null)\n        if [ \"$SUDOERS_PERMS\" != \"440\" ] && [ \"$SUDOERS_PERMS\" != \"400\" ]; then\n            DRIFT_ISSUES=\"$DRIFT_ISSUES sudoers_perms=$SUDOERS_PERMS\"\n            COMPLIANT=false\n        fi\n\n        if $COMPLIANT; then\n            echo \"COMPLIANT:sudoers_secure\"\n            exit 0\n        else\n            echo \"DRIFT:$DRIFT_ISSUES\"\n            exit 1\n        fi",
    "remediate_script": "FIXED=\"\"\n\n        # Fix sudoers file permissions (safe to auto-fix)\n        SUDOERS_PERMS=$(stat -c \"%a\" /etc/sudoers 2>/dev/null)\n        if [ \"$SUDOERS_PERMS\" != \"440\" ] && [ \"$SUDOERS_PERMS\" != \"400\" ]; then\n            chmod 440 /etc/sudoers\n            chown root:root /etc/sudoers\n            FIXED=\"$FIXED permissions_fixed\"\n        fi\n\n        # Fix sudoers.d directory permissions\n        if [ -d /etc/sudoers.d ]; then\n            chmod 750 /etc/sudoers.d\n            find /etc/sudoers.d -type f -exec chmod 440 {} \\;\n        fi\n\n        # NOPASSWD entries: ALERT ONLY - too risky to auto-remove\n        NOPASSWD_MAIN=$(grep -c \"NOPASSWD\" /etc/sudoers 2>/dev/null || echo \"0\")\n        NOPASSWD_DIR=0\n        if [ -d /etc/sudoers.d ]; then\n            NOPASSWD_DIR=$(grep -rc \"NOPASSWD\" /etc/sudoers.d/ 2>/dev/null | awk -F: '{sum+=$2} END {print sum+0}')\n        fi\n        NOPASSWD_TOTAL=$((NOPASSWD_MAIN + NOPASSWD_DIR))\n\n        if [ \"$NOPASSWD_TOTAL\" -gt 0 ]; then\n            echo \"ALERT:nopasswd_entries=$NOPASSWD_TOTAL requires manual review\"\n            echo \"REMEDIATED:partial - permissions fixed, NOPASSWD requires L2 review\"\n        else\n            echo \"REMEDIATED\"\n        fi",
    "verify_script": "SUDOERS_PERMS=$(stat -c \"%a\" /etc/sudoers 2>/dev/null)\n        NOPASSWD_MAIN=$(grep -c \"NOPASSWD\" /etc/sudoers 2>/dev/null || echo \"0\")\n        NOPASSWD_DIR=0\n        if [ -d /etc/sudoers.d ]; then\n            NOPASSWD_DIR=$(grep -rc \"NOPASSWD\" /etc/sudoers.d/ 2>/dev/null | awk -F: '{sum+=$2} END {print sum+0}')\n        fi\n        NOPASSWD_TOTAL=$((NOPASSWD_MAIN + NOPASSWD_DIR))\n\n        echo \"sudoers_perms=$SUDOERS_PERMS nopasswd_count=$NOPASSWD_TOTAL\"\n        if [ \"$SUDOERS_PERMS\" = \"440\" ] || [ \"$SUDOERS_PERMS\" = \"400\" ]; then\n            if [ \"$NOPASSWD_TOTAL\" -eq 0 ]; then\n                echo \"VERIFIED\"\n                exit 0\n            else\n                echo \"VERIFIED:partial - permissions ok, nopasswd=$NOPASSWD_TOTAL requires manual review\"\n                exit 1\n            fi\n        fi\n        echo \"VERIFY_FAILED\"\n        exit 1",
    "hipaa_controls": [
      "164.312(a)(1)"
    ],
    "severity": "high",
    "timeout_seconds": 30
  },
  "LIN-SSH-001": {
    "id": "LIN-SSH-001",
    "name": "SSH Root Login Disabled",
    "platform": "linux",
    "detect_script": "VALUE=$(grep -E '^PermitRootLogin' /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}')\nif [ \"$VALUE\" = \"no\" ] || [ \"$VALUE\" = \"prohibit-password\" ]; then\n    echo \"COMPLIANT:PermitRootLogin=$VALUE\"\n    exit 0\nelse\n    echo \"DRIFT:PermitRootLogin=$VALUE\"\n    exit 1\nfi",
    "remediate_script": "# NixOS: /etc/ssh/sshd_config is a read-only symlink  managed by configuration.nix\nif [ -f /etc/NIXOS ]; then\n    VALUE=$(grep -E '^PermitRootLogin' /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}')\n    if [ \"$VALUE\" = \"prohibit-password\" ] || [ \"$VALUE\" = \"no\" ]; then\n        echo \"REMEDIATED:nixos_ssh_already_hardened\"\n        exit 0\n    fi\n    echo \"SKIP:nixos_requires_configuration_change\"\n    exit 0\nfi\n\n# Standard Linux: modify sshd_config\nsed -i 's/^#*PermitRootLogin.*/PermitRootLogin no/' /etc/ssh/sshd_config\nif ! grep -q '^PermitRootLogin' /etc/ssh/sshd_config; then\n    echo 'PermitRootLogin no' >> /etc/ssh/sshd_config\nfi\nsystemctl reload sshd\necho \"REMEDIATED\"",
    "verify_script": "VALUE=$(grep -E '^PermitRootLogin' /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}')\nif [ \"$VALUE\" = \"no\" ] || [ \"$VALUE\" = \"prohibit-password\" ]; then\n    echo \"VERIFIED\"\n    exit 0\nelse\n    echo \"VERIFY_FAILED:PermitRootLogin=$VALUE\"\n    exit 1\nfi",
    "hipaa_controls": [
      "164.312(d)",
      "164.312(a)(1)"
    ],
    "severity": "high",
    "timeout_seconds": 30
  },
  "LIN-SSH-002": {
    "id": "LIN-SSH-002",
    "name": "SSH Password Authentication Disabled",
    "platform": "linux",
    "detect_script": "VALUE=$(grep -E \"^PasswordAuthentication\" /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}')\n        if [ \"$VALUE\" = \"no\" ]; then\n            echo \"COMPLIANT\"\n            exit 0\n        else\n            echo \"DRIFT:PasswordAuthentication=$VALUE\"\n            exit 1\n        fi",
    "remediate_script": "# NixOS: sshd_config is read-only  managed by services.openssh in configuration.nix\nif [ -f /etc/NIXOS ]; then\n    VALUE=$(grep -E '^PasswordAuthentication' /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}')\n    if [ \"$VALUE\" = \"no\" ]; then\n        echo \"REMEDIATED:nixos_password_auth_already_disabled\"\n        exit 0\n    fi\n    echo \"SKIP:nixos_requires_configuration_change  set services.openssh.settings.PasswordAuthentication = false\"\n    exit 0\nfi\n# Standard Linux\nsed -i 's/^#*PasswordAuthentication.*/PasswordAuthentication no/' /etc/ssh/sshd_config\nif ! grep -q '^PasswordAuthentication' /etc/ssh/sshd_config; then\n    echo 'PasswordAuthentication no' >> /etc/ssh/sshd_config\nfi\nsystemctl reload sshd\necho \"REMEDIATED\"",
    "verify_script": "VALUE=$(grep -E '^PasswordAuthentication' /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}')\nif [ \"$VALUE\" = \"no\" ]; then\n    echo \"VERIFIED:password_auth_disabled\"\n    exit 0\nelse\n    echo \"VERIFY_FAILED:PasswordAuthentication=$VALUE\"\n    exit 1\nfi",
    "hipaa_controls": [
      "164.312(d)",
      "164.312(a)(1)"
    ],
    "severity": "high",
    "timeout_seconds": 30
  },
  "LIN-SSH-003": {
    "id": "LIN-SSH-003",
    "name": "SSH Max Auth Tries",
    "platform": "linux",
    "detect_script": "VALUE=$(grep -E \"^MaxAuthTries\" /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}')\n        if [ -n \"$VALUE\" ] && [ \"$VALUE\" -le 3 ]; then\n            echo \"COMPLIANT:MaxAuthTries=$VALUE\"\n            exit 0\n        else\n            echo \"DRIFT:MaxAuthTries=${VALUE:-not_set}\"\n            exit 1\n        fi",
    "remediate_script": "# NixOS: sshd_config is read-only  managed by services.openssh in configuration.nix\nif [ -f /etc/NIXOS ]; then\n    VALUE=$(grep -E '^MaxAuthTries' /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}')\n    if [ -n \"$VALUE\" ] && [ \"$VALUE\" -le 3 ]; then\n        echo \"REMEDIATED:nixos_max_auth_tries_ok=$VALUE\"\n        exit 0\n    fi\n    echo \"SKIP:nixos_requires_configuration_change  set services.openssh.settings.MaxAuthTries = 3\"\n    exit 0\nfi\n# Standard Linux\nsed -i 's/^#*MaxAuthTries.*/MaxAuthTries 3/' /etc/ssh/sshd_config\nif ! grep -q '^MaxAuthTries' /etc/ssh/sshd_config; then\n    echo 'MaxAuthTries 3' >> /etc/ssh/sshd_config\nfi\nsystemctl reload sshd\necho \"REMEDIATED\"",
    "verify_script": "VALUE=$(grep -E '^MaxAuthTries' /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}')\nif [ -n \"$VALUE\" ] && [ \"$VALUE\" -le 3 ]; then\n    echo \"VERIFIED:MaxAuthTries=$VALUE\"\n    exit 0\nelse\n    echo \"VERIFY_FAILED:MaxAuthTries=${VALUE:-not_set}\"\n    exit 1\nfi",
    "hipaa_controls": [
      "164.312(a)(1)"
    ],
    "severity": "medium",
    "timeout_seconds": 30
  },
  "LIN-SSH-004": {
    "id": "LIN-SSH-004",
    "name": "SSH Idle Timeout",
    "platform": "linux",
    "detect_script": "INTERVAL=$(grep -E \"^ClientAliveInterval\" /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}')\n        COUNTMAX=$(grep -E \"^ClientAliveCountMax\" /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}')\n        if [ -n \"$INTERVAL\" ] && [ \"$INTERVAL\" -le 300 ] && [ -n \"$COUNTMAX\" ] && [ \"$COUNTMAX\" -eq 0 ]; then\n            echo \"COMPLIANT:ClientAliveInterval=$INTERVAL,ClientAliveCountMax=$COUNTMAX\"\n            exit 0\n        else\n            echo \"DRIFT:ClientAliveInterval=${INTERVAL:-not_set},ClientAliveCountMax=${COUNTMAX:-not_set}\"\n            exit 1\n        fi",
    "remediate_script": "# NixOS: sshd_config is read-only  managed by services.openssh in configuration.nix\nif [ -f /etc/NIXOS ]; then\n    INTERVAL=$(grep -E '^ClientAliveInterval' /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}')\n    COUNTMAX=$(grep -E '^ClientAliveCountMax' /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}')\n    if [ -n \"$INTERVAL\" ] && [ \"$INTERVAL\" -le 300 ] && [ -n \"$COUNTMAX\" ] && [ \"$COUNTMAX\" -eq 0 ]; then\n        echo \"REMEDIATED:nixos_ssh_idle_timeout_ok\"\n        exit 0\n    fi\n    echo \"SKIP:nixos_requires_configuration_change  set services.openssh.settings.ClientAliveInterval and ClientAliveCountMax\"\n    exit 0\nfi\n# Standard Linux\nsed -i 's/^#*ClientAliveInterval.*/ClientAliveInterval 300/' /etc/ssh/sshd_config\ngrep -q '^ClientAliveInterval' /etc/ssh/sshd_config || echo 'ClientAliveInterval 300' >> /etc/ssh/sshd_config\nsed -i 's/^#*ClientAliveCountMax.*/ClientAliveCountMax 0/' /etc/ssh/sshd_config\ngrep -q '^ClientAliveCountMax' /etc/ssh/sshd_config || echo 'ClientAliveCountMax 0' >> /etc/ssh/sshd_config\nsystemctl reload sshd\necho \"REMEDIATED\"",
    "verify_script": "INTERVAL=$(grep -E \"^ClientAliveInterval\" /etc/ssh/sshd_config | awk '{print $2}')\n        COUNTMAX=$(grep -E \"^ClientAliveCountMax\" /etc/ssh/sshd_config | awk '{print $2}')\n        if [ \"$INTERVAL\" = \"300\" ] && [ \"$COUNTMAX\" = \"0\" ]; then\n            echo \"VERIFIED\"\n            exit 0\n        else\n            echo \"VERIFY_FAILED:ClientAliveInterval=$INTERVAL,ClientAliveCountMax=$COUNTMAX\"\n            exit 1\n        fi",
    "hipaa_controls": [
      "164.312(a)(2)(iii)"
    ],
    "severity": "high",
    "timeout_seconds": 30
  },
  "LIN-SUID-001": {
    "id": "LIN-SUID-001",
    "name": "Unauthorized SUID Binary Cleanup",
    "platform": "linux",
    "detect_script": "SUID_FOUND=$(find /tmp /var/tmp /dev/shm -perm -4000 -type f 2>/dev/null)\n        if [ -z \"$SUID_FOUND\" ]; then\n            echo \"COMPLIANT\"\n            exit 0\n        else\n            COUNT=$(echo \"$SUID_FOUND\" | wc -l)\n            echo \"DRIFT:suid_binaries_found=$COUNT\"\n            echo \"$SUID_FOUND\"\n            exit 1\n        fi",
    "remediate_script": "REMOVED=0\n        for f in $(find /tmp /var/tmp /dev/shm -perm -4000 -type f 2>/dev/null); do\n            rm -f \"$f\" && REMOVED=$((REMOVED+1))\n        done\n        echo \"REMEDIATED:removed=$REMOVED\"",
    "verify_script": "SUID_FOUND=$(find /tmp /var/tmp /dev/shm -perm -4000 -type f 2>/dev/null)\n        if [ -z \"$SUID_FOUND\" ]; then\n            echo \"VERIFIED\"\n            exit 0\n        else\n            echo \"VERIFY_FAILED\"\n            exit 1\n        fi",
    "hipaa_controls": [
      "164.312(a)(1)",
      "164.308(a)(5)(ii)(C)"
    ],
    "severity": "critical",
    "timeout_seconds": 30
  },
  "LIN-SVC-001": {
    "id": "LIN-SVC-001",
    "name": "Failed Service Restart",
    "platform": "linux",
    "detect_script": "if systemctl is-active sshd &>/dev/null || systemctl is-active ssh &>/dev/null; then\n            echo \"COMPLIANT:sshd_running\"\n            exit 0\n        else\n            echo \"DRIFT:sshd_not_running\"\n            exit 1\n        fi",
    "remediate_script": "# Restart all failed systemd services\nfailed=$(systemctl --failed --no-legend --no-pager 2>/dev/null | awk '{print $1}')\nif [ -z \"$failed\" ]; then\n    echo \"REMEDIATED:no_failed_services\"\n    exit 0\nfi\nrestarted=0\nstill_failed=0\nfor svc in $failed; do\n    if systemctl restart \"$svc\" 2>/dev/null; then\n        restarted=$((restarted + 1))\n    else\n        still_failed=$((still_failed + 1))\n    fi\ndone\necho \"REMEDIATED:restarted=$restarted,still_failed=$still_failed\"",
    "verify_script": "failed_count=$(systemctl --failed --no-legend --no-pager 2>/dev/null | wc -l)\nfailed_count=$(echo \"$failed_count\" | tr -dc '0-9')\nif [ \"$failed_count\" -eq 0 ] 2>/dev/null; then\n    echo \"VERIFIED:no_failed_services\"\n    exit 0\nelse\n    echo \"VERIFY_FAILED:failed_count=$failed_count\"\n    exit 1\nfi",
    "hipaa_controls": [
      "164.312(a)(1)"
    ],
    "severity": "critical",
    "timeout_seconds": 30
  },
  "LIN-SVC-002": {
    "id": "LIN-SVC-002",
    "name": "Audit Daemon Running",
    "platform": "linux",
    "detect_script": "if systemctl is-active auditd &>/dev/null; then\n            echo \"COMPLIANT:auditd_running\"\n            exit 0\n        else\n            echo \"DRIFT:auditd_not_running\"\n            exit 1\n        fi",
    "remediate_script": "# Restart auditd if it exists\nif systemctl list-unit-files auditd.service 2>/dev/null | grep -q auditd; then\n    systemctl restart auditd 2>/dev/null\n    echo \"REMEDIATED:auditd_restarted\"\n    exit 0\nfi\necho \"ALERT:auditd_not_installed  on NixOS, enable security.auditd in configuration.nix\"",
    "verify_script": "if systemctl is-active auditd >/dev/null 2>&1; then\n    echo \"VERIFIED:auditd_running\"\n    exit 0\nelse\n    echo \"VERIFY_FAILED:auditd_not_running\"\n    exit 1\nfi",
    "hipaa_controls": [
      "164.312(b)"
    ],
    "severity": "high",
    "timeout_seconds": 60
  },
  "LIN-SVC-003": {
    "id": "LIN-SVC-003",
    "name": "Rsyslog Running",
    "platform": "linux",
    "detect_script": "if systemctl is-active rsyslog &>/dev/null; then\n            echo \"COMPLIANT:rsyslog_running\"\n            exit 0\n        else\n            echo \"DRIFT:rsyslog_not_running\"\n            exit 1\n        fi",
    "remediate_script": "systemctl enable rsyslog\n        systemctl start rsyslog\n        echo \"REMEDIATED\"",
    "verify_script": "if systemctl is-active rsyslog >/dev/null 2>&1; then\n    echo \"VERIFIED:rsyslog_running\"\n    exit 0\nelse\n    echo \"VERIFY_FAILED:rsyslog_not_running\"\n    exit 1\nfi",
    "hipaa_controls": [
      "164.312(b)"
    ],
    "severity": "high",
    "timeout_seconds": 30
  },
  "LIN-SVC-004": {
    "id": "LIN-SVC-004",
    "name": "No Telnet Service",
    "platform": "linux",
    "detect_script": "if systemctl is-active telnet &>/dev/null ||            systemctl is-active xinetd &>/dev/null && grep -q \"telnet\" /etc/xinetd.d/* 2>/dev/null; then\n            echo \"DRIFT:telnet_running\"\n            exit 1\n        else\n            echo \"COMPLIANT:no_telnet\"\n            exit 0\n        fi",
    "remediate_script": "# Stop telnet service if running\nsystemctl stop telnet 2>/dev/null || true\nsystemctl disable telnet 2>/dev/null || true\n# NixOS: packages are managed declaratively  just stop the service\nif [ -f /etc/NIXOS ]; then\n    echo \"REMEDIATED:nixos_telnet_stopped  remove from environment.systemPackages in configuration.nix\"\n    exit 0\nfi\n# Standard Linux: remove the package\napt-get remove -y telnetd 2>/dev/null || yum remove -y telnet-server 2>/dev/null || true\necho \"REMEDIATED\"",
    "verify_script": "if systemctl is-active telnet >/dev/null 2>&1; then\n    echo \"VERIFY_FAILED:telnet_still_running\"\n    exit 1\nelse\n    echo \"VERIFIED:no_telnet\"\n    exit 0\nfi",
    "hipaa_controls": [
      "164.312(e)(1)"
    ],
    "severity": "critical",
    "timeout_seconds": 30
  },
  "LIN-DISK-001": {
    "id": "LIN-DISK-001",
    "name": "Linux Disk Space Cleanup",
    "platform": "linux",
    "detect_script": "USAGE=$(df -h / | awk 'NR==2 {print $5}' | tr -d '%')\nif [ \"$USAGE\" -lt 90 ]; then\n    echo \"COMPLIANT:disk_usage=${USAGE}%\"\n    exit 0\nelse\n    echo \"DRIFT:disk_usage=${USAGE}%\"\n    exit 1\nfi",
    "remediate_script": "journalctl --vacuum-size=100M 2>/dev/null || true\nfind /tmp -type f -atime +7 -delete 2>/dev/null || true\nnix-collect-garbage -d 2>/dev/null || true\ndf -h /\necho \"REMEDIATED\"",
    "verify_script": "USAGE=$(df -h / | awk 'NR==2 {gsub(/%/,\"\",$5); if($5<90) print \"OK: \"$5\"%\"; else {print \"STILL HIGH: \"$5\"%\"; exit 1}}')\necho \"$USAGE\"\nif echo \"$USAGE\" | grep -q '^OK'; then\n    echo \"VERIFIED\"\n    exit 0\nelse\n    echo \"VERIFY_FAILED\"\n    exit 1\nfi",
    "hipaa_controls": [
      "164.312(a)(1)"
    ],
    "severity": "medium",
    "timeout_seconds": 300
  },
  "LIN-CERT-001": {
    "id": "LIN-CERT-001",
    "name": "Linux Certificate Renewal",
    "platform": "linux",
    "detect_script": "# Check certificate expiry for common cert locations\nCERT_FILES=$(find /etc/ssl/certs /etc/pki/tls/certs /etc/letsencrypt/live -name '*.pem' -o -name '*.crt' 2>/dev/null | head -5)\nEXPIRING=0\nfor CERT in $CERT_FILES; do\n    EXPIRY=$(openssl x509 -enddate -noout -in \"$CERT\" 2>/dev/null | cut -d= -f2)\n    if [ -n \"$EXPIRY\" ]; then\n        EXPIRY_EPOCH=$(date -d \"$EXPIRY\" +%s 2>/dev/null || date -j -f '%b %d %H:%M:%S %Y %Z' \"$EXPIRY\" +%s 2>/dev/null)\n        NOW_EPOCH=$(date +%s)\n        DAYS_LEFT=$(( (EXPIRY_EPOCH - NOW_EPOCH) / 86400 ))\n        if [ \"$DAYS_LEFT\" -lt 30 ]; then\n            EXPIRING=$((EXPIRING + 1))\n        fi\n    fi\ndone\nif [ \"$EXPIRING\" -eq 0 ]; then\n    echo \"COMPLIANT:no_expiring_certs\"\n    exit 0\nelse\n    echo \"DRIFT:expiring_certs=$EXPIRING\"\n    exit 1\nfi",
    "remediate_script": "if command -v certbot >/dev/null 2>&1; then\n    certbot renew --non-interactive\nelif command -v acme.sh >/dev/null 2>&1; then\n    acme.sh --renew-all\nelse\n    echo 'No ACME client found'\n    exit 1\nfi\necho \"REMEDIATED\"",
    "verify_script": "CERT_FILES=$(find /etc/ssl/certs /etc/pki/tls/certs /etc/letsencrypt/live -name '*.pem' -o -name '*.crt' 2>/dev/null | head -5)\nEXPIRING=0\nfor CERT in $CERT_FILES; do\n    EXPIRY=$(openssl x509 -enddate -noout -in \"$CERT\" 2>/dev/null | cut -d= -f2)\n    if [ -n \"$EXPIRY\" ]; then\n        EXPIRY_EPOCH=$(date -d \"$EXPIRY\" +%s 2>/dev/null || date -j -f '%b %d %H:%M:%S %Y %Z' \"$EXPIRY\" +%s 2>/dev/null)\n        NOW_EPOCH=$(date +%s)\n        DAYS_LEFT=$(( (EXPIRY_EPOCH - NOW_EPOCH) / 86400 ))\n        if [ \"$DAYS_LEFT\" -lt 30 ]; then\n            EXPIRING=$((EXPIRING + 1))\n        fi\n    fi\ndone\nif [ \"$EXPIRING\" -eq 0 ]; then\n    echo \"VERIFIED:all_certs_valid\"\n    exit 0\nelse\n    echo \"VERIFY_FAILED:still_expiring=$EXPIRING\"\n    exit 1\nfi",
    "hipaa_controls": [
      "164.312(e)(1)"
    ],
    "severity": "high",
    "timeout_seconds": 120
  },
  "RB-WIN-SEC-022": {
    "id": "RB-WIN-SEC-022",
    "name": "Password Policy Enforcement",
    "platform": "windows",
    "detect_script": "# Check password policy via net accounts\n$NetAccounts = net accounts 2>&1\n$Result = @{\n    Drifted = $false\n    Issues = @()\n}\n\nforeach ($Line in $NetAccounts) {\n    if ($Line -match 'Minimum password length:\\s*(\\d+)') {\n        $MinLen = [int]$Matches[1]\n        $Result.MinPasswordLength = $MinLen\n        if ($MinLen -lt 14) {\n            $Result.Drifted = $true\n            $Result.Issues += \"Min password length $MinLen < 14\"\n        }\n    }\n    if ($Line -match 'Lockout threshold:\\s*(\\d+|Never)') {\n        $Val = $Matches[1]\n        $Result.LockoutThreshold = $Val\n        if ($Val -eq 'Never' -or [int]$Val -eq 0 -or [int]$Val -gt 5) {\n            $Result.Drifted = $true\n            $Result.Issues += \"Lockout threshold not configured properly\"\n        }\n    }\n}\n\n# Check complexity via secedit\n$TempCfg = \"$env:TEMP\\secpol_pwcheck.cfg\"\nsecedit /export /cfg $TempCfg /areas SECURITYPOLICY 2>&1 | Out-Null\nif (Test-Path $TempCfg) {\n    $SecPol = Get-Content $TempCfg\n    $Complexity = ($SecPol | Select-String 'PasswordComplexity\\s*=\\s*1') -ne $null\n    $Result.ComplexityEnabled = $Complexity\n    if (-not $Complexity) {\n        $Result.Drifted = $true\n        $Result.Issues += \"Password complexity not enabled\"\n    }\n    Remove-Item $TempCfg -Force -ErrorAction SilentlyContinue\n}\n\n$Result | ConvertTo-Json -Depth 2",
    "remediate_script": "# Enforce password policy\nnet accounts /minpwlen:14 /minpwage:1 /maxpwage:90 /lockoutthreshold:5 2>&1 | Out-Null\n\n@{\n    Success = $true\n    Actions = @('Set min password length to 14', 'Set min password age to 1 day', 'Set max password age to 90 days', 'Set lockout threshold to 5')\n} | ConvertTo-Json",
    "verify_script": "# Verify password policy\n$NetAccounts = net accounts 2>&1\n$MinLen = 0\n$Lockout = 0\nforeach ($Line in $NetAccounts) {\n    if ($Line -match 'Minimum password length:\\s*(\\d+)') { $MinLen = [int]$Matches[1] }\n    if ($Line -match 'Lockout threshold:\\s*(\\d+)') { $Lockout = [int]$Matches[1] }\n}\n@{\n    MinPasswordLength = $MinLen\n    LockoutThreshold = $Lockout\n    Verified = ($MinLen -ge 14 -and $Lockout -ge 1 -and $Lockout -le 5)\n} | ConvertTo-Json",
    "hipaa_controls": [
      "164.312(d)",
      "164.312(a)(1)"
    ],
    "severity": "high",
    "timeout_seconds": 120
  },
  "RB-WIN-SEC-023": {
    "id": "RB-WIN-SEC-023",
    "name": "RDP NLA Enforcement",
    "platform": "windows",
    "detect_script": "# Check if NLA is required for RDP\ntry {\n    $NLA = (Get-WmiObject -Class Win32_TSGeneralSetting -Namespace root\\CIMV2\\TerminalServices).UserAuthenticationRequired\n    $Result = @{\n        NLAEnabled = ($NLA -eq 1)\n        Drifted = ($NLA -ne 1)\n    }\n} catch {\n    $Result = @{\n        Error = $_.Exception.Message\n        Drifted = $true\n    }\n}\n$Result | ConvertTo-Json",
    "remediate_script": "# Enable Network Level Authentication for RDP\ntry {\n    Set-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp' -Name 'UserAuthentication' -Value 1\n    @{\n        Success = $true\n        Action = 'Enabled NLA for RDP'\n    } | ConvertTo-Json\n} catch {\n    @{\n        Success = $false\n        Error = $_.Exception.Message\n    } | ConvertTo-Json\n}",
    "verify_script": "try {\n    $NLA = (Get-WmiObject -Class Win32_TSGeneralSetting -Namespace root\\CIMV2\\TerminalServices).UserAuthenticationRequired\n    @{\n        NLAEnabled = ($NLA -eq 1)\n        Verified = ($NLA -eq 1)\n    } | ConvertTo-Json\n} catch {\n    @{ Verified = $false; Error = $_.Exception.Message } | ConvertTo-Json\n}",
    "hipaa_controls": [
      "164.312(d)",
      "164.312(a)(1)"
    ],
    "severity": "high",
    "timeout_seconds": 60
  },
  "RB-WIN-SEC-024": {
    "id": "RB-WIN-SEC-024",
    "name": "Guest Account Disable",
    "platform": "windows",
    "detect_script": "# Check if Guest account is enabled\ntry {\n    $Guest = Get-LocalUser -Name 'Guest'\n    @{\n        GuestEnabled = $Guest.Enabled\n        Drifted = $Guest.Enabled\n    } | ConvertTo-Json\n} catch {\n    @{\n        Error = $_.Exception.Message\n        Drifted = $false\n    } | ConvertTo-Json\n}",
    "remediate_script": "# Disable the Guest account\ntry {\n    Disable-LocalUser -Name 'Guest'\n    @{\n        Success = $true\n        Action = 'Disabled Guest account'\n    } | ConvertTo-Json\n} catch {\n    @{\n        Success = $false\n        Error = $_.Exception.Message\n    } | ConvertTo-Json\n}",
    "verify_script": "try {\n    $g = Get-LocalUser -Name 'Guest'\n    if (-not $g.Enabled) {\n        @{ Verified = $true } | ConvertTo-Json\n    } else {\n        @{ Verified = $false } | ConvertTo-Json\n    }\n} catch {\n    @{ Verified = $false; Error = $_.Exception.Message } | ConvertTo-Json\n}",
    "hipaa_controls": [
      "164.312(a)(1)",
      "164.308(a)(3)(ii)(B)"
    ],
    "severity": "high",
    "timeout_seconds": 60
  }
}
